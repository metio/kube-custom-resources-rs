// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/ansible/awx-operator/awx.ansible.com/v1beta1/awxs.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "awx.ansible.com", version = "v1beta1", kind = "AWX", plural = "awxs")]
#[kube(namespaced)]
#[kube(status = "AwxStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct AwxSpec {
    /// Additional labels defined on the resource, which should be propagated to child resources
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub additional_labels: Option<Vec<String>>,
    /// The admin user email
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub admin_email: Option<String>,
    /// Secret where the admin password can be found
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub admin_password_secret: Option<String>,
    /// Username to use for the admin account
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub admin_user: Option<String>,
    /// If specified, the pod's scheduling constraints
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<AwxAffinity>,
    /// Common annotations for both Web and Task deployments.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<String>,
    /// An optional configuration to add a prefix in the API URL path
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_urlpattern_prefix: Option<String>,
    /// apiVersion of the deployment type
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    /// Should AWX instances be automatically upgraded when operator gets upgraded
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auto_upgrade: Option<bool>,
    /// Secret where the broadcast websocket secret can be found
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub broadcast_websocket_secret: Option<String>,
    /// Secret where can be found the trusted Certificate Authority Bundle
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bundle_cacert_secret: Option<String>,
    /// Path where the trusted CA bundle is available
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca_trust_bundle: Option<String>,
    /// Registry path to the Execution Environment container image to use on control plane pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub control_plane_ee_image: Option<String>,
    /// Assign a preexisting priority class to the control plane pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub control_plane_priority_class: Option<String>,
    /// Whether or not to preload data upon instance creation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub create_preload_data: Option<bool>,
    /// Set csrf cookie secure mode for web
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub csrf_cookie_secure: Option<String>,
    /// Name of the deployment type
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment_type: Option<String>,
    /// If the deployment should be done in development mode
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub development_mode: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ee_extra_env: Option<String>,
    /// Specify volume mounts to be added to Execution container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ee_extra_volume_mounts: Option<String>,
    /// Registry path to the Execution Environment container to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ee_images: Option<Vec<AwxEeImages>>,
    /// Secret where pull credentials for registered ees can be found
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ee_pull_credentials_secret: Option<String>,
    /// Resource requirements for the ee container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ee_resource_requirements: Option<AwxEeResourceRequirements>,
    /// Extra settings to specify for AWX
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extra_settings: Option<Vec<AwxExtraSettings>>,
    /// Extra ConfigMaps or Secrets of settings files to specify for AWX
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extra_settings_files: Option<AwxExtraSettingsFiles>,
    /// Specify extra volumes to add to the application pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extra_volumes: Option<String>,
    /// Whether or not to remove secrets upon instance removal
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub garbage_collect_secrets: Option<bool>,
    /// HostAliases for app containers
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host_aliases: Option<Vec<AwxHostAliases>>,
    /// (Deprecated) The hostname of the instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// Scale down deployments to put AWX into an idle state
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub idle_deployment: Option<bool>,
    /// Registry path to the application container to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// The image pull policy
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_pull_policy: Option<AwxImagePullPolicy>,
    /// (Deprecated) Image pull secret for app and database containers
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_pull_secret: Option<String>,
    /// Image pull secrets for app and database containers
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_pull_secrets: Option<Vec<String>>,
    /// Application container image version to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_version: Option<String>,
    /// Annotations to add to the Ingress Controller
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_annotations: Option<String>,
    /// The Ingress API version to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_api_version: Option<String>,
    /// The name of ingress class to use instead of the cluster default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_class_name: Option<String>,
    /// Special configuration for specific Ingress Controllers
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_controller: Option<String>,
    /// Ingress hostnames of the instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_hosts: Option<Vec<AwxIngressHosts>>,
    /// The ingress path used to reach the deployed service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_path: Option<String>,
    /// The ingress path type for the deployed service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_path_type: Option<String>,
    /// (Deprecated) Secret where the Ingress TLS secret can be found
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_tls_secret: Option<String>,
    /// The ingress type to use to reach the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_type: Option<AwxIngressType>,
    /// Extra commands for the init container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub init_container_extra_commands: Option<String>,
    /// Specify volume mounts to be added to the init container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub init_container_extra_volume_mounts: Option<String>,
    /// Registry path to the init container to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub init_container_image: Option<String>,
    /// Init container image version to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub init_container_image_version: Option<String>,
    /// Resource requirements for the init container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub init_container_resource_requirements: Option<AwxInitContainerResourceRequirements>,
    /// Registry path to the init projects container to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub init_projects_container_image: Option<String>,
    /// Disable web container's nginx ipv6 listener
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ipv6_disabled: Option<bool>,
    /// Kind of the deployment type
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// (Deprecated) Secret where can be found the LDAP trusted Certificate Authority Bundle
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ldap_cacert_secret: Option<String>,
    /// (Deprecated) Secret where can be found the LDAP bind password
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ldap_password_secret: Option<String>,
    /// Class of LoadBalancer to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loadbalancer_class: Option<String>,
    /// Assign LoadBalancer IP address
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loadbalancer_ip: Option<String>,
    /// Port to use for the loadbalancer
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loadbalancer_port: Option<i64>,
    /// Protocol to use for the loadbalancer
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loadbalancer_protocol: Option<AwxLoadbalancerProtocol>,
    /// Metrics-Utility ConfigMap
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_configmap: Option<String>,
    /// Enable metrics utility shipping to Red Hat Hybrid Cloud Console
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_console_enabled: Option<bool>,
    /// Metrics-Utility Gather Data CronJob Schedule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_cronjob_gather_schedule: Option<String>,
    /// Metrics-Utility Report CronJob Schedule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_cronjob_report_schedule: Option<String>,
    /// Enable metrics utility
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_enabled: Option<bool>,
    /// Metrics-Utility Image
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_image: Option<String>,
    /// Metrics-Utility Image PullPolicy
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_image_pull_policy: Option<String>,
    /// Metrics-Utility Image Version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_image_version: Option<String>,
    /// Metrics-Utility PVC Claim
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_pvc_claim: Option<String>,
    /// Metrics-Utility PVC Claim Size
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_pvc_claim_size: Option<String>,
    /// Metrics-Utility PVC Claim Storage Class
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_pvc_claim_storage_class: Option<String>,
    /// Metrics-Utility Secret
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_secret: Option<String>,
    /// Metrics-Utility Ship Target
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_ship_target: Option<String>,
    /// Sets the maximum allowed size of the client request body in megabytes (defaults to 5M)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nginx_client_max_body_size: Option<i64>,
    /// Set the socket listen queue size for nginx (defaults to same as uwsgi)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nginx_listen_queue_size: Option<i64>,
    /// Set the number of connections per worker for nginx
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nginx_worker_connections: Option<i64>,
    /// Set the CPU affinity for nginx workers
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nginx_worker_cpu_affinity: Option<String>,
    /// Set the number of workers for nginx
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nginx_worker_processes: Option<i64>,
    /// Configure no_log for no_log tasks
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub no_log: Option<bool>,
    /// nodeSelector for the pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_selector: Option<String>,
    /// Port to use for the nodeport
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nodeport_port: Option<i64>,
    /// Secret where the old database configuration can be found for data migration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub old_postgres_configuration_secret: Option<String>,
    /// Additional parameters for the pg_dump command during a migration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pg_dump_suffix: Option<String>,
    /// Annotations to add to the Postgres deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_annotations: Option<String>,
    /// Secret where the database configuration can be found
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_configuration_secret: Option<String>,
    /// Sets permissions on the /var/lib/pgdata/data for postgres container using an init container (not Openshift)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_data_volume_init: Option<bool>,
    /// (Deprecated, use postgres_extra_settings parameter) Define postgres configuration arguments to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_extra_args: Option<Vec<String>>,
    /// PostgreSQL configuration settings to be added to postgresql.conf
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_extra_settings: Option<Vec<AwxPostgresExtraSettings>>,
    /// Specify volume mounts to be added to Postgres container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_extra_volume_mounts: Option<String>,
    /// Specify extra volumes to add to the application pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_extra_volumes: Option<String>,
    /// Registry path to the PostgreSQL container to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_image: Option<String>,
    /// PostgreSQL container image version to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_image_version: Option<String>,
    /// Customize the postgres init container commands (Non Openshift)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_init_container_commands: Option<String>,
    /// (Deprecated, use postgres_resource_requirements parameter) Resource requirements for the postgres init container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_init_container_resource_requirements: Option<AwxPostgresInitContainerResourceRequirements>,
    /// Specify whether or not to keep the old PVC after PostgreSQL upgrades
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_keep_pvc_after_upgrade: Option<bool>,
    /// Controls whether client-side TCP keepalives are used for Postgres connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_keepalives: Option<bool>,
    /// Controls the number of TCP keepalives that can be lost before the client's connection to the server is considered dead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_keepalives_count: Option<i32>,
    /// Controls the number of seconds of inactivity after which TCP should send a keepalive message to the server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_keepalives_idle: Option<i32>,
    /// Controls the number of seconds after which a TCP keepalive message that is not acknowledged by the server should be retransmitted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_keepalives_interval: Option<i32>,
    /// Label selector used to identify postgres pod for data migration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_label_selector: Option<String>,
    /// Assign a preexisting priority class to the postgres pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_priority_class: Option<String>,
    /// Resource requirements for the PostgreSQL container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_resource_requirements: Option<AwxPostgresResourceRequirements>,
    /// Key/values that will be set under the pod-level securityContext field
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_security_context_settings: Option<BTreeMap<String, serde_json::Value>>,
    /// nodeSelector for the Postgres pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_selector: Option<String>,
    /// Storage class to use for the PostgreSQL PVC
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_storage_class: Option<String>,
    /// Storage requirements for the PostgreSQL container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_storage_requirements: Option<AwxPostgresStorageRequirements>,
    /// node tolerations for the Postgres pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_tolerations: Option<String>,
    /// PersistentVolumeClaim to mount /var/lib/projects directory
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projects_existing_claim: Option<String>,
    /// Whether or not the /var/lib/projects directory will be persistent
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projects_persistence: Option<bool>,
    /// AccessMode for the /var/lib/projects PersistentVolumeClaim
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projects_storage_access_mode: Option<String>,
    /// Storage class for the /var/lib/projects PersistentVolumeClaim
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projects_storage_class: Option<String>,
    /// Size for the /var/lib/projects PersistentVolumeClaim
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projects_storage_size: Option<String>,
    /// Using existing PersistentVolumeClaim
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projects_use_existing_claim: Option<AwxProjectsUseExistingClaim>,
    /// Public base URL
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public_base_url: Option<String>,
    /// Set log level of receptor service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub receptor_log_level: Option<String>,
    /// Redis container capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redis_capabilities: Option<Vec<String>>,
    /// Registry path to the redis container to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redis_image: Option<String>,
    /// Redis container image version to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redis_image_version: Option<String>,
    /// Resource requirements for the redis container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redis_resource_requirements: Option<AwxRedisResourceRequirements>,
    /// Number of instance replicas
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// The route API version to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route_api_version: Option<String>,
    /// The DNS to use to points to the instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route_host: Option<String>,
    /// Secret where the TLS related credentials are stored
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route_tls_secret: Option<String>,
    /// The secure TLS termination mechanism to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route_tls_termination_mechanism: Option<AwxRouteTlsTerminationMechanism>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rsyslog_args: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rsyslog_command: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rsyslog_extra_env: Option<String>,
    /// Specify volume mounts to be added to the Rsyslog container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rsyslog_extra_volume_mounts: Option<String>,
    /// Resource requirements for the rsyslog container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rsyslog_resource_requirements: Option<AwxRsyslogResourceRequirements>,
    /// Secret where the secret key can be found
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_key_secret: Option<String>,
    /// Key/values that will be set under the pod-level securityContext field
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_context_settings: Option<BTreeMap<String, serde_json::Value>>,
    /// ServiceAccount annotations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service_account_annotations: Option<String>,
    /// Annotations to add to the service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service_annotations: Option<String>,
    /// Additional labels to apply to the service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service_labels: Option<String>,
    /// The service type to be used on the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service_type: Option<AwxServiceType>,
    /// Set session cookie secure mode for web
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub session_cookie_secure: Option<String>,
    /// Maintain some of the recommended `app.kubernetes.io/*` labels on the resource (self)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set_self_labels: Option<bool>,
    /// If specified, the pod's scheduling constraints
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_affinity: Option<AwxTaskAffinity>,
    /// Task deployment annotations. This will override the general annotations parameter for the Task deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_annotations: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_args: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_command: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_extra_env: Option<String>,
    /// Specify volume mounts to be added to Task container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_extra_volume_mounts: Option<String>,
    /// Number of consecutive failure events to identify failure of task pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_liveness_failure_threshold: Option<i32>,
    /// Initial delay before starting liveness checks on task pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_liveness_initial_delay: Option<i32>,
    /// Time period in seconds between each liveness check for the task pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_liveness_period: Option<i32>,
    /// Number of seconds to wait for a probe response from task pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_liveness_timeout: Option<i32>,
    /// Enables operator control of replicas count for the task deployment when set to 'true'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_manage_replicas: Option<bool>,
    /// nodeSelector for the task pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_node_selector: Option<String>,
    /// If a privileged security context should be enabled
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_privileged: Option<bool>,
    /// Number of consecutive failure events to identify failure of task pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_readiness_failure_threshold: Option<i32>,
    /// Initial delay before starting readiness checks on task pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_readiness_initial_delay: Option<i32>,
    /// Time period in seconds between each readiness check for the task pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_readiness_period: Option<i32>,
    /// Number of seconds to wait for a probe response from task pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_readiness_timeout: Option<i32>,
    /// Number of task instance replicas
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_replicas: Option<i32>,
    /// Resource requirements for the task container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_resource_requirements: Option<AwxTaskResourceRequirements>,
    /// node tolerations for the task pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_tolerations: Option<String>,
    /// topology rule(s) for the task pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_topology_spread_constraints: Option<String>,
    /// Optional duration in seconds pods needs to terminate gracefully
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub termination_grace_period_seconds: Option<i32>,
    /// node tolerations for the pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<String>,
    /// topology rule(s) for the pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topology_spread_constraints: Option<String>,
    /// Set the socket listen queue size for uwsgi
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uwsgi_listen_queue_size: Option<i64>,
    /// Set the number of uwsgi processes to run in a web container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uwsgi_processes: Option<i64>,
    /// If specified, the pod's scheduling constraints
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_affinity: Option<AwxWebAffinity>,
    /// Web deployment annotations. This will override the general annotations parameter for the Web deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_annotations: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_args: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_command: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_extra_env: Option<String>,
    /// Specify volume mounts to be added to the Web container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_extra_volume_mounts: Option<String>,
    /// Number of consecutive failure events to identify failure of web pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_liveness_failure_threshold: Option<i32>,
    /// Initial delay before starting liveness checks on web pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_liveness_initial_delay: Option<i32>,
    /// Time period in seconds between each liveness check for the web pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_liveness_period: Option<i32>,
    /// Number of seconds to wait for a probe response from web pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_liveness_timeout: Option<i32>,
    /// Enables operator control of replicas count for the web deployment when set to 'true'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_manage_replicas: Option<bool>,
    /// nodeSelector for the web pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_node_selector: Option<String>,
    /// Number of consecutive failure events to identify failure of web pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_readiness_failure_threshold: Option<i32>,
    /// Initial delay before starting readiness checks on web pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_readiness_initial_delay: Option<i32>,
    /// Time period in seconds between each readiness check for the web pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_readiness_period: Option<i32>,
    /// Number of seconds to wait for a probe response from web pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_readiness_timeout: Option<i32>,
    /// Number of web instance replicas
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_replicas: Option<i32>,
    /// Resource requirements for the web container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_resource_requirements: Option<AwxWebResourceRequirements>,
    /// node tolerations for the web pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_tolerations: Option<String>,
    /// topology rule(s) for the web pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_topology_spread_constraints: Option<String>,
}

/// If specified, the pod's scheduling constraints
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<AwxAffinityNodeAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<AwxAffinityPodAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<AwxAffinityPodAntiAffinity>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AwxAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<AwxAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: AwxAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<AwxAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<AwxAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<AwxAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AwxAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<AwxAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: AwxAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AwxAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AwxAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AwxAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AwxAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AwxAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<AwxAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: AwxAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AwxAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AwxAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AwxAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AwxAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxEeImages {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Resource requirements for the ee container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxEeResourceRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AwxEeResourceRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AwxEeResourceRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxEeResourceRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxEeResourceRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxExtraSettings {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub setting: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Extra ConfigMaps or Secrets of settings files to specify for AWX
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxExtraSettingsFiles {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configmaps: Option<Vec<AwxExtraSettingsFilesConfigmaps>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<AwxExtraSettingsFilesSecrets>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxExtraSettingsFilesConfigmaps {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxExtraSettingsFilesSecrets {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxHostAliases {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AwxImagePullPolicy {
    Always,
    #[serde(rename = "always")]
    AlwaysX,
    Never,
    #[serde(rename = "never")]
    NeverX,
    IfNotPresent,
    #[serde(rename = "ifnotpresent")]
    Ifnotpresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxIngressHosts {
    /// Hostname of the instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// Secret where the Ingress TLS secret can be found
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_secret: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AwxIngressType {
    #[serde(rename = "none")]
    None,
    Ingress,
    #[serde(rename = "ingress")]
    IngressX,
    Route,
    #[serde(rename = "route")]
    RouteX,
}

/// Resource requirements for the init container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxInitContainerResourceRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AwxInitContainerResourceRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AwxInitContainerResourceRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxInitContainerResourceRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxInitContainerResourceRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AwxLoadbalancerProtocol {
    #[serde(rename = "http")]
    Http,
    #[serde(rename = "https")]
    Https,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxPostgresExtraSettings {
    /// PostgreSQL configuration parameter name
    pub setting: String,
    /// PostgreSQL configuration parameter value
    pub value: String,
}

/// (Deprecated, use postgres_resource_requirements parameter) Resource requirements for the postgres init container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxPostgresInitContainerResourceRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AwxPostgresInitContainerResourceRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AwxPostgresInitContainerResourceRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxPostgresInitContainerResourceRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxPostgresInitContainerResourceRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

/// Resource requirements for the PostgreSQL container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxPostgresResourceRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AwxPostgresResourceRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AwxPostgresResourceRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxPostgresResourceRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxPostgresResourceRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

/// Storage requirements for the PostgreSQL container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxPostgresStorageRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AwxPostgresStorageRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AwxPostgresStorageRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxPostgresStorageRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxPostgresStorageRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AwxProjectsUseExistingClaim {
    #[serde(rename = "_Yes_")]
    Yes,
    #[serde(rename = "_No_")]
    No,
}

/// Resource requirements for the redis container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxRedisResourceRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AwxRedisResourceRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AwxRedisResourceRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxRedisResourceRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxRedisResourceRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AwxRouteTlsTerminationMechanism {
    Edge,
    #[serde(rename = "edge")]
    EdgeX,
    Passthrough,
    #[serde(rename = "passthrough")]
    PassthroughX,
}

/// Resource requirements for the rsyslog container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxRsyslogResourceRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AwxRsyslogResourceRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AwxRsyslogResourceRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxRsyslogResourceRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxRsyslogResourceRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AwxServiceType {
    LoadBalancer,
    #[serde(rename = "loadbalancer")]
    Loadbalancer,
    #[serde(rename = "ClusterIP")]
    ClusterIp,
    #[serde(rename = "clusterip")]
    Clusterip,
    NodePort,
    #[serde(rename = "nodeport")]
    Nodeport,
}

/// If specified, the pod's scheduling constraints
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<AwxTaskAffinityNodeAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<AwxTaskAffinityPodAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<AwxTaskAffinityPodAntiAffinity>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AwxTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<AwxTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: AwxTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<AwxTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<AwxTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<AwxTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AwxTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<AwxTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: AwxTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AwxTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AwxTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AwxTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AwxTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AwxTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<AwxTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: AwxTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AwxTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AwxTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AwxTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AwxTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Resource requirements for the task container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskResourceRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AwxTaskResourceRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AwxTaskResourceRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskResourceRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxTaskResourceRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

/// If specified, the pod's scheduling constraints
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<AwxWebAffinityNodeAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<AwxWebAffinityPodAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<AwxWebAffinityPodAntiAffinity>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AwxWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<AwxWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: AwxWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<AwxWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<AwxWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<AwxWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AwxWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<AwxWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: AwxWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AwxWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AwxWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AwxWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AwxWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AwxWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<AwxWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: AwxWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AwxWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AwxWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AwxWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AwxWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AwxWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Resource requirements for the web container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebResourceRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AwxWebResourceRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AwxWebResourceRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebResourceRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxWebResourceRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxStatus {
    /// URL to access the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "URL")]
    pub url: Option<String>,
    /// Admin password secret name of the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminPasswordSecret")]
    pub admin_password_secret: Option<String>,
    /// Admin user of the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminUser")]
    pub admin_user: Option<String>,
    /// Broadcast websocket secret name of the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "broadcastWebsocketSecret")]
    pub broadcast_websocket_secret: Option<String>,
    /// The resulting conditions when a Service Telemetry is instantiated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<AwxStatusConditions>>,
    /// URL of the image used for the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// The secret used for migrating an old instance
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "migratedFromSecret")]
    pub migrated_from_secret: Option<String>,
    /// Postgres Configuration secret name of the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postgresConfigurationSecret")]
    pub postgres_configuration_secret: Option<String>,
    /// Secret key secret name of the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeySecret")]
    pub secret_key_secret: Option<String>,
    /// Last gated version
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradedFrom")]
    pub upgraded_from: Option<String>,
    /// Status to indicate that the database has been upgraded to the version in the status
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradedPostgresVersion")]
    pub upgraded_postgres_version: Option<String>,
    /// Version of the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AwxStatusConditions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastTransitionTime")]
    pub last_transition_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

