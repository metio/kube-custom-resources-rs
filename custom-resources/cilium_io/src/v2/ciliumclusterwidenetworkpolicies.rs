// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/cilium/cilium/cilium.io/v2/ciliumclusterwidenetworkpolicies.yaml
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// Spec is the desired Cilium specific rule specification.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "cilium.io", version = "v2", kind = "CiliumClusterwideNetworkPolicy", plural = "ciliumclusterwidenetworkpolicies")]
#[kube(status = "CiliumClusterwideNetworkPolicyStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct CiliumClusterwideNetworkPolicySpec {
    /// Description is a free form string, it can be used by the creator of
    /// the rule to store human readable explanation of the purpose of this
    /// rule. Rules cannot be identified by comment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Egress is a list of EgressRule which are enforced at egress.
    /// If omitted or empty, this rule does not apply at egress.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub egress: Option<Vec<CiliumClusterwideNetworkPolicyEgress>>,
    /// EgressDeny is a list of EgressDenyRule which are enforced at egress.
    /// Any rule inserted here will be denied regardless of the allowed egress
    /// rules in the 'egress' field.
    /// If omitted or empty, this rule does not apply at egress.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressDeny")]
    pub egress_deny: Option<Vec<CiliumClusterwideNetworkPolicyEgressDeny>>,
    /// EnableDefaultDeny determines whether this policy configures the
    /// subject endpoint(s) to have a default deny mode. If enabled,
    /// this causes all traffic not explicitly allowed by a network policy
    /// to be dropped.
    /// 
    /// If not specified, the default is true for each traffic direction
    /// that has rules, and false otherwise. For example, if a policy
    /// only has Ingress or IngressDeny rules, then the default for
    /// ingress is true and egress is false.
    /// 
    /// If multiple policies apply to an endpoint, that endpoint's default deny
    /// will be enabled if any policy requests it.
    /// 
    /// This is useful for creating broad-based network policies that will not
    /// cause endpoints to enter default-deny mode.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableDefaultDeny")]
    pub enable_default_deny: Option<CiliumClusterwideNetworkPolicyEnableDefaultDeny>,
    /// EndpointSelector selects all endpoints which should be subject to
    /// this rule. EndpointSelector and NodeSelector cannot be both empty and
    /// are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointSelector")]
    pub endpoint_selector: Option<CiliumClusterwideNetworkPolicyEndpointSelector>,
    /// Ingress is a list of IngressRule which are enforced at ingress.
    /// If omitted or empty, this rule does not apply at ingress.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<Vec<CiliumClusterwideNetworkPolicyIngress>>,
    /// IngressDeny is a list of IngressDenyRule which are enforced at ingress.
    /// Any rule inserted here will be denied regardless of the allowed ingress
    /// rules in the 'ingress' field.
    /// If omitted or empty, this rule does not apply at ingress.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressDeny")]
    pub ingress_deny: Option<Vec<CiliumClusterwideNetworkPolicyIngressDeny>>,
    /// Labels is a list of optional strings which can be used to
    /// re-identify the rule or to store metadata. It is possible to lookup
    /// or delete strings based on labels. Labels are not required to be
    /// unique, multiple rules can have overlapping or identical labels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<Vec<CiliumClusterwideNetworkPolicyLabels>>,
    /// Log specifies custom policy-specific Hubble logging configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub log: Option<CiliumClusterwideNetworkPolicyLog>,
    /// NodeSelector selects all nodes which should be subject to this rule.
    /// EndpointSelector and NodeSelector cannot be both empty and are mutually
    /// exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<CiliumClusterwideNetworkPolicyNodeSelector>,
}

/// EgressRule contains all rule types which can be applied at egress, i.e.
/// network traffic that originates inside the endpoint and exits the endpoint
/// selected by the endpointSelector.
/// 
///   - All members of this structure are optional. If omitted or empty, the
///     member will have no effect on the rule.
/// 
///   - If multiple members of the structure are specified, then all members
///     must match in order for the rule to take effect. The exception to this
///     rule is the ToRequires member; the effects of any Requires field in any
///     rule will apply to all other rules as well.
/// 
///   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
///     mutually exclusive. Only one of these members may be present within an
///     individual rule.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgress {
    /// Authentication is the required authentication type for the allowed traffic, if any.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<CiliumClusterwideNetworkPolicyEgressAuthentication>,
    /// ICMPs is a list of ICMP rule identified by type number
    /// which the endpoint subject to the rule is allowed to connect to.
    /// 
    /// Example:
    /// Any endpoint with the label "app=httpd" is allowed to initiate
    /// type 8 ICMP connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icmps: Option<Vec<CiliumClusterwideNetworkPolicyEgressIcmps>>,
    /// ToCIDR is a list of IP blocks which the endpoint subject to the rule
    /// is allowed to initiate connections. Only connections destined for
    /// outside of the cluster and not targeting the host will be subject
    /// to CIDR rules.  This will match on the destination IP address of
    /// outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
    /// with no ExcludeCIDRs is equivalent. Overlaps are allowed between
    /// ToCIDR and ToCIDRSet.
    /// 
    /// Example:
    /// Any endpoint with the label "app=database-proxy" is allowed to
    /// initiate connections to 10.2.3.0/24
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toCIDR")]
    pub to_cidr: Option<Vec<String>>,
    /// ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
    /// is allowed to initiate connections to in addition to connections
    /// which are allowed via ToEndpoints, along with a list of subnets contained
    /// within their corresponding IP block to which traffic should not be
    /// allowed. This will match on the destination IP address of outgoing
    /// connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
    /// ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
    /// ToCIDRSet.
    /// 
    /// Example:
    /// Any endpoint with the label "app=database-proxy" is allowed to
    /// initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toCIDRSet")]
    pub to_cidr_set: Option<Vec<CiliumClusterwideNetworkPolicyEgressToCidrSet>>,
    /// ToEndpoints is a list of endpoints identified by an EndpointSelector to
    /// which the endpoints subject to the rule are allowed to communicate.
    /// 
    /// Example:
    /// Any endpoint with the label "role=frontend" can communicate with any
    /// endpoint carrying the label "role=backend".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toEndpoints")]
    pub to_endpoints: Option<Vec<CiliumClusterwideNetworkPolicyEgressToEndpoints>>,
    /// ToEntities is a list of special entities to which the endpoint subject
    /// to the rule is allowed to initiate connections. Supported entities are
    /// `world`, `cluster`, `host`, `remote-node`, `kube-apiserver`, `ingress`, `init`,
    /// `health`, `unmanaged`, `none` and `all`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toEntities")]
    pub to_entities: Option<Vec<String>>,
    /// ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result
    /// from DNS resolution of `ToFQDN.MatchName`s are added to the same
    /// EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and
    /// L7 rules within this EgressRule will also apply to these IPs.
    /// The DNS -> IP mapping is re-resolved periodically from within the
    /// cilium-agent, and the IPs in the DNS response are effected in the policy
    /// for selected pods as-is (i.e. the list of IPs is not modified in any way).
    /// Note: An explicit rule to allow for DNS traffic is needed for the pods, as
    /// ToFQDN counts as an egress rule and will enforce egress policy when
    /// PolicyEnforcment=default.
    /// Note: If the resolved IPs are IPs within the kubernetes cluster, the
    /// ToFQDN rule will not apply to that IP.
    /// Note: ToFQDN cannot occur in the same policy as other To* rules.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toFQDNs")]
    pub to_fqd_ns: Option<Vec<CiliumClusterwideNetworkPolicyEgressToFqdNs>>,
    /// ToGroups is a directive that allows the integration with multiple outside
    /// providers. Currently, only AWS is supported, and the rule can select by
    /// multiple sub directives:
    /// 
    /// Example:
    /// toGroups:
    /// - aws:
    ///     securityGroupsIds:
    ///     - 'sg-XXXXXXXXXXXXX'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toGroups")]
    pub to_groups: Option<Vec<CiliumClusterwideNetworkPolicyEgressToGroups>>,
    /// ToNodes is a list of nodes identified by an
    /// EndpointSelector to which endpoints subject to the rule is allowed to communicate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toNodes")]
    pub to_nodes: Option<Vec<CiliumClusterwideNetworkPolicyEgressToNodes>>,
    /// ToPorts is a list of destination ports identified by port number and
    /// protocol which the endpoint subject to the rule is allowed to
    /// connect to.
    /// 
    /// Example:
    /// Any endpoint with the label "role=frontend" is allowed to initiate
    /// connections to destination port 8080/tcp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toPorts")]
    pub to_ports: Option<Vec<CiliumClusterwideNetworkPolicyEgressToPorts>>,
    /// ToRequires is a list of additional constraints which must be met
    /// in order for the selected endpoints to be able to connect to other
    /// endpoints. These additional constraints do no by itself grant access
    /// privileges and must always be accompanied with at least one matching
    /// ToEndpoints.
    /// 
    /// Example:
    /// Any Endpoint with the label "team=A" requires any endpoint to which it
    /// communicates to also carry the label "team=A".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toRequires")]
    pub to_requires: Option<Vec<CiliumClusterwideNetworkPolicyEgressToRequires>>,
    /// ToServices is a list of services to which the endpoint subject
    /// to the rule is allowed to initiate connections.
    /// Currently Cilium only supports toServices for K8s services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toServices")]
    pub to_services: Option<Vec<CiliumClusterwideNetworkPolicyEgressToServices>>,
}

/// Authentication is the required authentication type for the allowed traffic, if any.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressAuthentication {
    /// Mode is the required authentication mode for the allowed traffic, if any.
    pub mode: CiliumClusterwideNetworkPolicyEgressAuthenticationMode,
}

/// Authentication is the required authentication type for the allowed traffic, if any.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressAuthenticationMode {
    #[serde(rename = "disabled")]
    Disabled,
    #[serde(rename = "required")]
    Required,
    #[serde(rename = "test-always-fail")]
    TestAlwaysFail,
}

/// ICMPRule is a list of ICMP fields.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressIcmps {
    /// Fields is a list of ICMP fields.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<CiliumClusterwideNetworkPolicyEgressIcmpsFields>>,
}

/// ICMPField is a ICMP field.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressIcmpsFields {
    /// Family is a IP address version.
    /// Currently, we support `IPv4` and `IPv6`.
    /// `IPv4` is set as default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<CiliumClusterwideNetworkPolicyEgressIcmpsFieldsFamily>,
    /// Type is a ICMP-type.
    /// It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
    /// Allowed ICMP types are:
    ///     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
    /// 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
    /// 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
    ///     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
    /// 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
    /// 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
    /// 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
    /// 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
    /// 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
    /// 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
    /// 			 ExtendedEchoRequest | ExtendedEchoReply
    #[serde(rename = "type")]
    pub r#type: IntOrString,
}

/// ICMPField is a ICMP field.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressIcmpsFieldsFamily {
    IPv4,
    IPv6,
}

/// CIDRRule is a rule that specifies a CIDR prefix to/from which outside
/// communication  is allowed, along with an optional list of subnets within that
/// CIDR prefix to/from which outside communication is not allowed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToCidrSet {
    /// CIDR is a CIDR prefix / IP Block.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    /// CIDRGroupRef is a reference to a CiliumCIDRGroup object.
    /// A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
    /// the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
    /// connections from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupRef")]
    pub cidr_group_ref: Option<String>,
    /// CIDRGroupSelector selects CiliumCIDRGroups by their labels,
    /// rather than by name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupSelector")]
    pub cidr_group_selector: Option<CiliumClusterwideNetworkPolicyEgressToCidrSetCidrGroupSelector>,
    /// ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
    /// is not allowed to initiate connections to. These CIDR prefixes should be
    /// contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
    /// supported yet.
    /// These exceptions are only applied to the Cidr in this CIDRRule, and do not
    /// apply to any other CIDR prefixes in any other CIDRRules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub except: Option<Vec<String>>,
}

/// CIDRGroupSelector selects CiliumCIDRGroups by their labels,
/// rather than by name.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToCidrSetCidrGroupSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyEgressToCidrSetCidrGroupSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToCidrSetCidrGroupSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyEgressToCidrSetCidrGroupSelectorMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressToCidrSetCidrGroupSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToEndpoints {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyEgressToEndpointsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToEndpointsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyEgressToEndpointsMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressToEndpointsMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToFqdNs {
    /// MatchName matches literal DNS names. A trailing "." is automatically added
    /// when missing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchName")]
    pub match_name: Option<String>,
    /// MatchPattern allows using wildcards to match DNS names. All wildcards are
    /// case insensitive. The wildcards are:
    /// - "*" matches 0 or more DNS valid characters, and may occur anywhere in
    /// the pattern. As a special case a "*" as the leftmost character, without a
    /// following "." matches all subdomains as well as the name to the right.
    /// A trailing "." is automatically added when missing.
    /// 
    /// Examples:
    /// `*.cilium.io` matches subdomains of cilium at that level
    ///   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
    /// `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
    ///   except those containing "." separator, subcilium.io and sub-cilium.io match,
    ///   www.cilium.io and blog.cilium.io does not
    /// sub*.cilium.io matches subdomains of cilium where the subdomain component
    /// begins with "sub"
    ///   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
    ///   blog.cilium.io, cilium.io and google.com do not
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchPattern")]
    pub match_pattern: Option<String>,
}

/// Groups structure to store all kinds of new integrations that needs a new
/// derivative policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToGroups {
    /// AWSGroup is an structure that can be used to whitelisting information from AWS integration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<CiliumClusterwideNetworkPolicyEgressToGroupsAws>,
}

/// AWSGroup is an structure that can be used to whitelisting information from AWS integration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToGroupsAws {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    pub security_groups_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsNames")]
    pub security_groups_names: Option<Vec<String>>,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToNodes {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyEgressToNodesMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToNodesMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyEgressToNodesMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressToNodesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// PortRule is a list of ports/protocol combinations with optional Layer 7
/// rules which must be met.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToPorts {
    /// listener specifies the name of a custom Envoy listener to which this traffic should be
    /// redirected to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub listener: Option<CiliumClusterwideNetworkPolicyEgressToPortsListener>,
    /// OriginatingTLS is the TLS context for the connections originated by
    /// the L7 proxy.  For egress policy this specifies the client-side TLS
    /// parameters for the upstream connection originating from the L7 proxy
    /// to the remote destination. For ingress policy this specifies the
    /// client-side TLS parameters for the connection from the L7 proxy to
    /// the local endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originatingTLS")]
    pub originating_tls: Option<CiliumClusterwideNetworkPolicyEgressToPortsOriginatingTls>,
    /// Ports is a list of L4 port/protocol
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<CiliumClusterwideNetworkPolicyEgressToPortsPorts>>,
    /// Rules is a list of additional port level rules which must be met in
    /// order for the PortRule to allow the traffic. If omitted or empty,
    /// no layer 7 rules are enforced.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<CiliumClusterwideNetworkPolicyEgressToPortsRules>,
    /// ServerNames is a list of allowed TLS SNI values. If not empty, then
    /// TLS must be present and one of the provided SNIs must be indicated in the
    /// TLS handshake.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverNames")]
    pub server_names: Option<Vec<String>>,
    /// TerminatingTLS is the TLS context for the connection terminated by
    /// the L7 proxy.  For egress policy this specifies the server-side TLS
    /// parameters to be applied on the connections originated from the local
    /// endpoint and terminated by the L7 proxy. For ingress policy this specifies
    /// the server-side TLS parameters to be applied on the connections
    /// originated from a remote source and terminated by the L7 proxy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminatingTLS")]
    pub terminating_tls: Option<CiliumClusterwideNetworkPolicyEgressToPortsTerminatingTls>,
}

/// listener specifies the name of a custom Envoy listener to which this traffic should be
/// redirected to.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToPortsListener {
    /// EnvoyConfig is a reference to the CEC or CCEC resource in which
    /// the listener is defined.
    #[serde(rename = "envoyConfig")]
    pub envoy_config: CiliumClusterwideNetworkPolicyEgressToPortsListenerEnvoyConfig,
    /// Name is the name of the listener.
    pub name: String,
    /// Priority for this Listener that is used when multiple rules would apply different
    /// listeners to a policy map entry. Behavior of this is implementation dependent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
}

/// EnvoyConfig is a reference to the CEC or CCEC resource in which
/// the listener is defined.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToPortsListenerEnvoyConfig {
    /// Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
    /// CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
    /// respectively. The only case this is currently explicitly needed is when referring to a
    /// CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
    /// from a cluster scoped policy is not allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<CiliumClusterwideNetworkPolicyEgressToPortsListenerEnvoyConfigKind>,
    /// Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
    /// the listener is defined in.
    pub name: String,
}

/// EnvoyConfig is a reference to the CEC or CCEC resource in which
/// the listener is defined.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressToPortsListenerEnvoyConfigKind {
    CiliumEnvoyConfig,
    CiliumClusterwideEnvoyConfig,
}

/// OriginatingTLS is the TLS context for the connections originated by
/// the L7 proxy.  For egress policy this specifies the client-side TLS
/// parameters for the upstream connection originating from the L7 proxy
/// to the remote destination. For ingress policy this specifies the
/// client-side TLS parameters for the connection from the L7 proxy to
/// the local endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToPortsOriginatingTls {
    /// Certificate is the file name or k8s secret item name for the certificate
    /// chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
    /// item must exist.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    /// PrivateKey is the file name or k8s secret item name for the private key
    /// matching the certificate chain. If omitted, 'tls.key' is assumed, if it
    /// exists. If given, the item must exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// Secret is the secret that contains the certificates and private key for
    /// the TLS context.
    /// By default, Cilium will search in this secret for the following items:
    ///  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
    ///  - 'tls.crt' - Which represents the public key certificate.
    ///  - 'tls.key' - Which represents the private key matching the public key
    ///                certificate.
    pub secret: CiliumClusterwideNetworkPolicyEgressToPortsOriginatingTlsSecret,
    /// TrustedCA is the file name or k8s secret item name for the trusted CA.
    /// If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
    /// exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedCA")]
    pub trusted_ca: Option<String>,
}

/// Secret is the secret that contains the certificates and private key for
/// the TLS context.
/// By default, Cilium will search in this secret for the following items:
///  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
///  - 'tls.crt' - Which represents the public key certificate.
///  - 'tls.key' - Which represents the private key matching the public key
///                certificate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToPortsOriginatingTlsSecret {
    /// Name is the name of the secret.
    pub name: String,
    /// Namespace is the namespace in which the secret exists. Context of use
    /// determines the default value if left out (e.g., "default").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// PortProtocol specifies an L4 port with an optional transport protocol
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToPortsPorts {
    /// EndPort can only be an L4 port number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endPort")]
    pub end_port: Option<i32>,
    /// Port can be an L4 port number, or a name in the form of "http"
    /// or "http-8080".
    pub port: String,
    /// Protocol is the L4 protocol. If omitted or empty, any protocol
    /// matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
    /// 
    /// Matching on ICMP is not supported.
    /// 
    /// Named port specified for a container may narrow this down, but may not
    /// contradict this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<CiliumClusterwideNetworkPolicyEgressToPortsPortsProtocol>,
}

/// PortProtocol specifies an L4 port with an optional transport protocol
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressToPortsPortsProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "SCTP")]
    Sctp,
    #[serde(rename = "ANY")]
    Any,
}

/// Rules is a list of additional port level rules which must be met in
/// order for the PortRule to allow the traffic. If omitted or empty,
/// no layer 7 rules are enforced.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToPortsRules {
    /// DNS-specific rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dns: Option<Vec<CiliumClusterwideNetworkPolicyEgressToPortsRulesDns>>,
    /// HTTP specific rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<Vec<CiliumClusterwideNetworkPolicyEgressToPortsRulesHttp>>,
    /// Kafka-specific rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<Vec<CiliumClusterwideNetworkPolicyEgressToPortsRulesKafka>>,
    /// Key-value pair rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l7: Option<Vec<BTreeMap<String, String>>>,
    /// Name of the L7 protocol for which the Key-value pair rules apply.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l7proto: Option<String>,
}

/// PortRuleDNS is a list of allowed DNS lookups.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToPortsRulesDns {
    /// MatchName matches literal DNS names. A trailing "." is automatically added
    /// when missing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchName")]
    pub match_name: Option<String>,
    /// MatchPattern allows using wildcards to match DNS names. All wildcards are
    /// case insensitive. The wildcards are:
    /// - "*" matches 0 or more DNS valid characters, and may occur anywhere in
    /// the pattern. As a special case a "*" as the leftmost character, without a
    /// following "." matches all subdomains as well as the name to the right.
    /// A trailing "." is automatically added when missing.
    /// 
    /// Examples:
    /// `*.cilium.io` matches subdomains of cilium at that level
    ///   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
    /// `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
    ///   except those containing "." separator, subcilium.io and sub-cilium.io match,
    ///   www.cilium.io and blog.cilium.io does not
    /// sub*.cilium.io matches subdomains of cilium where the subdomain component
    /// begins with "sub"
    ///   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
    ///   blog.cilium.io, cilium.io and google.com do not
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchPattern")]
    pub match_pattern: Option<String>,
}

/// PortRuleHTTP is a list of HTTP protocol constraints. All fields are
/// optional, if all fields are empty or missing, the rule does not have any
/// effect.
/// 
/// All fields of this type are extended POSIX regex as defined by IEEE Std
/// 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
/// matched against the path of an incoming request. Currently it can contain
/// characters disallowed from the conventional "path" part of a URL as defined
/// by RFC 3986.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToPortsRulesHttp {
    /// HeaderMatches is a list of HTTP headers which must be
    /// present and match against the given values. Mismatch field can be used
    /// to specify what to do when there is no match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerMatches")]
    pub header_matches: Option<Vec<CiliumClusterwideNetworkPolicyEgressToPortsRulesHttpHeaderMatches>>,
    /// Headers is a list of HTTP headers which must be present in the
    /// request. If omitted or empty, requests are allowed regardless of
    /// headers present.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    /// Host is an extended POSIX regex matched against the host header of a
    /// request. Examples:
    /// 
    /// - foo.bar.com will match the host fooXbar.com or foo-bar.com
    /// - foo\.bar\.com will only match the host foo.bar.com
    /// 
    /// If omitted or empty, the value of the host header is ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Method is an extended POSIX regex matched against the method of a
    /// request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
    /// 
    /// If omitted or empty, all methods are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Path is an extended POSIX regex matched against the path of a
    /// request. Currently it can contain characters disallowed from the
    /// conventional "path" part of a URL as defined by RFC 3986.
    /// 
    /// If omitted or empty, all paths are all allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// HeaderMatch extends the HeaderValue for matching requirement of a
/// named header field against an immediate string or a secret value.
/// If none of the optional fields is present, then the
/// header value is not matched, only presence of the header is enough.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToPortsRulesHttpHeaderMatches {
    /// Mismatch identifies what to do in case there is no match. The default is
    /// to drop the request. Otherwise the overall rule is still considered as
    /// matching, but the mismatches are logged in the access log.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mismatch: Option<CiliumClusterwideNetworkPolicyEgressToPortsRulesHttpHeaderMatchesMismatch>,
    /// Name identifies the header.
    pub name: String,
    /// Secret refers to a secret that contains the value to be matched against.
    /// The secret must only contain one entry. If the referred secret does not
    /// exist, and there is no "Value" specified, the match will fail.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CiliumClusterwideNetworkPolicyEgressToPortsRulesHttpHeaderMatchesSecret>,
    /// Value matches the exact value of the header. Can be specified either
    /// alone or together with "Secret"; will be used as the header value if the
    /// secret can not be found in the latter case.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// HeaderMatch extends the HeaderValue for matching requirement of a
/// named header field against an immediate string or a secret value.
/// If none of the optional fields is present, then the
/// header value is not matched, only presence of the header is enough.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressToPortsRulesHttpHeaderMatchesMismatch {
    #[serde(rename = "LOG")]
    Log,
    #[serde(rename = "ADD")]
    Add,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "REPLACE")]
    Replace,
}

/// Secret refers to a secret that contains the value to be matched against.
/// The secret must only contain one entry. If the referred secret does not
/// exist, and there is no "Value" specified, the match will fail.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToPortsRulesHttpHeaderMatchesSecret {
    /// Name is the name of the secret.
    pub name: String,
    /// Namespace is the namespace in which the secret exists. Context of use
    /// determines the default value if left out (e.g., "default").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// PortRule is a list of Kafka protocol constraints. All fields are
/// optional, if all fields are empty or missing, the rule will match all
/// Kafka messages.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToPortsRulesKafka {
    /// APIKey is a case-insensitive string matched against the key of a
    /// request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
    /// Reference: https://kafka.apache.org/protocol#protocol_api_keys
    /// 
    /// If omitted or empty, and if Role is not specified, then all keys are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<String>,
    /// APIVersion is the version matched against the api version of the
    /// Kafka message. If set, it has to be a string representing a positive
    /// integer.
    /// 
    /// If omitted or empty, all versions are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// ClientID is the client identifier as provided in the request.
    /// 
    /// From Kafka protocol documentation:
    /// This is a user supplied identifier for the client application. The
    /// user can use any identifier they like and it will be used when
    /// logging errors, monitoring aggregates, etc. For example, one might
    /// want to monitor not just the requests per second overall, but the
    /// number coming from each client application (each of which could
    /// reside on multiple servers). This id acts as a logical grouping
    /// across all requests from a particular client.
    /// 
    /// If omitted or empty, all client identifiers are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientID")]
    pub client_id: Option<String>,
    /// Role is a case-insensitive string and describes a group of API keys
    /// necessary to perform certain higher-level Kafka operations such as "produce"
    /// or "consume". A Role automatically expands into all APIKeys required
    /// to perform the specified higher-level operation.
    /// 
    /// The following values are supported:
    ///  - "produce": Allow producing to the topics specified in the rule
    ///  - "consume": Allow consuming from the topics specified in the rule
    /// 
    /// This field is incompatible with the APIKey field, i.e APIKey and Role
    /// cannot both be specified in the same rule.
    /// 
    /// If omitted or empty, and if APIKey is not specified, then all keys are
    /// allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<CiliumClusterwideNetworkPolicyEgressToPortsRulesKafkaRole>,
    /// Topic is the topic name contained in the message. If a Kafka request
    /// contains multiple topics, then all topics must be allowed or the
    /// message will be rejected.
    /// 
    /// This constraint is ignored if the matched request message type
    /// doesn't contain any topic. Maximum size of Topic can be 249
    /// characters as per recent Kafka spec and allowed characters are
    /// a-z, A-Z, 0-9, -, . and _.
    /// 
    /// Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
    /// version the length was changed from 255 to 249. For compatibility
    /// reasons we are using 255.
    /// 
    /// If omitted or empty, all topics are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// PortRule is a list of Kafka protocol constraints. All fields are
/// optional, if all fields are empty or missing, the rule will match all
/// Kafka messages.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressToPortsRulesKafkaRole {
    #[serde(rename = "produce")]
    Produce,
    #[serde(rename = "consume")]
    Consume,
}

/// TerminatingTLS is the TLS context for the connection terminated by
/// the L7 proxy.  For egress policy this specifies the server-side TLS
/// parameters to be applied on the connections originated from the local
/// endpoint and terminated by the L7 proxy. For ingress policy this specifies
/// the server-side TLS parameters to be applied on the connections
/// originated from a remote source and terminated by the L7 proxy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToPortsTerminatingTls {
    /// Certificate is the file name or k8s secret item name for the certificate
    /// chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
    /// item must exist.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    /// PrivateKey is the file name or k8s secret item name for the private key
    /// matching the certificate chain. If omitted, 'tls.key' is assumed, if it
    /// exists. If given, the item must exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// Secret is the secret that contains the certificates and private key for
    /// the TLS context.
    /// By default, Cilium will search in this secret for the following items:
    ///  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
    ///  - 'tls.crt' - Which represents the public key certificate.
    ///  - 'tls.key' - Which represents the private key matching the public key
    ///                certificate.
    pub secret: CiliumClusterwideNetworkPolicyEgressToPortsTerminatingTlsSecret,
    /// TrustedCA is the file name or k8s secret item name for the trusted CA.
    /// If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
    /// exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedCA")]
    pub trusted_ca: Option<String>,
}

/// Secret is the secret that contains the certificates and private key for
/// the TLS context.
/// By default, Cilium will search in this secret for the following items:
///  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
///  - 'tls.crt' - Which represents the public key certificate.
///  - 'tls.key' - Which represents the private key matching the public key
///                certificate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToPortsTerminatingTlsSecret {
    /// Name is the name of the secret.
    pub name: String,
    /// Namespace is the namespace in which the secret exists. Context of use
    /// determines the default value if left out (e.g., "default").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToRequires {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyEgressToRequiresMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToRequiresMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyEgressToRequiresMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressToRequiresMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// Service selects policy targets that are bundled as part of a
/// logical load-balanced service.
/// 
/// Currently only Kubernetes-based Services are supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToServices {
    /// K8sService selects service by name and namespace pair
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sService")]
    pub k8s_service: Option<CiliumClusterwideNetworkPolicyEgressToServicesK8sService>,
    /// K8sServiceSelector selects services by k8s labels and namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sServiceSelector")]
    pub k8s_service_selector: Option<CiliumClusterwideNetworkPolicyEgressToServicesK8sServiceSelector>,
}

/// K8sService selects service by name and namespace pair
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToServicesK8sService {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

/// K8sServiceSelector selects services by k8s labels and namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToServicesK8sServiceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// ServiceSelector is a label selector for k8s services
    pub selector: CiliumClusterwideNetworkPolicyEgressToServicesK8sServiceSelectorSelector,
}

/// ServiceSelector is a label selector for k8s services
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToServicesK8sServiceSelectorSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyEgressToServicesK8sServiceSelectorSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressToServicesK8sServiceSelectorSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyEgressToServicesK8sServiceSelectorSelectorMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressToServicesK8sServiceSelectorSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// EgressDenyRule contains all rule types which can be applied at egress, i.e.
/// network traffic that originates inside the endpoint and exits the endpoint
/// selected by the endpointSelector.
/// 
///   - All members of this structure are optional. If omitted or empty, the
///     member will have no effect on the rule.
/// 
///   - If multiple members of the structure are specified, then all members
///     must match in order for the rule to take effect. The exception to this
///     rule is the ToRequires member; the effects of any Requires field in any
///     rule will apply to all other rules as well.
/// 
///   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
///     mutually exclusive. Only one of these members may be present within an
///     individual rule.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDeny {
    /// ICMPs is a list of ICMP rule identified by type number
    /// which the endpoint subject to the rule is not allowed to connect to.
    /// 
    /// Example:
    /// Any endpoint with the label "app=httpd" is not allowed to initiate
    /// type 8 ICMP connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icmps: Option<Vec<CiliumClusterwideNetworkPolicyEgressDenyIcmps>>,
    /// ToCIDR is a list of IP blocks which the endpoint subject to the rule
    /// is allowed to initiate connections. Only connections destined for
    /// outside of the cluster and not targeting the host will be subject
    /// to CIDR rules.  This will match on the destination IP address of
    /// outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
    /// with no ExcludeCIDRs is equivalent. Overlaps are allowed between
    /// ToCIDR and ToCIDRSet.
    /// 
    /// Example:
    /// Any endpoint with the label "app=database-proxy" is allowed to
    /// initiate connections to 10.2.3.0/24
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toCIDR")]
    pub to_cidr: Option<Vec<String>>,
    /// ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
    /// is allowed to initiate connections to in addition to connections
    /// which are allowed via ToEndpoints, along with a list of subnets contained
    /// within their corresponding IP block to which traffic should not be
    /// allowed. This will match on the destination IP address of outgoing
    /// connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
    /// ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
    /// ToCIDRSet.
    /// 
    /// Example:
    /// Any endpoint with the label "app=database-proxy" is allowed to
    /// initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toCIDRSet")]
    pub to_cidr_set: Option<Vec<CiliumClusterwideNetworkPolicyEgressDenyToCidrSet>>,
    /// ToEndpoints is a list of endpoints identified by an EndpointSelector to
    /// which the endpoints subject to the rule are allowed to communicate.
    /// 
    /// Example:
    /// Any endpoint with the label "role=frontend" can communicate with any
    /// endpoint carrying the label "role=backend".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toEndpoints")]
    pub to_endpoints: Option<Vec<CiliumClusterwideNetworkPolicyEgressDenyToEndpoints>>,
    /// ToEntities is a list of special entities to which the endpoint subject
    /// to the rule is allowed to initiate connections. Supported entities are
    /// `world`, `cluster`, `host`, `remote-node`, `kube-apiserver`, `ingress`, `init`,
    /// `health`, `unmanaged`, `none` and `all`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toEntities")]
    pub to_entities: Option<Vec<String>>,
    /// ToGroups is a directive that allows the integration with multiple outside
    /// providers. Currently, only AWS is supported, and the rule can select by
    /// multiple sub directives:
    /// 
    /// Example:
    /// toGroups:
    /// - aws:
    ///     securityGroupsIds:
    ///     - 'sg-XXXXXXXXXXXXX'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toGroups")]
    pub to_groups: Option<Vec<CiliumClusterwideNetworkPolicyEgressDenyToGroups>>,
    /// ToNodes is a list of nodes identified by an
    /// EndpointSelector to which endpoints subject to the rule is allowed to communicate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toNodes")]
    pub to_nodes: Option<Vec<CiliumClusterwideNetworkPolicyEgressDenyToNodes>>,
    /// ToPorts is a list of destination ports identified by port number and
    /// protocol which the endpoint subject to the rule is not allowed to connect
    /// to.
    /// 
    /// Example:
    /// Any endpoint with the label "role=frontend" is not allowed to initiate
    /// connections to destination port 8080/tcp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toPorts")]
    pub to_ports: Option<Vec<CiliumClusterwideNetworkPolicyEgressDenyToPorts>>,
    /// ToRequires is a list of additional constraints which must be met
    /// in order for the selected endpoints to be able to connect to other
    /// endpoints. These additional constraints do no by itself grant access
    /// privileges and must always be accompanied with at least one matching
    /// ToEndpoints.
    /// 
    /// Example:
    /// Any Endpoint with the label "team=A" requires any endpoint to which it
    /// communicates to also carry the label "team=A".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toRequires")]
    pub to_requires: Option<Vec<CiliumClusterwideNetworkPolicyEgressDenyToRequires>>,
    /// ToServices is a list of services to which the endpoint subject
    /// to the rule is allowed to initiate connections.
    /// Currently Cilium only supports toServices for K8s services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toServices")]
    pub to_services: Option<Vec<CiliumClusterwideNetworkPolicyEgressDenyToServices>>,
}

/// ICMPRule is a list of ICMP fields.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyIcmps {
    /// Fields is a list of ICMP fields.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<CiliumClusterwideNetworkPolicyEgressDenyIcmpsFields>>,
}

/// ICMPField is a ICMP field.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyIcmpsFields {
    /// Family is a IP address version.
    /// Currently, we support `IPv4` and `IPv6`.
    /// `IPv4` is set as default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<CiliumClusterwideNetworkPolicyEgressDenyIcmpsFieldsFamily>,
    /// Type is a ICMP-type.
    /// It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
    /// Allowed ICMP types are:
    ///     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
    /// 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
    /// 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
    ///     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
    /// 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
    /// 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
    /// 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
    /// 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
    /// 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
    /// 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
    /// 			 ExtendedEchoRequest | ExtendedEchoReply
    #[serde(rename = "type")]
    pub r#type: IntOrString,
}

/// ICMPField is a ICMP field.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressDenyIcmpsFieldsFamily {
    IPv4,
    IPv6,
}

/// CIDRRule is a rule that specifies a CIDR prefix to/from which outside
/// communication  is allowed, along with an optional list of subnets within that
/// CIDR prefix to/from which outside communication is not allowed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToCidrSet {
    /// CIDR is a CIDR prefix / IP Block.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    /// CIDRGroupRef is a reference to a CiliumCIDRGroup object.
    /// A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
    /// the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
    /// connections from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupRef")]
    pub cidr_group_ref: Option<String>,
    /// CIDRGroupSelector selects CiliumCIDRGroups by their labels,
    /// rather than by name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupSelector")]
    pub cidr_group_selector: Option<CiliumClusterwideNetworkPolicyEgressDenyToCidrSetCidrGroupSelector>,
    /// ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
    /// is not allowed to initiate connections to. These CIDR prefixes should be
    /// contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
    /// supported yet.
    /// These exceptions are only applied to the Cidr in this CIDRRule, and do not
    /// apply to any other CIDR prefixes in any other CIDRRules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub except: Option<Vec<String>>,
}

/// CIDRGroupSelector selects CiliumCIDRGroups by their labels,
/// rather than by name.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToCidrSetCidrGroupSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyEgressDenyToCidrSetCidrGroupSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToCidrSetCidrGroupSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyEgressDenyToCidrSetCidrGroupSelectorMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressDenyToCidrSetCidrGroupSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToEndpoints {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyEgressDenyToEndpointsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToEndpointsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyEgressDenyToEndpointsMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressDenyToEndpointsMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// Groups structure to store all kinds of new integrations that needs a new
/// derivative policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToGroups {
    /// AWSGroup is an structure that can be used to whitelisting information from AWS integration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<CiliumClusterwideNetworkPolicyEgressDenyToGroupsAws>,
}

/// AWSGroup is an structure that can be used to whitelisting information from AWS integration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToGroupsAws {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    pub security_groups_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsNames")]
    pub security_groups_names: Option<Vec<String>>,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToNodes {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyEgressDenyToNodesMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToNodesMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyEgressDenyToNodesMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressDenyToNodesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// PortDenyRule is a list of ports/protocol that should be used for deny
/// policies. This structure lacks the L7Rules since it's not supported in deny
/// policies.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToPorts {
    /// Ports is a list of L4 port/protocol
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<CiliumClusterwideNetworkPolicyEgressDenyToPortsPorts>>,
}

/// PortProtocol specifies an L4 port with an optional transport protocol
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToPortsPorts {
    /// EndPort can only be an L4 port number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endPort")]
    pub end_port: Option<i32>,
    /// Port can be an L4 port number, or a name in the form of "http"
    /// or "http-8080".
    pub port: String,
    /// Protocol is the L4 protocol. If omitted or empty, any protocol
    /// matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
    /// 
    /// Matching on ICMP is not supported.
    /// 
    /// Named port specified for a container may narrow this down, but may not
    /// contradict this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<CiliumClusterwideNetworkPolicyEgressDenyToPortsPortsProtocol>,
}

/// PortProtocol specifies an L4 port with an optional transport protocol
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressDenyToPortsPortsProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "SCTP")]
    Sctp,
    #[serde(rename = "ANY")]
    Any,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToRequires {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyEgressDenyToRequiresMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToRequiresMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyEgressDenyToRequiresMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressDenyToRequiresMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// Service selects policy targets that are bundled as part of a
/// logical load-balanced service.
/// 
/// Currently only Kubernetes-based Services are supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToServices {
    /// K8sService selects service by name and namespace pair
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sService")]
    pub k8s_service: Option<CiliumClusterwideNetworkPolicyEgressDenyToServicesK8sService>,
    /// K8sServiceSelector selects services by k8s labels and namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sServiceSelector")]
    pub k8s_service_selector: Option<CiliumClusterwideNetworkPolicyEgressDenyToServicesK8sServiceSelector>,
}

/// K8sService selects service by name and namespace pair
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToServicesK8sService {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

/// K8sServiceSelector selects services by k8s labels and namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToServicesK8sServiceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// ServiceSelector is a label selector for k8s services
    pub selector: CiliumClusterwideNetworkPolicyEgressDenyToServicesK8sServiceSelectorSelector,
}

/// ServiceSelector is a label selector for k8s services
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToServicesK8sServiceSelectorSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// EnableDefaultDeny determines whether this policy configures the
/// subject endpoint(s) to have a default deny mode. If enabled,
/// this causes all traffic not explicitly allowed by a network policy
/// to be dropped.
/// 
/// If not specified, the default is true for each traffic direction
/// that has rules, and false otherwise. For example, if a policy
/// only has Ingress or IngressDeny rules, then the default for
/// ingress is true and egress is false.
/// 
/// If multiple policies apply to an endpoint, that endpoint's default deny
/// will be enabled if any policy requests it.
/// 
/// This is useful for creating broad-based network policies that will not
/// cause endpoints to enter default-deny mode.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEnableDefaultDeny {
    /// Whether or not the endpoint should have a default-deny rule applied
    /// to egress traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub egress: Option<bool>,
    /// Whether or not the endpoint should have a default-deny rule applied
    /// to ingress traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<bool>,
}

/// EndpointSelector selects all endpoints which should be subject to
/// this rule. EndpointSelector and NodeSelector cannot be both empty and
/// are mutually exclusive.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEndpointSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyEndpointSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyEndpointSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyEndpointSelectorMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyEndpointSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// IngressRule contains all rule types which can be applied at ingress,
/// i.e. network traffic that originates outside of the endpoint and
/// is entering the endpoint selected by the endpointSelector.
/// 
///   - All members of this structure are optional. If omitted or empty, the
///     member will have no effect on the rule.
/// 
///   - If multiple members are set, all of them need to match in order for
///     the rule to take effect. The exception to this rule is FromRequires field;
///     the effects of any Requires field in any rule will apply to all other
///     rules as well.
/// 
///   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually
///     exclusive. Only one of these members may be present within an individual
///     rule.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngress {
    /// Authentication is the required authentication type for the allowed traffic, if any.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<CiliumClusterwideNetworkPolicyIngressAuthentication>,
    /// FromCIDR is a list of IP blocks which the endpoint subject to the
    /// rule is allowed to receive connections from. Only connections which
    /// do *not* originate from the cluster or from the local host are subject
    /// to CIDR rules. In order to allow in-cluster connectivity, use the
    /// FromEndpoints field.  This will match on the source IP address of
    /// incoming connections. Adding  a prefix into FromCIDR or into
    /// FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
    /// allowed between FromCIDR and FromCIDRSet.
    /// 
    /// Example:
    /// Any endpoint with the label "app=my-legacy-pet" is allowed to receive
    /// connections from 10.3.9.1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromCIDR")]
    pub from_cidr: Option<Vec<String>>,
    /// FromCIDRSet is a list of IP blocks which the endpoint subject to the
    /// rule is allowed to receive connections from in addition to FromEndpoints,
    /// along with a list of subnets contained within their corresponding IP block
    /// from which traffic should not be allowed.
    /// This will match on the source IP address of incoming connections. Adding
    /// a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
    /// equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
    /// 
    /// Example:
    /// Any endpoint with the label "app=my-legacy-pet" is allowed to receive
    /// connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromCIDRSet")]
    pub from_cidr_set: Option<Vec<CiliumClusterwideNetworkPolicyIngressFromCidrSet>>,
    /// FromEndpoints is a list of endpoints identified by an
    /// EndpointSelector which are allowed to communicate with the endpoint
    /// subject to the rule.
    /// 
    /// Example:
    /// Any endpoint with the label "role=backend" can be consumed by any
    /// endpoint carrying the label "role=frontend".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEndpoints")]
    pub from_endpoints: Option<Vec<CiliumClusterwideNetworkPolicyIngressFromEndpoints>>,
    /// FromEntities is a list of special entities which the endpoint subject
    /// to the rule is allowed to receive connections from. Supported entities are
    /// `world`, `cluster`, `host`, `remote-node`, `kube-apiserver`, `ingress`, `init`,
    /// `health`, `unmanaged`, `none` and `all`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEntities")]
    pub from_entities: Option<Vec<String>>,
    /// FromGroups is a directive that allows the integration with multiple outside
    /// providers. Currently, only AWS is supported, and the rule can select by
    /// multiple sub directives:
    /// 
    /// Example:
    /// FromGroups:
    /// - aws:
    ///     securityGroupsIds:
    ///     - 'sg-XXXXXXXXXXXXX'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromGroups")]
    pub from_groups: Option<Vec<CiliumClusterwideNetworkPolicyIngressFromGroups>>,
    /// FromNodes is a list of nodes identified by an
    /// EndpointSelector which are allowed to communicate with the endpoint
    /// subject to the rule.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromNodes")]
    pub from_nodes: Option<Vec<CiliumClusterwideNetworkPolicyIngressFromNodes>>,
    /// FromRequires is a list of additional constraints which must be met
    /// in order for the selected endpoints to be reachable. These
    /// additional constraints do no by itself grant access privileges and
    /// must always be accompanied with at least one matching FromEndpoints.
    /// 
    /// Example:
    /// Any Endpoint with the label "team=A" requires consuming endpoint
    /// to also carry the label "team=A".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromRequires")]
    pub from_requires: Option<Vec<CiliumClusterwideNetworkPolicyIngressFromRequires>>,
    /// ICMPs is a list of ICMP rule identified by type number
    /// which the endpoint subject to the rule is allowed to
    /// receive connections on.
    /// 
    /// Example:
    /// Any endpoint with the label "app=httpd" can only accept incoming
    /// type 8 ICMP connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icmps: Option<Vec<CiliumClusterwideNetworkPolicyIngressIcmps>>,
    /// ToPorts is a list of destination ports identified by port number and
    /// protocol which the endpoint subject to the rule is allowed to
    /// receive connections on.
    /// 
    /// Example:
    /// Any endpoint with the label "app=httpd" can only accept incoming
    /// connections on port 80/tcp.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toPorts")]
    pub to_ports: Option<Vec<CiliumClusterwideNetworkPolicyIngressToPorts>>,
}

/// Authentication is the required authentication type for the allowed traffic, if any.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressAuthentication {
    /// Mode is the required authentication mode for the allowed traffic, if any.
    pub mode: CiliumClusterwideNetworkPolicyIngressAuthenticationMode,
}

/// Authentication is the required authentication type for the allowed traffic, if any.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyIngressAuthenticationMode {
    #[serde(rename = "disabled")]
    Disabled,
    #[serde(rename = "required")]
    Required,
    #[serde(rename = "test-always-fail")]
    TestAlwaysFail,
}

/// CIDRRule is a rule that specifies a CIDR prefix to/from which outside
/// communication  is allowed, along with an optional list of subnets within that
/// CIDR prefix to/from which outside communication is not allowed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressFromCidrSet {
    /// CIDR is a CIDR prefix / IP Block.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    /// CIDRGroupRef is a reference to a CiliumCIDRGroup object.
    /// A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
    /// the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
    /// connections from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupRef")]
    pub cidr_group_ref: Option<String>,
    /// CIDRGroupSelector selects CiliumCIDRGroups by their labels,
    /// rather than by name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupSelector")]
    pub cidr_group_selector: Option<CiliumClusterwideNetworkPolicyIngressFromCidrSetCidrGroupSelector>,
    /// ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
    /// is not allowed to initiate connections to. These CIDR prefixes should be
    /// contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
    /// supported yet.
    /// These exceptions are only applied to the Cidr in this CIDRRule, and do not
    /// apply to any other CIDR prefixes in any other CIDRRules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub except: Option<Vec<String>>,
}

/// CIDRGroupSelector selects CiliumCIDRGroups by their labels,
/// rather than by name.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressFromCidrSetCidrGroupSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyIngressFromCidrSetCidrGroupSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressFromCidrSetCidrGroupSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyIngressFromCidrSetCidrGroupSelectorMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyIngressFromCidrSetCidrGroupSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressFromEndpoints {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyIngressFromEndpointsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressFromEndpointsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyIngressFromEndpointsMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyIngressFromEndpointsMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// Groups structure to store all kinds of new integrations that needs a new
/// derivative policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressFromGroups {
    /// AWSGroup is an structure that can be used to whitelisting information from AWS integration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<CiliumClusterwideNetworkPolicyIngressFromGroupsAws>,
}

/// AWSGroup is an structure that can be used to whitelisting information from AWS integration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressFromGroupsAws {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    pub security_groups_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsNames")]
    pub security_groups_names: Option<Vec<String>>,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressFromNodes {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyIngressFromNodesMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressFromNodesMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyIngressFromNodesMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyIngressFromNodesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressFromRequires {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyIngressFromRequiresMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressFromRequiresMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyIngressFromRequiresMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyIngressFromRequiresMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// ICMPRule is a list of ICMP fields.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressIcmps {
    /// Fields is a list of ICMP fields.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<CiliumClusterwideNetworkPolicyIngressIcmpsFields>>,
}

/// ICMPField is a ICMP field.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressIcmpsFields {
    /// Family is a IP address version.
    /// Currently, we support `IPv4` and `IPv6`.
    /// `IPv4` is set as default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<CiliumClusterwideNetworkPolicyIngressIcmpsFieldsFamily>,
    /// Type is a ICMP-type.
    /// It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
    /// Allowed ICMP types are:
    ///     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
    /// 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
    /// 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
    ///     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
    /// 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
    /// 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
    /// 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
    /// 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
    /// 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
    /// 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
    /// 			 ExtendedEchoRequest | ExtendedEchoReply
    #[serde(rename = "type")]
    pub r#type: IntOrString,
}

/// ICMPField is a ICMP field.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyIngressIcmpsFieldsFamily {
    IPv4,
    IPv6,
}

/// PortRule is a list of ports/protocol combinations with optional Layer 7
/// rules which must be met.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressToPorts {
    /// listener specifies the name of a custom Envoy listener to which this traffic should be
    /// redirected to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub listener: Option<CiliumClusterwideNetworkPolicyIngressToPortsListener>,
    /// OriginatingTLS is the TLS context for the connections originated by
    /// the L7 proxy.  For egress policy this specifies the client-side TLS
    /// parameters for the upstream connection originating from the L7 proxy
    /// to the remote destination. For ingress policy this specifies the
    /// client-side TLS parameters for the connection from the L7 proxy to
    /// the local endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originatingTLS")]
    pub originating_tls: Option<CiliumClusterwideNetworkPolicyIngressToPortsOriginatingTls>,
    /// Ports is a list of L4 port/protocol
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<CiliumClusterwideNetworkPolicyIngressToPortsPorts>>,
    /// Rules is a list of additional port level rules which must be met in
    /// order for the PortRule to allow the traffic. If omitted or empty,
    /// no layer 7 rules are enforced.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<CiliumClusterwideNetworkPolicyIngressToPortsRules>,
    /// ServerNames is a list of allowed TLS SNI values. If not empty, then
    /// TLS must be present and one of the provided SNIs must be indicated in the
    /// TLS handshake.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverNames")]
    pub server_names: Option<Vec<String>>,
    /// TerminatingTLS is the TLS context for the connection terminated by
    /// the L7 proxy.  For egress policy this specifies the server-side TLS
    /// parameters to be applied on the connections originated from the local
    /// endpoint and terminated by the L7 proxy. For ingress policy this specifies
    /// the server-side TLS parameters to be applied on the connections
    /// originated from a remote source and terminated by the L7 proxy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminatingTLS")]
    pub terminating_tls: Option<CiliumClusterwideNetworkPolicyIngressToPortsTerminatingTls>,
}

/// listener specifies the name of a custom Envoy listener to which this traffic should be
/// redirected to.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressToPortsListener {
    /// EnvoyConfig is a reference to the CEC or CCEC resource in which
    /// the listener is defined.
    #[serde(rename = "envoyConfig")]
    pub envoy_config: CiliumClusterwideNetworkPolicyIngressToPortsListenerEnvoyConfig,
    /// Name is the name of the listener.
    pub name: String,
    /// Priority for this Listener that is used when multiple rules would apply different
    /// listeners to a policy map entry. Behavior of this is implementation dependent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
}

/// EnvoyConfig is a reference to the CEC or CCEC resource in which
/// the listener is defined.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressToPortsListenerEnvoyConfig {
    /// Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
    /// CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
    /// respectively. The only case this is currently explicitly needed is when referring to a
    /// CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
    /// from a cluster scoped policy is not allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<CiliumClusterwideNetworkPolicyIngressToPortsListenerEnvoyConfigKind>,
    /// Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
    /// the listener is defined in.
    pub name: String,
}

/// EnvoyConfig is a reference to the CEC or CCEC resource in which
/// the listener is defined.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyIngressToPortsListenerEnvoyConfigKind {
    CiliumEnvoyConfig,
    CiliumClusterwideEnvoyConfig,
}

/// OriginatingTLS is the TLS context for the connections originated by
/// the L7 proxy.  For egress policy this specifies the client-side TLS
/// parameters for the upstream connection originating from the L7 proxy
/// to the remote destination. For ingress policy this specifies the
/// client-side TLS parameters for the connection from the L7 proxy to
/// the local endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressToPortsOriginatingTls {
    /// Certificate is the file name or k8s secret item name for the certificate
    /// chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
    /// item must exist.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    /// PrivateKey is the file name or k8s secret item name for the private key
    /// matching the certificate chain. If omitted, 'tls.key' is assumed, if it
    /// exists. If given, the item must exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// Secret is the secret that contains the certificates and private key for
    /// the TLS context.
    /// By default, Cilium will search in this secret for the following items:
    ///  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
    ///  - 'tls.crt' - Which represents the public key certificate.
    ///  - 'tls.key' - Which represents the private key matching the public key
    ///                certificate.
    pub secret: CiliumClusterwideNetworkPolicyIngressToPortsOriginatingTlsSecret,
    /// TrustedCA is the file name or k8s secret item name for the trusted CA.
    /// If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
    /// exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedCA")]
    pub trusted_ca: Option<String>,
}

/// Secret is the secret that contains the certificates and private key for
/// the TLS context.
/// By default, Cilium will search in this secret for the following items:
///  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
///  - 'tls.crt' - Which represents the public key certificate.
///  - 'tls.key' - Which represents the private key matching the public key
///                certificate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressToPortsOriginatingTlsSecret {
    /// Name is the name of the secret.
    pub name: String,
    /// Namespace is the namespace in which the secret exists. Context of use
    /// determines the default value if left out (e.g., "default").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// PortProtocol specifies an L4 port with an optional transport protocol
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressToPortsPorts {
    /// EndPort can only be an L4 port number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endPort")]
    pub end_port: Option<i32>,
    /// Port can be an L4 port number, or a name in the form of "http"
    /// or "http-8080".
    pub port: String,
    /// Protocol is the L4 protocol. If omitted or empty, any protocol
    /// matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
    /// 
    /// Matching on ICMP is not supported.
    /// 
    /// Named port specified for a container may narrow this down, but may not
    /// contradict this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<CiliumClusterwideNetworkPolicyIngressToPortsPortsProtocol>,
}

/// PortProtocol specifies an L4 port with an optional transport protocol
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyIngressToPortsPortsProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "SCTP")]
    Sctp,
    #[serde(rename = "ANY")]
    Any,
}

/// Rules is a list of additional port level rules which must be met in
/// order for the PortRule to allow the traffic. If omitted or empty,
/// no layer 7 rules are enforced.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressToPortsRules {
    /// DNS-specific rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dns: Option<Vec<CiliumClusterwideNetworkPolicyIngressToPortsRulesDns>>,
    /// HTTP specific rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<Vec<CiliumClusterwideNetworkPolicyIngressToPortsRulesHttp>>,
    /// Kafka-specific rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<Vec<CiliumClusterwideNetworkPolicyIngressToPortsRulesKafka>>,
    /// Key-value pair rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l7: Option<Vec<BTreeMap<String, String>>>,
    /// Name of the L7 protocol for which the Key-value pair rules apply.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l7proto: Option<String>,
}

/// PortRuleDNS is a list of allowed DNS lookups.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressToPortsRulesDns {
    /// MatchName matches literal DNS names. A trailing "." is automatically added
    /// when missing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchName")]
    pub match_name: Option<String>,
    /// MatchPattern allows using wildcards to match DNS names. All wildcards are
    /// case insensitive. The wildcards are:
    /// - "*" matches 0 or more DNS valid characters, and may occur anywhere in
    /// the pattern. As a special case a "*" as the leftmost character, without a
    /// following "." matches all subdomains as well as the name to the right.
    /// A trailing "." is automatically added when missing.
    /// 
    /// Examples:
    /// `*.cilium.io` matches subdomains of cilium at that level
    ///   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
    /// `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
    ///   except those containing "." separator, subcilium.io and sub-cilium.io match,
    ///   www.cilium.io and blog.cilium.io does not
    /// sub*.cilium.io matches subdomains of cilium where the subdomain component
    /// begins with "sub"
    ///   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
    ///   blog.cilium.io, cilium.io and google.com do not
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchPattern")]
    pub match_pattern: Option<String>,
}

/// PortRuleHTTP is a list of HTTP protocol constraints. All fields are
/// optional, if all fields are empty or missing, the rule does not have any
/// effect.
/// 
/// All fields of this type are extended POSIX regex as defined by IEEE Std
/// 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
/// matched against the path of an incoming request. Currently it can contain
/// characters disallowed from the conventional "path" part of a URL as defined
/// by RFC 3986.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressToPortsRulesHttp {
    /// HeaderMatches is a list of HTTP headers which must be
    /// present and match against the given values. Mismatch field can be used
    /// to specify what to do when there is no match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerMatches")]
    pub header_matches: Option<Vec<CiliumClusterwideNetworkPolicyIngressToPortsRulesHttpHeaderMatches>>,
    /// Headers is a list of HTTP headers which must be present in the
    /// request. If omitted or empty, requests are allowed regardless of
    /// headers present.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    /// Host is an extended POSIX regex matched against the host header of a
    /// request. Examples:
    /// 
    /// - foo.bar.com will match the host fooXbar.com or foo-bar.com
    /// - foo\.bar\.com will only match the host foo.bar.com
    /// 
    /// If omitted or empty, the value of the host header is ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Method is an extended POSIX regex matched against the method of a
    /// request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
    /// 
    /// If omitted or empty, all methods are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Path is an extended POSIX regex matched against the path of a
    /// request. Currently it can contain characters disallowed from the
    /// conventional "path" part of a URL as defined by RFC 3986.
    /// 
    /// If omitted or empty, all paths are all allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// HeaderMatch extends the HeaderValue for matching requirement of a
/// named header field against an immediate string or a secret value.
/// If none of the optional fields is present, then the
/// header value is not matched, only presence of the header is enough.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressToPortsRulesHttpHeaderMatches {
    /// Mismatch identifies what to do in case there is no match. The default is
    /// to drop the request. Otherwise the overall rule is still considered as
    /// matching, but the mismatches are logged in the access log.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mismatch: Option<CiliumClusterwideNetworkPolicyIngressToPortsRulesHttpHeaderMatchesMismatch>,
    /// Name identifies the header.
    pub name: String,
    /// Secret refers to a secret that contains the value to be matched against.
    /// The secret must only contain one entry. If the referred secret does not
    /// exist, and there is no "Value" specified, the match will fail.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CiliumClusterwideNetworkPolicyIngressToPortsRulesHttpHeaderMatchesSecret>,
    /// Value matches the exact value of the header. Can be specified either
    /// alone or together with "Secret"; will be used as the header value if the
    /// secret can not be found in the latter case.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// HeaderMatch extends the HeaderValue for matching requirement of a
/// named header field against an immediate string or a secret value.
/// If none of the optional fields is present, then the
/// header value is not matched, only presence of the header is enough.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyIngressToPortsRulesHttpHeaderMatchesMismatch {
    #[serde(rename = "LOG")]
    Log,
    #[serde(rename = "ADD")]
    Add,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "REPLACE")]
    Replace,
}

/// Secret refers to a secret that contains the value to be matched against.
/// The secret must only contain one entry. If the referred secret does not
/// exist, and there is no "Value" specified, the match will fail.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressToPortsRulesHttpHeaderMatchesSecret {
    /// Name is the name of the secret.
    pub name: String,
    /// Namespace is the namespace in which the secret exists. Context of use
    /// determines the default value if left out (e.g., "default").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// PortRule is a list of Kafka protocol constraints. All fields are
/// optional, if all fields are empty or missing, the rule will match all
/// Kafka messages.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressToPortsRulesKafka {
    /// APIKey is a case-insensitive string matched against the key of a
    /// request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
    /// Reference: https://kafka.apache.org/protocol#protocol_api_keys
    /// 
    /// If omitted or empty, and if Role is not specified, then all keys are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<String>,
    /// APIVersion is the version matched against the api version of the
    /// Kafka message. If set, it has to be a string representing a positive
    /// integer.
    /// 
    /// If omitted or empty, all versions are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// ClientID is the client identifier as provided in the request.
    /// 
    /// From Kafka protocol documentation:
    /// This is a user supplied identifier for the client application. The
    /// user can use any identifier they like and it will be used when
    /// logging errors, monitoring aggregates, etc. For example, one might
    /// want to monitor not just the requests per second overall, but the
    /// number coming from each client application (each of which could
    /// reside on multiple servers). This id acts as a logical grouping
    /// across all requests from a particular client.
    /// 
    /// If omitted or empty, all client identifiers are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientID")]
    pub client_id: Option<String>,
    /// Role is a case-insensitive string and describes a group of API keys
    /// necessary to perform certain higher-level Kafka operations such as "produce"
    /// or "consume". A Role automatically expands into all APIKeys required
    /// to perform the specified higher-level operation.
    /// 
    /// The following values are supported:
    ///  - "produce": Allow producing to the topics specified in the rule
    ///  - "consume": Allow consuming from the topics specified in the rule
    /// 
    /// This field is incompatible with the APIKey field, i.e APIKey and Role
    /// cannot both be specified in the same rule.
    /// 
    /// If omitted or empty, and if APIKey is not specified, then all keys are
    /// allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<CiliumClusterwideNetworkPolicyIngressToPortsRulesKafkaRole>,
    /// Topic is the topic name contained in the message. If a Kafka request
    /// contains multiple topics, then all topics must be allowed or the
    /// message will be rejected.
    /// 
    /// This constraint is ignored if the matched request message type
    /// doesn't contain any topic. Maximum size of Topic can be 249
    /// characters as per recent Kafka spec and allowed characters are
    /// a-z, A-Z, 0-9, -, . and _.
    /// 
    /// Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
    /// version the length was changed from 255 to 249. For compatibility
    /// reasons we are using 255.
    /// 
    /// If omitted or empty, all topics are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// PortRule is a list of Kafka protocol constraints. All fields are
/// optional, if all fields are empty or missing, the rule will match all
/// Kafka messages.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyIngressToPortsRulesKafkaRole {
    #[serde(rename = "produce")]
    Produce,
    #[serde(rename = "consume")]
    Consume,
}

/// TerminatingTLS is the TLS context for the connection terminated by
/// the L7 proxy.  For egress policy this specifies the server-side TLS
/// parameters to be applied on the connections originated from the local
/// endpoint and terminated by the L7 proxy. For ingress policy this specifies
/// the server-side TLS parameters to be applied on the connections
/// originated from a remote source and terminated by the L7 proxy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressToPortsTerminatingTls {
    /// Certificate is the file name or k8s secret item name for the certificate
    /// chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
    /// item must exist.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    /// PrivateKey is the file name or k8s secret item name for the private key
    /// matching the certificate chain. If omitted, 'tls.key' is assumed, if it
    /// exists. If given, the item must exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// Secret is the secret that contains the certificates and private key for
    /// the TLS context.
    /// By default, Cilium will search in this secret for the following items:
    ///  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
    ///  - 'tls.crt' - Which represents the public key certificate.
    ///  - 'tls.key' - Which represents the private key matching the public key
    ///                certificate.
    pub secret: CiliumClusterwideNetworkPolicyIngressToPortsTerminatingTlsSecret,
    /// TrustedCA is the file name or k8s secret item name for the trusted CA.
    /// If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
    /// exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedCA")]
    pub trusted_ca: Option<String>,
}

/// Secret is the secret that contains the certificates and private key for
/// the TLS context.
/// By default, Cilium will search in this secret for the following items:
///  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
///  - 'tls.crt' - Which represents the public key certificate.
///  - 'tls.key' - Which represents the private key matching the public key
///                certificate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressToPortsTerminatingTlsSecret {
    /// Name is the name of the secret.
    pub name: String,
    /// Namespace is the namespace in which the secret exists. Context of use
    /// determines the default value if left out (e.g., "default").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// IngressDenyRule contains all rule types which can be applied at ingress,
/// i.e. network traffic that originates outside of the endpoint and
/// is entering the endpoint selected by the endpointSelector.
/// 
///   - All members of this structure are optional. If omitted or empty, the
///     member will have no effect on the rule.
/// 
///   - If multiple members are set, all of them need to match in order for
///     the rule to take effect. The exception to this rule is FromRequires field;
///     the effects of any Requires field in any rule will apply to all other
///     rules as well.
/// 
///   - FromEndpoints, FromCIDR, FromCIDRSet, FromGroups and FromEntities are mutually
///     exclusive. Only one of these members may be present within an individual
///     rule.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressDeny {
    /// FromCIDR is a list of IP blocks which the endpoint subject to the
    /// rule is allowed to receive connections from. Only connections which
    /// do *not* originate from the cluster or from the local host are subject
    /// to CIDR rules. In order to allow in-cluster connectivity, use the
    /// FromEndpoints field.  This will match on the source IP address of
    /// incoming connections. Adding  a prefix into FromCIDR or into
    /// FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
    /// allowed between FromCIDR and FromCIDRSet.
    /// 
    /// Example:
    /// Any endpoint with the label "app=my-legacy-pet" is allowed to receive
    /// connections from 10.3.9.1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromCIDR")]
    pub from_cidr: Option<Vec<String>>,
    /// FromCIDRSet is a list of IP blocks which the endpoint subject to the
    /// rule is allowed to receive connections from in addition to FromEndpoints,
    /// along with a list of subnets contained within their corresponding IP block
    /// from which traffic should not be allowed.
    /// This will match on the source IP address of incoming connections. Adding
    /// a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
    /// equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
    /// 
    /// Example:
    /// Any endpoint with the label "app=my-legacy-pet" is allowed to receive
    /// connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromCIDRSet")]
    pub from_cidr_set: Option<Vec<CiliumClusterwideNetworkPolicyIngressDenyFromCidrSet>>,
    /// FromEndpoints is a list of endpoints identified by an
    /// EndpointSelector which are allowed to communicate with the endpoint
    /// subject to the rule.
    /// 
    /// Example:
    /// Any endpoint with the label "role=backend" can be consumed by any
    /// endpoint carrying the label "role=frontend".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEndpoints")]
    pub from_endpoints: Option<Vec<CiliumClusterwideNetworkPolicyIngressDenyFromEndpoints>>,
    /// FromEntities is a list of special entities which the endpoint subject
    /// to the rule is allowed to receive connections from. Supported entities are
    /// `world`, `cluster`, `host`, `remote-node`, `kube-apiserver`, `ingress`, `init`,
    /// `health`, `unmanaged`, `none` and `all`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEntities")]
    pub from_entities: Option<Vec<String>>,
    /// FromGroups is a directive that allows the integration with multiple outside
    /// providers. Currently, only AWS is supported, and the rule can select by
    /// multiple sub directives:
    /// 
    /// Example:
    /// FromGroups:
    /// - aws:
    ///     securityGroupsIds:
    ///     - 'sg-XXXXXXXXXXXXX'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromGroups")]
    pub from_groups: Option<Vec<CiliumClusterwideNetworkPolicyIngressDenyFromGroups>>,
    /// FromNodes is a list of nodes identified by an
    /// EndpointSelector which are allowed to communicate with the endpoint
    /// subject to the rule.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromNodes")]
    pub from_nodes: Option<Vec<CiliumClusterwideNetworkPolicyIngressDenyFromNodes>>,
    /// FromRequires is a list of additional constraints which must be met
    /// in order for the selected endpoints to be reachable. These
    /// additional constraints do no by itself grant access privileges and
    /// must always be accompanied with at least one matching FromEndpoints.
    /// 
    /// Example:
    /// Any Endpoint with the label "team=A" requires consuming endpoint
    /// to also carry the label "team=A".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromRequires")]
    pub from_requires: Option<Vec<CiliumClusterwideNetworkPolicyIngressDenyFromRequires>>,
    /// ICMPs is a list of ICMP rule identified by type number
    /// which the endpoint subject to the rule is not allowed to
    /// receive connections on.
    /// 
    /// Example:
    /// Any endpoint with the label "app=httpd" can not accept incoming
    /// type 8 ICMP connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icmps: Option<Vec<CiliumClusterwideNetworkPolicyIngressDenyIcmps>>,
    /// ToPorts is a list of destination ports identified by port number and
    /// protocol which the endpoint subject to the rule is not allowed to
    /// receive connections on.
    /// 
    /// Example:
    /// Any endpoint with the label "app=httpd" can not accept incoming
    /// connections on port 80/tcp.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toPorts")]
    pub to_ports: Option<Vec<CiliumClusterwideNetworkPolicyIngressDenyToPorts>>,
}

/// CIDRRule is a rule that specifies a CIDR prefix to/from which outside
/// communication  is allowed, along with an optional list of subnets within that
/// CIDR prefix to/from which outside communication is not allowed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressDenyFromCidrSet {
    /// CIDR is a CIDR prefix / IP Block.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    /// CIDRGroupRef is a reference to a CiliumCIDRGroup object.
    /// A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
    /// the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
    /// connections from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupRef")]
    pub cidr_group_ref: Option<String>,
    /// CIDRGroupSelector selects CiliumCIDRGroups by their labels,
    /// rather than by name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupSelector")]
    pub cidr_group_selector: Option<CiliumClusterwideNetworkPolicyIngressDenyFromCidrSetCidrGroupSelector>,
    /// ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
    /// is not allowed to initiate connections to. These CIDR prefixes should be
    /// contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
    /// supported yet.
    /// These exceptions are only applied to the Cidr in this CIDRRule, and do not
    /// apply to any other CIDR prefixes in any other CIDRRules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub except: Option<Vec<String>>,
}

/// CIDRGroupSelector selects CiliumCIDRGroups by their labels,
/// rather than by name.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressDenyFromCidrSetCidrGroupSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyIngressDenyFromCidrSetCidrGroupSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressDenyFromCidrSetCidrGroupSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyIngressDenyFromCidrSetCidrGroupSelectorMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyIngressDenyFromCidrSetCidrGroupSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressDenyFromEndpoints {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyIngressDenyFromEndpointsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressDenyFromEndpointsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyIngressDenyFromEndpointsMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyIngressDenyFromEndpointsMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// Groups structure to store all kinds of new integrations that needs a new
/// derivative policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressDenyFromGroups {
    /// AWSGroup is an structure that can be used to whitelisting information from AWS integration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<CiliumClusterwideNetworkPolicyIngressDenyFromGroupsAws>,
}

/// AWSGroup is an structure that can be used to whitelisting information from AWS integration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressDenyFromGroupsAws {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    pub security_groups_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsNames")]
    pub security_groups_names: Option<Vec<String>>,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressDenyFromNodes {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyIngressDenyFromNodesMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressDenyFromNodesMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyIngressDenyFromNodesMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyIngressDenyFromNodesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressDenyFromRequires {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyIngressDenyFromRequiresMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressDenyFromRequiresMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyIngressDenyFromRequiresMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyIngressDenyFromRequiresMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// ICMPRule is a list of ICMP fields.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressDenyIcmps {
    /// Fields is a list of ICMP fields.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<CiliumClusterwideNetworkPolicyIngressDenyIcmpsFields>>,
}

/// ICMPField is a ICMP field.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressDenyIcmpsFields {
    /// Family is a IP address version.
    /// Currently, we support `IPv4` and `IPv6`.
    /// `IPv4` is set as default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<CiliumClusterwideNetworkPolicyIngressDenyIcmpsFieldsFamily>,
    /// Type is a ICMP-type.
    /// It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
    /// Allowed ICMP types are:
    ///     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
    /// 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
    /// 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
    ///     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
    /// 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
    /// 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
    /// 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
    /// 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
    /// 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
    /// 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
    /// 			 ExtendedEchoRequest | ExtendedEchoReply
    #[serde(rename = "type")]
    pub r#type: IntOrString,
}

/// ICMPField is a ICMP field.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyIngressDenyIcmpsFieldsFamily {
    IPv4,
    IPv6,
}

/// PortDenyRule is a list of ports/protocol that should be used for deny
/// policies. This structure lacks the L7Rules since it's not supported in deny
/// policies.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressDenyToPorts {
    /// Ports is a list of L4 port/protocol
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<CiliumClusterwideNetworkPolicyIngressDenyToPortsPorts>>,
}

/// PortProtocol specifies an L4 port with an optional transport protocol
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyIngressDenyToPortsPorts {
    /// EndPort can only be an L4 port number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endPort")]
    pub end_port: Option<i32>,
    /// Port can be an L4 port number, or a name in the form of "http"
    /// or "http-8080".
    pub port: String,
    /// Protocol is the L4 protocol. If omitted or empty, any protocol
    /// matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
    /// 
    /// Matching on ICMP is not supported.
    /// 
    /// Named port specified for a container may narrow this down, but may not
    /// contradict this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<CiliumClusterwideNetworkPolicyIngressDenyToPortsPortsProtocol>,
}

/// PortProtocol specifies an L4 port with an optional transport protocol
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyIngressDenyToPortsPortsProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "SCTP")]
    Sctp,
    #[serde(rename = "ANY")]
    Any,
}

/// Label is the Cilium's representation of a container label.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyLabels {
    pub key: String,
    /// Source can be one of the above values (e.g.: LabelSourceContainer).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Log specifies custom policy-specific Hubble logging configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyLog {
    /// Value is a free-form string that is included in Hubble flows
    /// that match this policy. The string is limited to 32 printable characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// NodeSelector selects all nodes which should be subject to this rule.
/// EndpointSelector and NodeSelector cannot be both empty and are mutually
/// exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyNodeSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicyNodeSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyNodeSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicyNodeSelectorMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicyNodeSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// Rule is a policy rule which must be applied to all endpoints which match the
/// labels contained in the endpointSelector
/// 
/// Each rule is split into an ingress section which contains all rules
/// applicable at ingress, and an egress section applicable at egress. For rule
/// types such as `L4Rule` and `CIDR` which can be applied at both ingress and
/// egress, both ingress and egress side have to either specifically allow the
/// connection or one side has to be omitted.
/// 
/// Either ingress, egress, or both can be provided. If both ingress and egress
/// are omitted, the rule has no effect.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicys {
    /// Description is a free form string, it can be used by the creator of
    /// the rule to store human readable explanation of the purpose of this
    /// rule. Rules cannot be identified by comment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Egress is a list of EgressRule which are enforced at egress.
    /// If omitted or empty, this rule does not apply at egress.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub egress: Option<Vec<CiliumClusterwideNetworkPolicysEgress>>,
    /// EgressDeny is a list of EgressDenyRule which are enforced at egress.
    /// Any rule inserted here will be denied regardless of the allowed egress
    /// rules in the 'egress' field.
    /// If omitted or empty, this rule does not apply at egress.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressDeny")]
    pub egress_deny: Option<Vec<CiliumClusterwideNetworkPolicysEgressDeny>>,
    /// EnableDefaultDeny determines whether this policy configures the
    /// subject endpoint(s) to have a default deny mode. If enabled,
    /// this causes all traffic not explicitly allowed by a network policy
    /// to be dropped.
    /// 
    /// If not specified, the default is true for each traffic direction
    /// that has rules, and false otherwise. For example, if a policy
    /// only has Ingress or IngressDeny rules, then the default for
    /// ingress is true and egress is false.
    /// 
    /// If multiple policies apply to an endpoint, that endpoint's default deny
    /// will be enabled if any policy requests it.
    /// 
    /// This is useful for creating broad-based network policies that will not
    /// cause endpoints to enter default-deny mode.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableDefaultDeny")]
    pub enable_default_deny: Option<CiliumClusterwideNetworkPolicysEnableDefaultDeny>,
    /// EndpointSelector selects all endpoints which should be subject to
    /// this rule. EndpointSelector and NodeSelector cannot be both empty and
    /// are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointSelector")]
    pub endpoint_selector: Option<CiliumClusterwideNetworkPolicysEndpointSelector>,
    /// Ingress is a list of IngressRule which are enforced at ingress.
    /// If omitted or empty, this rule does not apply at ingress.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<Vec<CiliumClusterwideNetworkPolicysIngress>>,
    /// IngressDeny is a list of IngressDenyRule which are enforced at ingress.
    /// Any rule inserted here will be denied regardless of the allowed ingress
    /// rules in the 'ingress' field.
    /// If omitted or empty, this rule does not apply at ingress.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressDeny")]
    pub ingress_deny: Option<Vec<CiliumClusterwideNetworkPolicysIngressDeny>>,
    /// Labels is a list of optional strings which can be used to
    /// re-identify the rule or to store metadata. It is possible to lookup
    /// or delete strings based on labels. Labels are not required to be
    /// unique, multiple rules can have overlapping or identical labels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<Vec<CiliumClusterwideNetworkPolicysLabels>>,
    /// Log specifies custom policy-specific Hubble logging configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub log: Option<CiliumClusterwideNetworkPolicysLog>,
    /// NodeSelector selects all nodes which should be subject to this rule.
    /// EndpointSelector and NodeSelector cannot be both empty and are mutually
    /// exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<CiliumClusterwideNetworkPolicysNodeSelector>,
}

/// EgressRule contains all rule types which can be applied at egress, i.e.
/// network traffic that originates inside the endpoint and exits the endpoint
/// selected by the endpointSelector.
/// 
///   - All members of this structure are optional. If omitted or empty, the
///     member will have no effect on the rule.
/// 
///   - If multiple members of the structure are specified, then all members
///     must match in order for the rule to take effect. The exception to this
///     rule is the ToRequires member; the effects of any Requires field in any
///     rule will apply to all other rules as well.
/// 
///   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
///     mutually exclusive. Only one of these members may be present within an
///     individual rule.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgress {
    /// Authentication is the required authentication type for the allowed traffic, if any.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<CiliumClusterwideNetworkPolicysEgressAuthentication>,
    /// ICMPs is a list of ICMP rule identified by type number
    /// which the endpoint subject to the rule is allowed to connect to.
    /// 
    /// Example:
    /// Any endpoint with the label "app=httpd" is allowed to initiate
    /// type 8 ICMP connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icmps: Option<Vec<CiliumClusterwideNetworkPolicysEgressIcmps>>,
    /// ToCIDR is a list of IP blocks which the endpoint subject to the rule
    /// is allowed to initiate connections. Only connections destined for
    /// outside of the cluster and not targeting the host will be subject
    /// to CIDR rules.  This will match on the destination IP address of
    /// outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
    /// with no ExcludeCIDRs is equivalent. Overlaps are allowed between
    /// ToCIDR and ToCIDRSet.
    /// 
    /// Example:
    /// Any endpoint with the label "app=database-proxy" is allowed to
    /// initiate connections to 10.2.3.0/24
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toCIDR")]
    pub to_cidr: Option<Vec<String>>,
    /// ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
    /// is allowed to initiate connections to in addition to connections
    /// which are allowed via ToEndpoints, along with a list of subnets contained
    /// within their corresponding IP block to which traffic should not be
    /// allowed. This will match on the destination IP address of outgoing
    /// connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
    /// ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
    /// ToCIDRSet.
    /// 
    /// Example:
    /// Any endpoint with the label "app=database-proxy" is allowed to
    /// initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toCIDRSet")]
    pub to_cidr_set: Option<Vec<CiliumClusterwideNetworkPolicysEgressToCidrSet>>,
    /// ToEndpoints is a list of endpoints identified by an EndpointSelector to
    /// which the endpoints subject to the rule are allowed to communicate.
    /// 
    /// Example:
    /// Any endpoint with the label "role=frontend" can communicate with any
    /// endpoint carrying the label "role=backend".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toEndpoints")]
    pub to_endpoints: Option<Vec<CiliumClusterwideNetworkPolicysEgressToEndpoints>>,
    /// ToEntities is a list of special entities to which the endpoint subject
    /// to the rule is allowed to initiate connections. Supported entities are
    /// `world`, `cluster`, `host`, `remote-node`, `kube-apiserver`, `ingress`, `init`,
    /// `health`, `unmanaged`, `none` and `all`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toEntities")]
    pub to_entities: Option<Vec<String>>,
    /// ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result
    /// from DNS resolution of `ToFQDN.MatchName`s are added to the same
    /// EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and
    /// L7 rules within this EgressRule will also apply to these IPs.
    /// The DNS -> IP mapping is re-resolved periodically from within the
    /// cilium-agent, and the IPs in the DNS response are effected in the policy
    /// for selected pods as-is (i.e. the list of IPs is not modified in any way).
    /// Note: An explicit rule to allow for DNS traffic is needed for the pods, as
    /// ToFQDN counts as an egress rule and will enforce egress policy when
    /// PolicyEnforcment=default.
    /// Note: If the resolved IPs are IPs within the kubernetes cluster, the
    /// ToFQDN rule will not apply to that IP.
    /// Note: ToFQDN cannot occur in the same policy as other To* rules.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toFQDNs")]
    pub to_fqd_ns: Option<Vec<CiliumClusterwideNetworkPolicysEgressToFqdNs>>,
    /// ToGroups is a directive that allows the integration with multiple outside
    /// providers. Currently, only AWS is supported, and the rule can select by
    /// multiple sub directives:
    /// 
    /// Example:
    /// toGroups:
    /// - aws:
    ///     securityGroupsIds:
    ///     - 'sg-XXXXXXXXXXXXX'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toGroups")]
    pub to_groups: Option<Vec<CiliumClusterwideNetworkPolicysEgressToGroups>>,
    /// ToNodes is a list of nodes identified by an
    /// EndpointSelector to which endpoints subject to the rule is allowed to communicate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toNodes")]
    pub to_nodes: Option<Vec<CiliumClusterwideNetworkPolicysEgressToNodes>>,
    /// ToPorts is a list of destination ports identified by port number and
    /// protocol which the endpoint subject to the rule is allowed to
    /// connect to.
    /// 
    /// Example:
    /// Any endpoint with the label "role=frontend" is allowed to initiate
    /// connections to destination port 8080/tcp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toPorts")]
    pub to_ports: Option<Vec<CiliumClusterwideNetworkPolicysEgressToPorts>>,
    /// ToRequires is a list of additional constraints which must be met
    /// in order for the selected endpoints to be able to connect to other
    /// endpoints. These additional constraints do no by itself grant access
    /// privileges and must always be accompanied with at least one matching
    /// ToEndpoints.
    /// 
    /// Example:
    /// Any Endpoint with the label "team=A" requires any endpoint to which it
    /// communicates to also carry the label "team=A".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toRequires")]
    pub to_requires: Option<Vec<CiliumClusterwideNetworkPolicysEgressToRequires>>,
    /// ToServices is a list of services to which the endpoint subject
    /// to the rule is allowed to initiate connections.
    /// Currently Cilium only supports toServices for K8s services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toServices")]
    pub to_services: Option<Vec<CiliumClusterwideNetworkPolicysEgressToServices>>,
}

/// Authentication is the required authentication type for the allowed traffic, if any.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressAuthentication {
    /// Mode is the required authentication mode for the allowed traffic, if any.
    pub mode: CiliumClusterwideNetworkPolicysEgressAuthenticationMode,
}

/// Authentication is the required authentication type for the allowed traffic, if any.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressAuthenticationMode {
    #[serde(rename = "disabled")]
    Disabled,
    #[serde(rename = "required")]
    Required,
    #[serde(rename = "test-always-fail")]
    TestAlwaysFail,
}

/// ICMPRule is a list of ICMP fields.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressIcmps {
    /// Fields is a list of ICMP fields.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<CiliumClusterwideNetworkPolicysEgressIcmpsFields>>,
}

/// ICMPField is a ICMP field.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressIcmpsFields {
    /// Family is a IP address version.
    /// Currently, we support `IPv4` and `IPv6`.
    /// `IPv4` is set as default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<CiliumClusterwideNetworkPolicysEgressIcmpsFieldsFamily>,
    /// Type is a ICMP-type.
    /// It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
    /// Allowed ICMP types are:
    ///     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
    /// 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
    /// 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
    ///     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
    /// 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
    /// 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
    /// 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
    /// 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
    /// 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
    /// 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
    /// 			 ExtendedEchoRequest | ExtendedEchoReply
    #[serde(rename = "type")]
    pub r#type: IntOrString,
}

/// ICMPField is a ICMP field.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressIcmpsFieldsFamily {
    IPv4,
    IPv6,
}

/// CIDRRule is a rule that specifies a CIDR prefix to/from which outside
/// communication  is allowed, along with an optional list of subnets within that
/// CIDR prefix to/from which outside communication is not allowed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToCidrSet {
    /// CIDR is a CIDR prefix / IP Block.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    /// CIDRGroupRef is a reference to a CiliumCIDRGroup object.
    /// A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
    /// the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
    /// connections from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupRef")]
    pub cidr_group_ref: Option<String>,
    /// CIDRGroupSelector selects CiliumCIDRGroups by their labels,
    /// rather than by name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupSelector")]
    pub cidr_group_selector: Option<CiliumClusterwideNetworkPolicysEgressToCidrSetCidrGroupSelector>,
    /// ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
    /// is not allowed to initiate connections to. These CIDR prefixes should be
    /// contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
    /// supported yet.
    /// These exceptions are only applied to the Cidr in this CIDRRule, and do not
    /// apply to any other CIDR prefixes in any other CIDRRules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub except: Option<Vec<String>>,
}

/// CIDRGroupSelector selects CiliumCIDRGroups by their labels,
/// rather than by name.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToCidrSetCidrGroupSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysEgressToCidrSetCidrGroupSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToCidrSetCidrGroupSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysEgressToCidrSetCidrGroupSelectorMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressToCidrSetCidrGroupSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToEndpoints {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysEgressToEndpointsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToEndpointsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysEgressToEndpointsMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressToEndpointsMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToFqdNs {
    /// MatchName matches literal DNS names. A trailing "." is automatically added
    /// when missing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchName")]
    pub match_name: Option<String>,
    /// MatchPattern allows using wildcards to match DNS names. All wildcards are
    /// case insensitive. The wildcards are:
    /// - "*" matches 0 or more DNS valid characters, and may occur anywhere in
    /// the pattern. As a special case a "*" as the leftmost character, without a
    /// following "." matches all subdomains as well as the name to the right.
    /// A trailing "." is automatically added when missing.
    /// 
    /// Examples:
    /// `*.cilium.io` matches subdomains of cilium at that level
    ///   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
    /// `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
    ///   except those containing "." separator, subcilium.io and sub-cilium.io match,
    ///   www.cilium.io and blog.cilium.io does not
    /// sub*.cilium.io matches subdomains of cilium where the subdomain component
    /// begins with "sub"
    ///   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
    ///   blog.cilium.io, cilium.io and google.com do not
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchPattern")]
    pub match_pattern: Option<String>,
}

/// Groups structure to store all kinds of new integrations that needs a new
/// derivative policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToGroups {
    /// AWSGroup is an structure that can be used to whitelisting information from AWS integration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<CiliumClusterwideNetworkPolicysEgressToGroupsAws>,
}

/// AWSGroup is an structure that can be used to whitelisting information from AWS integration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToGroupsAws {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    pub security_groups_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsNames")]
    pub security_groups_names: Option<Vec<String>>,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToNodes {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysEgressToNodesMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToNodesMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysEgressToNodesMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressToNodesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// PortRule is a list of ports/protocol combinations with optional Layer 7
/// rules which must be met.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToPorts {
    /// listener specifies the name of a custom Envoy listener to which this traffic should be
    /// redirected to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub listener: Option<CiliumClusterwideNetworkPolicysEgressToPortsListener>,
    /// OriginatingTLS is the TLS context for the connections originated by
    /// the L7 proxy.  For egress policy this specifies the client-side TLS
    /// parameters for the upstream connection originating from the L7 proxy
    /// to the remote destination. For ingress policy this specifies the
    /// client-side TLS parameters for the connection from the L7 proxy to
    /// the local endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originatingTLS")]
    pub originating_tls: Option<CiliumClusterwideNetworkPolicysEgressToPortsOriginatingTls>,
    /// Ports is a list of L4 port/protocol
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<CiliumClusterwideNetworkPolicysEgressToPortsPorts>>,
    /// Rules is a list of additional port level rules which must be met in
    /// order for the PortRule to allow the traffic. If omitted or empty,
    /// no layer 7 rules are enforced.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<CiliumClusterwideNetworkPolicysEgressToPortsRules>,
    /// ServerNames is a list of allowed TLS SNI values. If not empty, then
    /// TLS must be present and one of the provided SNIs must be indicated in the
    /// TLS handshake.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverNames")]
    pub server_names: Option<Vec<String>>,
    /// TerminatingTLS is the TLS context for the connection terminated by
    /// the L7 proxy.  For egress policy this specifies the server-side TLS
    /// parameters to be applied on the connections originated from the local
    /// endpoint and terminated by the L7 proxy. For ingress policy this specifies
    /// the server-side TLS parameters to be applied on the connections
    /// originated from a remote source and terminated by the L7 proxy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminatingTLS")]
    pub terminating_tls: Option<CiliumClusterwideNetworkPolicysEgressToPortsTerminatingTls>,
}

/// listener specifies the name of a custom Envoy listener to which this traffic should be
/// redirected to.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToPortsListener {
    /// EnvoyConfig is a reference to the CEC or CCEC resource in which
    /// the listener is defined.
    #[serde(rename = "envoyConfig")]
    pub envoy_config: CiliumClusterwideNetworkPolicysEgressToPortsListenerEnvoyConfig,
    /// Name is the name of the listener.
    pub name: String,
    /// Priority for this Listener that is used when multiple rules would apply different
    /// listeners to a policy map entry. Behavior of this is implementation dependent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
}

/// EnvoyConfig is a reference to the CEC or CCEC resource in which
/// the listener is defined.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToPortsListenerEnvoyConfig {
    /// Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
    /// CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
    /// respectively. The only case this is currently explicitly needed is when referring to a
    /// CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
    /// from a cluster scoped policy is not allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<CiliumClusterwideNetworkPolicysEgressToPortsListenerEnvoyConfigKind>,
    /// Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
    /// the listener is defined in.
    pub name: String,
}

/// EnvoyConfig is a reference to the CEC or CCEC resource in which
/// the listener is defined.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressToPortsListenerEnvoyConfigKind {
    CiliumEnvoyConfig,
    CiliumClusterwideEnvoyConfig,
}

/// OriginatingTLS is the TLS context for the connections originated by
/// the L7 proxy.  For egress policy this specifies the client-side TLS
/// parameters for the upstream connection originating from the L7 proxy
/// to the remote destination. For ingress policy this specifies the
/// client-side TLS parameters for the connection from the L7 proxy to
/// the local endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToPortsOriginatingTls {
    /// Certificate is the file name or k8s secret item name for the certificate
    /// chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
    /// item must exist.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    /// PrivateKey is the file name or k8s secret item name for the private key
    /// matching the certificate chain. If omitted, 'tls.key' is assumed, if it
    /// exists. If given, the item must exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// Secret is the secret that contains the certificates and private key for
    /// the TLS context.
    /// By default, Cilium will search in this secret for the following items:
    ///  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
    ///  - 'tls.crt' - Which represents the public key certificate.
    ///  - 'tls.key' - Which represents the private key matching the public key
    ///                certificate.
    pub secret: CiliumClusterwideNetworkPolicysEgressToPortsOriginatingTlsSecret,
    /// TrustedCA is the file name or k8s secret item name for the trusted CA.
    /// If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
    /// exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedCA")]
    pub trusted_ca: Option<String>,
}

/// Secret is the secret that contains the certificates and private key for
/// the TLS context.
/// By default, Cilium will search in this secret for the following items:
///  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
///  - 'tls.crt' - Which represents the public key certificate.
///  - 'tls.key' - Which represents the private key matching the public key
///                certificate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToPortsOriginatingTlsSecret {
    /// Name is the name of the secret.
    pub name: String,
    /// Namespace is the namespace in which the secret exists. Context of use
    /// determines the default value if left out (e.g., "default").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// PortProtocol specifies an L4 port with an optional transport protocol
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToPortsPorts {
    /// EndPort can only be an L4 port number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endPort")]
    pub end_port: Option<i32>,
    /// Port can be an L4 port number, or a name in the form of "http"
    /// or "http-8080".
    pub port: String,
    /// Protocol is the L4 protocol. If omitted or empty, any protocol
    /// matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
    /// 
    /// Matching on ICMP is not supported.
    /// 
    /// Named port specified for a container may narrow this down, but may not
    /// contradict this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<CiliumClusterwideNetworkPolicysEgressToPortsPortsProtocol>,
}

/// PortProtocol specifies an L4 port with an optional transport protocol
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressToPortsPortsProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "SCTP")]
    Sctp,
    #[serde(rename = "ANY")]
    Any,
}

/// Rules is a list of additional port level rules which must be met in
/// order for the PortRule to allow the traffic. If omitted or empty,
/// no layer 7 rules are enforced.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToPortsRules {
    /// DNS-specific rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dns: Option<Vec<CiliumClusterwideNetworkPolicysEgressToPortsRulesDns>>,
    /// HTTP specific rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<Vec<CiliumClusterwideNetworkPolicysEgressToPortsRulesHttp>>,
    /// Kafka-specific rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<Vec<CiliumClusterwideNetworkPolicysEgressToPortsRulesKafka>>,
    /// Key-value pair rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l7: Option<Vec<BTreeMap<String, String>>>,
    /// Name of the L7 protocol for which the Key-value pair rules apply.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l7proto: Option<String>,
}

/// PortRuleDNS is a list of allowed DNS lookups.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToPortsRulesDns {
    /// MatchName matches literal DNS names. A trailing "." is automatically added
    /// when missing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchName")]
    pub match_name: Option<String>,
    /// MatchPattern allows using wildcards to match DNS names. All wildcards are
    /// case insensitive. The wildcards are:
    /// - "*" matches 0 or more DNS valid characters, and may occur anywhere in
    /// the pattern. As a special case a "*" as the leftmost character, without a
    /// following "." matches all subdomains as well as the name to the right.
    /// A trailing "." is automatically added when missing.
    /// 
    /// Examples:
    /// `*.cilium.io` matches subdomains of cilium at that level
    ///   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
    /// `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
    ///   except those containing "." separator, subcilium.io and sub-cilium.io match,
    ///   www.cilium.io and blog.cilium.io does not
    /// sub*.cilium.io matches subdomains of cilium where the subdomain component
    /// begins with "sub"
    ///   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
    ///   blog.cilium.io, cilium.io and google.com do not
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchPattern")]
    pub match_pattern: Option<String>,
}

/// PortRuleHTTP is a list of HTTP protocol constraints. All fields are
/// optional, if all fields are empty or missing, the rule does not have any
/// effect.
/// 
/// All fields of this type are extended POSIX regex as defined by IEEE Std
/// 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
/// matched against the path of an incoming request. Currently it can contain
/// characters disallowed from the conventional "path" part of a URL as defined
/// by RFC 3986.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToPortsRulesHttp {
    /// HeaderMatches is a list of HTTP headers which must be
    /// present and match against the given values. Mismatch field can be used
    /// to specify what to do when there is no match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerMatches")]
    pub header_matches: Option<Vec<CiliumClusterwideNetworkPolicysEgressToPortsRulesHttpHeaderMatches>>,
    /// Headers is a list of HTTP headers which must be present in the
    /// request. If omitted or empty, requests are allowed regardless of
    /// headers present.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    /// Host is an extended POSIX regex matched against the host header of a
    /// request. Examples:
    /// 
    /// - foo.bar.com will match the host fooXbar.com or foo-bar.com
    /// - foo\.bar\.com will only match the host foo.bar.com
    /// 
    /// If omitted or empty, the value of the host header is ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Method is an extended POSIX regex matched against the method of a
    /// request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
    /// 
    /// If omitted or empty, all methods are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Path is an extended POSIX regex matched against the path of a
    /// request. Currently it can contain characters disallowed from the
    /// conventional "path" part of a URL as defined by RFC 3986.
    /// 
    /// If omitted or empty, all paths are all allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// HeaderMatch extends the HeaderValue for matching requirement of a
/// named header field against an immediate string or a secret value.
/// If none of the optional fields is present, then the
/// header value is not matched, only presence of the header is enough.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToPortsRulesHttpHeaderMatches {
    /// Mismatch identifies what to do in case there is no match. The default is
    /// to drop the request. Otherwise the overall rule is still considered as
    /// matching, but the mismatches are logged in the access log.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mismatch: Option<CiliumClusterwideNetworkPolicysEgressToPortsRulesHttpHeaderMatchesMismatch>,
    /// Name identifies the header.
    pub name: String,
    /// Secret refers to a secret that contains the value to be matched against.
    /// The secret must only contain one entry. If the referred secret does not
    /// exist, and there is no "Value" specified, the match will fail.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CiliumClusterwideNetworkPolicysEgressToPortsRulesHttpHeaderMatchesSecret>,
    /// Value matches the exact value of the header. Can be specified either
    /// alone or together with "Secret"; will be used as the header value if the
    /// secret can not be found in the latter case.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// HeaderMatch extends the HeaderValue for matching requirement of a
/// named header field against an immediate string or a secret value.
/// If none of the optional fields is present, then the
/// header value is not matched, only presence of the header is enough.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressToPortsRulesHttpHeaderMatchesMismatch {
    #[serde(rename = "LOG")]
    Log,
    #[serde(rename = "ADD")]
    Add,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "REPLACE")]
    Replace,
}

/// Secret refers to a secret that contains the value to be matched against.
/// The secret must only contain one entry. If the referred secret does not
/// exist, and there is no "Value" specified, the match will fail.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToPortsRulesHttpHeaderMatchesSecret {
    /// Name is the name of the secret.
    pub name: String,
    /// Namespace is the namespace in which the secret exists. Context of use
    /// determines the default value if left out (e.g., "default").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// PortRule is a list of Kafka protocol constraints. All fields are
/// optional, if all fields are empty or missing, the rule will match all
/// Kafka messages.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToPortsRulesKafka {
    /// APIKey is a case-insensitive string matched against the key of a
    /// request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
    /// Reference: https://kafka.apache.org/protocol#protocol_api_keys
    /// 
    /// If omitted or empty, and if Role is not specified, then all keys are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<String>,
    /// APIVersion is the version matched against the api version of the
    /// Kafka message. If set, it has to be a string representing a positive
    /// integer.
    /// 
    /// If omitted or empty, all versions are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// ClientID is the client identifier as provided in the request.
    /// 
    /// From Kafka protocol documentation:
    /// This is a user supplied identifier for the client application. The
    /// user can use any identifier they like and it will be used when
    /// logging errors, monitoring aggregates, etc. For example, one might
    /// want to monitor not just the requests per second overall, but the
    /// number coming from each client application (each of which could
    /// reside on multiple servers). This id acts as a logical grouping
    /// across all requests from a particular client.
    /// 
    /// If omitted or empty, all client identifiers are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientID")]
    pub client_id: Option<String>,
    /// Role is a case-insensitive string and describes a group of API keys
    /// necessary to perform certain higher-level Kafka operations such as "produce"
    /// or "consume". A Role automatically expands into all APIKeys required
    /// to perform the specified higher-level operation.
    /// 
    /// The following values are supported:
    ///  - "produce": Allow producing to the topics specified in the rule
    ///  - "consume": Allow consuming from the topics specified in the rule
    /// 
    /// This field is incompatible with the APIKey field, i.e APIKey and Role
    /// cannot both be specified in the same rule.
    /// 
    /// If omitted or empty, and if APIKey is not specified, then all keys are
    /// allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<CiliumClusterwideNetworkPolicysEgressToPortsRulesKafkaRole>,
    /// Topic is the topic name contained in the message. If a Kafka request
    /// contains multiple topics, then all topics must be allowed or the
    /// message will be rejected.
    /// 
    /// This constraint is ignored if the matched request message type
    /// doesn't contain any topic. Maximum size of Topic can be 249
    /// characters as per recent Kafka spec and allowed characters are
    /// a-z, A-Z, 0-9, -, . and _.
    /// 
    /// Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
    /// version the length was changed from 255 to 249. For compatibility
    /// reasons we are using 255.
    /// 
    /// If omitted or empty, all topics are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// PortRule is a list of Kafka protocol constraints. All fields are
/// optional, if all fields are empty or missing, the rule will match all
/// Kafka messages.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressToPortsRulesKafkaRole {
    #[serde(rename = "produce")]
    Produce,
    #[serde(rename = "consume")]
    Consume,
}

/// TerminatingTLS is the TLS context for the connection terminated by
/// the L7 proxy.  For egress policy this specifies the server-side TLS
/// parameters to be applied on the connections originated from the local
/// endpoint and terminated by the L7 proxy. For ingress policy this specifies
/// the server-side TLS parameters to be applied on the connections
/// originated from a remote source and terminated by the L7 proxy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToPortsTerminatingTls {
    /// Certificate is the file name or k8s secret item name for the certificate
    /// chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
    /// item must exist.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    /// PrivateKey is the file name or k8s secret item name for the private key
    /// matching the certificate chain. If omitted, 'tls.key' is assumed, if it
    /// exists. If given, the item must exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// Secret is the secret that contains the certificates and private key for
    /// the TLS context.
    /// By default, Cilium will search in this secret for the following items:
    ///  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
    ///  - 'tls.crt' - Which represents the public key certificate.
    ///  - 'tls.key' - Which represents the private key matching the public key
    ///                certificate.
    pub secret: CiliumClusterwideNetworkPolicysEgressToPortsTerminatingTlsSecret,
    /// TrustedCA is the file name or k8s secret item name for the trusted CA.
    /// If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
    /// exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedCA")]
    pub trusted_ca: Option<String>,
}

/// Secret is the secret that contains the certificates and private key for
/// the TLS context.
/// By default, Cilium will search in this secret for the following items:
///  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
///  - 'tls.crt' - Which represents the public key certificate.
///  - 'tls.key' - Which represents the private key matching the public key
///                certificate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToPortsTerminatingTlsSecret {
    /// Name is the name of the secret.
    pub name: String,
    /// Namespace is the namespace in which the secret exists. Context of use
    /// determines the default value if left out (e.g., "default").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToRequires {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysEgressToRequiresMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToRequiresMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysEgressToRequiresMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressToRequiresMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// Service selects policy targets that are bundled as part of a
/// logical load-balanced service.
/// 
/// Currently only Kubernetes-based Services are supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToServices {
    /// K8sService selects service by name and namespace pair
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sService")]
    pub k8s_service: Option<CiliumClusterwideNetworkPolicysEgressToServicesK8sService>,
    /// K8sServiceSelector selects services by k8s labels and namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sServiceSelector")]
    pub k8s_service_selector: Option<CiliumClusterwideNetworkPolicysEgressToServicesK8sServiceSelector>,
}

/// K8sService selects service by name and namespace pair
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToServicesK8sService {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

/// K8sServiceSelector selects services by k8s labels and namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToServicesK8sServiceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// ServiceSelector is a label selector for k8s services
    pub selector: CiliumClusterwideNetworkPolicysEgressToServicesK8sServiceSelectorSelector,
}

/// ServiceSelector is a label selector for k8s services
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToServicesK8sServiceSelectorSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysEgressToServicesK8sServiceSelectorSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressToServicesK8sServiceSelectorSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysEgressToServicesK8sServiceSelectorSelectorMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressToServicesK8sServiceSelectorSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// EgressDenyRule contains all rule types which can be applied at egress, i.e.
/// network traffic that originates inside the endpoint and exits the endpoint
/// selected by the endpointSelector.
/// 
///   - All members of this structure are optional. If omitted or empty, the
///     member will have no effect on the rule.
/// 
///   - If multiple members of the structure are specified, then all members
///     must match in order for the rule to take effect. The exception to this
///     rule is the ToRequires member; the effects of any Requires field in any
///     rule will apply to all other rules as well.
/// 
///   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
///     mutually exclusive. Only one of these members may be present within an
///     individual rule.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDeny {
    /// ICMPs is a list of ICMP rule identified by type number
    /// which the endpoint subject to the rule is not allowed to connect to.
    /// 
    /// Example:
    /// Any endpoint with the label "app=httpd" is not allowed to initiate
    /// type 8 ICMP connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icmps: Option<Vec<CiliumClusterwideNetworkPolicysEgressDenyIcmps>>,
    /// ToCIDR is a list of IP blocks which the endpoint subject to the rule
    /// is allowed to initiate connections. Only connections destined for
    /// outside of the cluster and not targeting the host will be subject
    /// to CIDR rules.  This will match on the destination IP address of
    /// outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
    /// with no ExcludeCIDRs is equivalent. Overlaps are allowed between
    /// ToCIDR and ToCIDRSet.
    /// 
    /// Example:
    /// Any endpoint with the label "app=database-proxy" is allowed to
    /// initiate connections to 10.2.3.0/24
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toCIDR")]
    pub to_cidr: Option<Vec<String>>,
    /// ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
    /// is allowed to initiate connections to in addition to connections
    /// which are allowed via ToEndpoints, along with a list of subnets contained
    /// within their corresponding IP block to which traffic should not be
    /// allowed. This will match on the destination IP address of outgoing
    /// connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
    /// ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
    /// ToCIDRSet.
    /// 
    /// Example:
    /// Any endpoint with the label "app=database-proxy" is allowed to
    /// initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toCIDRSet")]
    pub to_cidr_set: Option<Vec<CiliumClusterwideNetworkPolicysEgressDenyToCidrSet>>,
    /// ToEndpoints is a list of endpoints identified by an EndpointSelector to
    /// which the endpoints subject to the rule are allowed to communicate.
    /// 
    /// Example:
    /// Any endpoint with the label "role=frontend" can communicate with any
    /// endpoint carrying the label "role=backend".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toEndpoints")]
    pub to_endpoints: Option<Vec<CiliumClusterwideNetworkPolicysEgressDenyToEndpoints>>,
    /// ToEntities is a list of special entities to which the endpoint subject
    /// to the rule is allowed to initiate connections. Supported entities are
    /// `world`, `cluster`, `host`, `remote-node`, `kube-apiserver`, `ingress`, `init`,
    /// `health`, `unmanaged`, `none` and `all`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toEntities")]
    pub to_entities: Option<Vec<String>>,
    /// ToGroups is a directive that allows the integration with multiple outside
    /// providers. Currently, only AWS is supported, and the rule can select by
    /// multiple sub directives:
    /// 
    /// Example:
    /// toGroups:
    /// - aws:
    ///     securityGroupsIds:
    ///     - 'sg-XXXXXXXXXXXXX'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toGroups")]
    pub to_groups: Option<Vec<CiliumClusterwideNetworkPolicysEgressDenyToGroups>>,
    /// ToNodes is a list of nodes identified by an
    /// EndpointSelector to which endpoints subject to the rule is allowed to communicate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toNodes")]
    pub to_nodes: Option<Vec<CiliumClusterwideNetworkPolicysEgressDenyToNodes>>,
    /// ToPorts is a list of destination ports identified by port number and
    /// protocol which the endpoint subject to the rule is not allowed to connect
    /// to.
    /// 
    /// Example:
    /// Any endpoint with the label "role=frontend" is not allowed to initiate
    /// connections to destination port 8080/tcp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toPorts")]
    pub to_ports: Option<Vec<CiliumClusterwideNetworkPolicysEgressDenyToPorts>>,
    /// ToRequires is a list of additional constraints which must be met
    /// in order for the selected endpoints to be able to connect to other
    /// endpoints. These additional constraints do no by itself grant access
    /// privileges and must always be accompanied with at least one matching
    /// ToEndpoints.
    /// 
    /// Example:
    /// Any Endpoint with the label "team=A" requires any endpoint to which it
    /// communicates to also carry the label "team=A".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toRequires")]
    pub to_requires: Option<Vec<CiliumClusterwideNetworkPolicysEgressDenyToRequires>>,
    /// ToServices is a list of services to which the endpoint subject
    /// to the rule is allowed to initiate connections.
    /// Currently Cilium only supports toServices for K8s services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toServices")]
    pub to_services: Option<Vec<CiliumClusterwideNetworkPolicysEgressDenyToServices>>,
}

/// ICMPRule is a list of ICMP fields.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyIcmps {
    /// Fields is a list of ICMP fields.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<CiliumClusterwideNetworkPolicysEgressDenyIcmpsFields>>,
}

/// ICMPField is a ICMP field.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyIcmpsFields {
    /// Family is a IP address version.
    /// Currently, we support `IPv4` and `IPv6`.
    /// `IPv4` is set as default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<CiliumClusterwideNetworkPolicysEgressDenyIcmpsFieldsFamily>,
    /// Type is a ICMP-type.
    /// It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
    /// Allowed ICMP types are:
    ///     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
    /// 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
    /// 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
    ///     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
    /// 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
    /// 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
    /// 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
    /// 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
    /// 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
    /// 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
    /// 			 ExtendedEchoRequest | ExtendedEchoReply
    #[serde(rename = "type")]
    pub r#type: IntOrString,
}

/// ICMPField is a ICMP field.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressDenyIcmpsFieldsFamily {
    IPv4,
    IPv6,
}

/// CIDRRule is a rule that specifies a CIDR prefix to/from which outside
/// communication  is allowed, along with an optional list of subnets within that
/// CIDR prefix to/from which outside communication is not allowed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToCidrSet {
    /// CIDR is a CIDR prefix / IP Block.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    /// CIDRGroupRef is a reference to a CiliumCIDRGroup object.
    /// A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
    /// the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
    /// connections from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupRef")]
    pub cidr_group_ref: Option<String>,
    /// CIDRGroupSelector selects CiliumCIDRGroups by their labels,
    /// rather than by name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupSelector")]
    pub cidr_group_selector: Option<CiliumClusterwideNetworkPolicysEgressDenyToCidrSetCidrGroupSelector>,
    /// ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
    /// is not allowed to initiate connections to. These CIDR prefixes should be
    /// contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
    /// supported yet.
    /// These exceptions are only applied to the Cidr in this CIDRRule, and do not
    /// apply to any other CIDR prefixes in any other CIDRRules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub except: Option<Vec<String>>,
}

/// CIDRGroupSelector selects CiliumCIDRGroups by their labels,
/// rather than by name.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToCidrSetCidrGroupSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysEgressDenyToCidrSetCidrGroupSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToCidrSetCidrGroupSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysEgressDenyToCidrSetCidrGroupSelectorMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressDenyToCidrSetCidrGroupSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToEndpoints {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysEgressDenyToEndpointsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToEndpointsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysEgressDenyToEndpointsMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressDenyToEndpointsMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// Groups structure to store all kinds of new integrations that needs a new
/// derivative policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToGroups {
    /// AWSGroup is an structure that can be used to whitelisting information from AWS integration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<CiliumClusterwideNetworkPolicysEgressDenyToGroupsAws>,
}

/// AWSGroup is an structure that can be used to whitelisting information from AWS integration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToGroupsAws {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    pub security_groups_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsNames")]
    pub security_groups_names: Option<Vec<String>>,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToNodes {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysEgressDenyToNodesMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToNodesMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysEgressDenyToNodesMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressDenyToNodesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// PortDenyRule is a list of ports/protocol that should be used for deny
/// policies. This structure lacks the L7Rules since it's not supported in deny
/// policies.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToPorts {
    /// Ports is a list of L4 port/protocol
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<CiliumClusterwideNetworkPolicysEgressDenyToPortsPorts>>,
}

/// PortProtocol specifies an L4 port with an optional transport protocol
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToPortsPorts {
    /// EndPort can only be an L4 port number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endPort")]
    pub end_port: Option<i32>,
    /// Port can be an L4 port number, or a name in the form of "http"
    /// or "http-8080".
    pub port: String,
    /// Protocol is the L4 protocol. If omitted or empty, any protocol
    /// matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
    /// 
    /// Matching on ICMP is not supported.
    /// 
    /// Named port specified for a container may narrow this down, but may not
    /// contradict this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<CiliumClusterwideNetworkPolicysEgressDenyToPortsPortsProtocol>,
}

/// PortProtocol specifies an L4 port with an optional transport protocol
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressDenyToPortsPortsProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "SCTP")]
    Sctp,
    #[serde(rename = "ANY")]
    Any,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToRequires {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysEgressDenyToRequiresMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToRequiresMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysEgressDenyToRequiresMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressDenyToRequiresMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// Service selects policy targets that are bundled as part of a
/// logical load-balanced service.
/// 
/// Currently only Kubernetes-based Services are supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToServices {
    /// K8sService selects service by name and namespace pair
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sService")]
    pub k8s_service: Option<CiliumClusterwideNetworkPolicysEgressDenyToServicesK8sService>,
    /// K8sServiceSelector selects services by k8s labels and namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sServiceSelector")]
    pub k8s_service_selector: Option<CiliumClusterwideNetworkPolicysEgressDenyToServicesK8sServiceSelector>,
}

/// K8sService selects service by name and namespace pair
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToServicesK8sService {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

/// K8sServiceSelector selects services by k8s labels and namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToServicesK8sServiceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// ServiceSelector is a label selector for k8s services
    pub selector: CiliumClusterwideNetworkPolicysEgressDenyToServicesK8sServiceSelectorSelector,
}

/// ServiceSelector is a label selector for k8s services
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToServicesK8sServiceSelectorSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// EnableDefaultDeny determines whether this policy configures the
/// subject endpoint(s) to have a default deny mode. If enabled,
/// this causes all traffic not explicitly allowed by a network policy
/// to be dropped.
/// 
/// If not specified, the default is true for each traffic direction
/// that has rules, and false otherwise. For example, if a policy
/// only has Ingress or IngressDeny rules, then the default for
/// ingress is true and egress is false.
/// 
/// If multiple policies apply to an endpoint, that endpoint's default deny
/// will be enabled if any policy requests it.
/// 
/// This is useful for creating broad-based network policies that will not
/// cause endpoints to enter default-deny mode.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEnableDefaultDeny {
    /// Whether or not the endpoint should have a default-deny rule applied
    /// to egress traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub egress: Option<bool>,
    /// Whether or not the endpoint should have a default-deny rule applied
    /// to ingress traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<bool>,
}

/// EndpointSelector selects all endpoints which should be subject to
/// this rule. EndpointSelector and NodeSelector cannot be both empty and
/// are mutually exclusive.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEndpointSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysEndpointSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysEndpointSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysEndpointSelectorMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysEndpointSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// IngressRule contains all rule types which can be applied at ingress,
/// i.e. network traffic that originates outside of the endpoint and
/// is entering the endpoint selected by the endpointSelector.
/// 
///   - All members of this structure are optional. If omitted or empty, the
///     member will have no effect on the rule.
/// 
///   - If multiple members are set, all of them need to match in order for
///     the rule to take effect. The exception to this rule is FromRequires field;
///     the effects of any Requires field in any rule will apply to all other
///     rules as well.
/// 
///   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually
///     exclusive. Only one of these members may be present within an individual
///     rule.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngress {
    /// Authentication is the required authentication type for the allowed traffic, if any.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<CiliumClusterwideNetworkPolicysIngressAuthentication>,
    /// FromCIDR is a list of IP blocks which the endpoint subject to the
    /// rule is allowed to receive connections from. Only connections which
    /// do *not* originate from the cluster or from the local host are subject
    /// to CIDR rules. In order to allow in-cluster connectivity, use the
    /// FromEndpoints field.  This will match on the source IP address of
    /// incoming connections. Adding  a prefix into FromCIDR or into
    /// FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
    /// allowed between FromCIDR and FromCIDRSet.
    /// 
    /// Example:
    /// Any endpoint with the label "app=my-legacy-pet" is allowed to receive
    /// connections from 10.3.9.1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromCIDR")]
    pub from_cidr: Option<Vec<String>>,
    /// FromCIDRSet is a list of IP blocks which the endpoint subject to the
    /// rule is allowed to receive connections from in addition to FromEndpoints,
    /// along with a list of subnets contained within their corresponding IP block
    /// from which traffic should not be allowed.
    /// This will match on the source IP address of incoming connections. Adding
    /// a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
    /// equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
    /// 
    /// Example:
    /// Any endpoint with the label "app=my-legacy-pet" is allowed to receive
    /// connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromCIDRSet")]
    pub from_cidr_set: Option<Vec<CiliumClusterwideNetworkPolicysIngressFromCidrSet>>,
    /// FromEndpoints is a list of endpoints identified by an
    /// EndpointSelector which are allowed to communicate with the endpoint
    /// subject to the rule.
    /// 
    /// Example:
    /// Any endpoint with the label "role=backend" can be consumed by any
    /// endpoint carrying the label "role=frontend".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEndpoints")]
    pub from_endpoints: Option<Vec<CiliumClusterwideNetworkPolicysIngressFromEndpoints>>,
    /// FromEntities is a list of special entities which the endpoint subject
    /// to the rule is allowed to receive connections from. Supported entities are
    /// `world`, `cluster`, `host`, `remote-node`, `kube-apiserver`, `ingress`, `init`,
    /// `health`, `unmanaged`, `none` and `all`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEntities")]
    pub from_entities: Option<Vec<String>>,
    /// FromGroups is a directive that allows the integration with multiple outside
    /// providers. Currently, only AWS is supported, and the rule can select by
    /// multiple sub directives:
    /// 
    /// Example:
    /// FromGroups:
    /// - aws:
    ///     securityGroupsIds:
    ///     - 'sg-XXXXXXXXXXXXX'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromGroups")]
    pub from_groups: Option<Vec<CiliumClusterwideNetworkPolicysIngressFromGroups>>,
    /// FromNodes is a list of nodes identified by an
    /// EndpointSelector which are allowed to communicate with the endpoint
    /// subject to the rule.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromNodes")]
    pub from_nodes: Option<Vec<CiliumClusterwideNetworkPolicysIngressFromNodes>>,
    /// FromRequires is a list of additional constraints which must be met
    /// in order for the selected endpoints to be reachable. These
    /// additional constraints do no by itself grant access privileges and
    /// must always be accompanied with at least one matching FromEndpoints.
    /// 
    /// Example:
    /// Any Endpoint with the label "team=A" requires consuming endpoint
    /// to also carry the label "team=A".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromRequires")]
    pub from_requires: Option<Vec<CiliumClusterwideNetworkPolicysIngressFromRequires>>,
    /// ICMPs is a list of ICMP rule identified by type number
    /// which the endpoint subject to the rule is allowed to
    /// receive connections on.
    /// 
    /// Example:
    /// Any endpoint with the label "app=httpd" can only accept incoming
    /// type 8 ICMP connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icmps: Option<Vec<CiliumClusterwideNetworkPolicysIngressIcmps>>,
    /// ToPorts is a list of destination ports identified by port number and
    /// protocol which the endpoint subject to the rule is allowed to
    /// receive connections on.
    /// 
    /// Example:
    /// Any endpoint with the label "app=httpd" can only accept incoming
    /// connections on port 80/tcp.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toPorts")]
    pub to_ports: Option<Vec<CiliumClusterwideNetworkPolicysIngressToPorts>>,
}

/// Authentication is the required authentication type for the allowed traffic, if any.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressAuthentication {
    /// Mode is the required authentication mode for the allowed traffic, if any.
    pub mode: CiliumClusterwideNetworkPolicysIngressAuthenticationMode,
}

/// Authentication is the required authentication type for the allowed traffic, if any.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysIngressAuthenticationMode {
    #[serde(rename = "disabled")]
    Disabled,
    #[serde(rename = "required")]
    Required,
    #[serde(rename = "test-always-fail")]
    TestAlwaysFail,
}

/// CIDRRule is a rule that specifies a CIDR prefix to/from which outside
/// communication  is allowed, along with an optional list of subnets within that
/// CIDR prefix to/from which outside communication is not allowed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressFromCidrSet {
    /// CIDR is a CIDR prefix / IP Block.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    /// CIDRGroupRef is a reference to a CiliumCIDRGroup object.
    /// A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
    /// the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
    /// connections from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupRef")]
    pub cidr_group_ref: Option<String>,
    /// CIDRGroupSelector selects CiliumCIDRGroups by their labels,
    /// rather than by name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupSelector")]
    pub cidr_group_selector: Option<CiliumClusterwideNetworkPolicysIngressFromCidrSetCidrGroupSelector>,
    /// ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
    /// is not allowed to initiate connections to. These CIDR prefixes should be
    /// contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
    /// supported yet.
    /// These exceptions are only applied to the Cidr in this CIDRRule, and do not
    /// apply to any other CIDR prefixes in any other CIDRRules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub except: Option<Vec<String>>,
}

/// CIDRGroupSelector selects CiliumCIDRGroups by their labels,
/// rather than by name.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressFromCidrSetCidrGroupSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysIngressFromCidrSetCidrGroupSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressFromCidrSetCidrGroupSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysIngressFromCidrSetCidrGroupSelectorMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysIngressFromCidrSetCidrGroupSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressFromEndpoints {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysIngressFromEndpointsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressFromEndpointsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysIngressFromEndpointsMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysIngressFromEndpointsMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// Groups structure to store all kinds of new integrations that needs a new
/// derivative policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressFromGroups {
    /// AWSGroup is an structure that can be used to whitelisting information from AWS integration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<CiliumClusterwideNetworkPolicysIngressFromGroupsAws>,
}

/// AWSGroup is an structure that can be used to whitelisting information from AWS integration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressFromGroupsAws {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    pub security_groups_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsNames")]
    pub security_groups_names: Option<Vec<String>>,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressFromNodes {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysIngressFromNodesMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressFromNodesMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysIngressFromNodesMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysIngressFromNodesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressFromRequires {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysIngressFromRequiresMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressFromRequiresMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysIngressFromRequiresMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysIngressFromRequiresMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// ICMPRule is a list of ICMP fields.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressIcmps {
    /// Fields is a list of ICMP fields.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<CiliumClusterwideNetworkPolicysIngressIcmpsFields>>,
}

/// ICMPField is a ICMP field.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressIcmpsFields {
    /// Family is a IP address version.
    /// Currently, we support `IPv4` and `IPv6`.
    /// `IPv4` is set as default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<CiliumClusterwideNetworkPolicysIngressIcmpsFieldsFamily>,
    /// Type is a ICMP-type.
    /// It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
    /// Allowed ICMP types are:
    ///     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
    /// 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
    /// 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
    ///     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
    /// 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
    /// 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
    /// 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
    /// 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
    /// 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
    /// 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
    /// 			 ExtendedEchoRequest | ExtendedEchoReply
    #[serde(rename = "type")]
    pub r#type: IntOrString,
}

/// ICMPField is a ICMP field.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysIngressIcmpsFieldsFamily {
    IPv4,
    IPv6,
}

/// PortRule is a list of ports/protocol combinations with optional Layer 7
/// rules which must be met.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressToPorts {
    /// listener specifies the name of a custom Envoy listener to which this traffic should be
    /// redirected to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub listener: Option<CiliumClusterwideNetworkPolicysIngressToPortsListener>,
    /// OriginatingTLS is the TLS context for the connections originated by
    /// the L7 proxy.  For egress policy this specifies the client-side TLS
    /// parameters for the upstream connection originating from the L7 proxy
    /// to the remote destination. For ingress policy this specifies the
    /// client-side TLS parameters for the connection from the L7 proxy to
    /// the local endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originatingTLS")]
    pub originating_tls: Option<CiliumClusterwideNetworkPolicysIngressToPortsOriginatingTls>,
    /// Ports is a list of L4 port/protocol
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<CiliumClusterwideNetworkPolicysIngressToPortsPorts>>,
    /// Rules is a list of additional port level rules which must be met in
    /// order for the PortRule to allow the traffic. If omitted or empty,
    /// no layer 7 rules are enforced.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<CiliumClusterwideNetworkPolicysIngressToPortsRules>,
    /// ServerNames is a list of allowed TLS SNI values. If not empty, then
    /// TLS must be present and one of the provided SNIs must be indicated in the
    /// TLS handshake.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverNames")]
    pub server_names: Option<Vec<String>>,
    /// TerminatingTLS is the TLS context for the connection terminated by
    /// the L7 proxy.  For egress policy this specifies the server-side TLS
    /// parameters to be applied on the connections originated from the local
    /// endpoint and terminated by the L7 proxy. For ingress policy this specifies
    /// the server-side TLS parameters to be applied on the connections
    /// originated from a remote source and terminated by the L7 proxy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminatingTLS")]
    pub terminating_tls: Option<CiliumClusterwideNetworkPolicysIngressToPortsTerminatingTls>,
}

/// listener specifies the name of a custom Envoy listener to which this traffic should be
/// redirected to.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressToPortsListener {
    /// EnvoyConfig is a reference to the CEC or CCEC resource in which
    /// the listener is defined.
    #[serde(rename = "envoyConfig")]
    pub envoy_config: CiliumClusterwideNetworkPolicysIngressToPortsListenerEnvoyConfig,
    /// Name is the name of the listener.
    pub name: String,
    /// Priority for this Listener that is used when multiple rules would apply different
    /// listeners to a policy map entry. Behavior of this is implementation dependent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
}

/// EnvoyConfig is a reference to the CEC or CCEC resource in which
/// the listener is defined.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressToPortsListenerEnvoyConfig {
    /// Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
    /// CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
    /// respectively. The only case this is currently explicitly needed is when referring to a
    /// CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
    /// from a cluster scoped policy is not allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<CiliumClusterwideNetworkPolicysIngressToPortsListenerEnvoyConfigKind>,
    /// Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
    /// the listener is defined in.
    pub name: String,
}

/// EnvoyConfig is a reference to the CEC or CCEC resource in which
/// the listener is defined.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysIngressToPortsListenerEnvoyConfigKind {
    CiliumEnvoyConfig,
    CiliumClusterwideEnvoyConfig,
}

/// OriginatingTLS is the TLS context for the connections originated by
/// the L7 proxy.  For egress policy this specifies the client-side TLS
/// parameters for the upstream connection originating from the L7 proxy
/// to the remote destination. For ingress policy this specifies the
/// client-side TLS parameters for the connection from the L7 proxy to
/// the local endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressToPortsOriginatingTls {
    /// Certificate is the file name or k8s secret item name for the certificate
    /// chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
    /// item must exist.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    /// PrivateKey is the file name or k8s secret item name for the private key
    /// matching the certificate chain. If omitted, 'tls.key' is assumed, if it
    /// exists. If given, the item must exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// Secret is the secret that contains the certificates and private key for
    /// the TLS context.
    /// By default, Cilium will search in this secret for the following items:
    ///  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
    ///  - 'tls.crt' - Which represents the public key certificate.
    ///  - 'tls.key' - Which represents the private key matching the public key
    ///                certificate.
    pub secret: CiliumClusterwideNetworkPolicysIngressToPortsOriginatingTlsSecret,
    /// TrustedCA is the file name or k8s secret item name for the trusted CA.
    /// If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
    /// exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedCA")]
    pub trusted_ca: Option<String>,
}

/// Secret is the secret that contains the certificates and private key for
/// the TLS context.
/// By default, Cilium will search in this secret for the following items:
///  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
///  - 'tls.crt' - Which represents the public key certificate.
///  - 'tls.key' - Which represents the private key matching the public key
///                certificate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressToPortsOriginatingTlsSecret {
    /// Name is the name of the secret.
    pub name: String,
    /// Namespace is the namespace in which the secret exists. Context of use
    /// determines the default value if left out (e.g., "default").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// PortProtocol specifies an L4 port with an optional transport protocol
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressToPortsPorts {
    /// EndPort can only be an L4 port number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endPort")]
    pub end_port: Option<i32>,
    /// Port can be an L4 port number, or a name in the form of "http"
    /// or "http-8080".
    pub port: String,
    /// Protocol is the L4 protocol. If omitted or empty, any protocol
    /// matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
    /// 
    /// Matching on ICMP is not supported.
    /// 
    /// Named port specified for a container may narrow this down, but may not
    /// contradict this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<CiliumClusterwideNetworkPolicysIngressToPortsPortsProtocol>,
}

/// PortProtocol specifies an L4 port with an optional transport protocol
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysIngressToPortsPortsProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "SCTP")]
    Sctp,
    #[serde(rename = "ANY")]
    Any,
}

/// Rules is a list of additional port level rules which must be met in
/// order for the PortRule to allow the traffic. If omitted or empty,
/// no layer 7 rules are enforced.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressToPortsRules {
    /// DNS-specific rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dns: Option<Vec<CiliumClusterwideNetworkPolicysIngressToPortsRulesDns>>,
    /// HTTP specific rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<Vec<CiliumClusterwideNetworkPolicysIngressToPortsRulesHttp>>,
    /// Kafka-specific rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<Vec<CiliumClusterwideNetworkPolicysIngressToPortsRulesKafka>>,
    /// Key-value pair rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l7: Option<Vec<BTreeMap<String, String>>>,
    /// Name of the L7 protocol for which the Key-value pair rules apply.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l7proto: Option<String>,
}

/// PortRuleDNS is a list of allowed DNS lookups.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressToPortsRulesDns {
    /// MatchName matches literal DNS names. A trailing "." is automatically added
    /// when missing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchName")]
    pub match_name: Option<String>,
    /// MatchPattern allows using wildcards to match DNS names. All wildcards are
    /// case insensitive. The wildcards are:
    /// - "*" matches 0 or more DNS valid characters, and may occur anywhere in
    /// the pattern. As a special case a "*" as the leftmost character, without a
    /// following "." matches all subdomains as well as the name to the right.
    /// A trailing "." is automatically added when missing.
    /// 
    /// Examples:
    /// `*.cilium.io` matches subdomains of cilium at that level
    ///   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
    /// `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
    ///   except those containing "." separator, subcilium.io and sub-cilium.io match,
    ///   www.cilium.io and blog.cilium.io does not
    /// sub*.cilium.io matches subdomains of cilium where the subdomain component
    /// begins with "sub"
    ///   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
    ///   blog.cilium.io, cilium.io and google.com do not
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchPattern")]
    pub match_pattern: Option<String>,
}

/// PortRuleHTTP is a list of HTTP protocol constraints. All fields are
/// optional, if all fields are empty or missing, the rule does not have any
/// effect.
/// 
/// All fields of this type are extended POSIX regex as defined by IEEE Std
/// 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
/// matched against the path of an incoming request. Currently it can contain
/// characters disallowed from the conventional "path" part of a URL as defined
/// by RFC 3986.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressToPortsRulesHttp {
    /// HeaderMatches is a list of HTTP headers which must be
    /// present and match against the given values. Mismatch field can be used
    /// to specify what to do when there is no match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerMatches")]
    pub header_matches: Option<Vec<CiliumClusterwideNetworkPolicysIngressToPortsRulesHttpHeaderMatches>>,
    /// Headers is a list of HTTP headers which must be present in the
    /// request. If omitted or empty, requests are allowed regardless of
    /// headers present.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    /// Host is an extended POSIX regex matched against the host header of a
    /// request. Examples:
    /// 
    /// - foo.bar.com will match the host fooXbar.com or foo-bar.com
    /// - foo\.bar\.com will only match the host foo.bar.com
    /// 
    /// If omitted or empty, the value of the host header is ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Method is an extended POSIX regex matched against the method of a
    /// request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
    /// 
    /// If omitted or empty, all methods are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Path is an extended POSIX regex matched against the path of a
    /// request. Currently it can contain characters disallowed from the
    /// conventional "path" part of a URL as defined by RFC 3986.
    /// 
    /// If omitted or empty, all paths are all allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// HeaderMatch extends the HeaderValue for matching requirement of a
/// named header field against an immediate string or a secret value.
/// If none of the optional fields is present, then the
/// header value is not matched, only presence of the header is enough.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressToPortsRulesHttpHeaderMatches {
    /// Mismatch identifies what to do in case there is no match. The default is
    /// to drop the request. Otherwise the overall rule is still considered as
    /// matching, but the mismatches are logged in the access log.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mismatch: Option<CiliumClusterwideNetworkPolicysIngressToPortsRulesHttpHeaderMatchesMismatch>,
    /// Name identifies the header.
    pub name: String,
    /// Secret refers to a secret that contains the value to be matched against.
    /// The secret must only contain one entry. If the referred secret does not
    /// exist, and there is no "Value" specified, the match will fail.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CiliumClusterwideNetworkPolicysIngressToPortsRulesHttpHeaderMatchesSecret>,
    /// Value matches the exact value of the header. Can be specified either
    /// alone or together with "Secret"; will be used as the header value if the
    /// secret can not be found in the latter case.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// HeaderMatch extends the HeaderValue for matching requirement of a
/// named header field against an immediate string or a secret value.
/// If none of the optional fields is present, then the
/// header value is not matched, only presence of the header is enough.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysIngressToPortsRulesHttpHeaderMatchesMismatch {
    #[serde(rename = "LOG")]
    Log,
    #[serde(rename = "ADD")]
    Add,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "REPLACE")]
    Replace,
}

/// Secret refers to a secret that contains the value to be matched against.
/// The secret must only contain one entry. If the referred secret does not
/// exist, and there is no "Value" specified, the match will fail.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressToPortsRulesHttpHeaderMatchesSecret {
    /// Name is the name of the secret.
    pub name: String,
    /// Namespace is the namespace in which the secret exists. Context of use
    /// determines the default value if left out (e.g., "default").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// PortRule is a list of Kafka protocol constraints. All fields are
/// optional, if all fields are empty or missing, the rule will match all
/// Kafka messages.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressToPortsRulesKafka {
    /// APIKey is a case-insensitive string matched against the key of a
    /// request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
    /// Reference: https://kafka.apache.org/protocol#protocol_api_keys
    /// 
    /// If omitted or empty, and if Role is not specified, then all keys are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<String>,
    /// APIVersion is the version matched against the api version of the
    /// Kafka message. If set, it has to be a string representing a positive
    /// integer.
    /// 
    /// If omitted or empty, all versions are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// ClientID is the client identifier as provided in the request.
    /// 
    /// From Kafka protocol documentation:
    /// This is a user supplied identifier for the client application. The
    /// user can use any identifier they like and it will be used when
    /// logging errors, monitoring aggregates, etc. For example, one might
    /// want to monitor not just the requests per second overall, but the
    /// number coming from each client application (each of which could
    /// reside on multiple servers). This id acts as a logical grouping
    /// across all requests from a particular client.
    /// 
    /// If omitted or empty, all client identifiers are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientID")]
    pub client_id: Option<String>,
    /// Role is a case-insensitive string and describes a group of API keys
    /// necessary to perform certain higher-level Kafka operations such as "produce"
    /// or "consume". A Role automatically expands into all APIKeys required
    /// to perform the specified higher-level operation.
    /// 
    /// The following values are supported:
    ///  - "produce": Allow producing to the topics specified in the rule
    ///  - "consume": Allow consuming from the topics specified in the rule
    /// 
    /// This field is incompatible with the APIKey field, i.e APIKey and Role
    /// cannot both be specified in the same rule.
    /// 
    /// If omitted or empty, and if APIKey is not specified, then all keys are
    /// allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<CiliumClusterwideNetworkPolicysIngressToPortsRulesKafkaRole>,
    /// Topic is the topic name contained in the message. If a Kafka request
    /// contains multiple topics, then all topics must be allowed or the
    /// message will be rejected.
    /// 
    /// This constraint is ignored if the matched request message type
    /// doesn't contain any topic. Maximum size of Topic can be 249
    /// characters as per recent Kafka spec and allowed characters are
    /// a-z, A-Z, 0-9, -, . and _.
    /// 
    /// Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
    /// version the length was changed from 255 to 249. For compatibility
    /// reasons we are using 255.
    /// 
    /// If omitted or empty, all topics are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// PortRule is a list of Kafka protocol constraints. All fields are
/// optional, if all fields are empty or missing, the rule will match all
/// Kafka messages.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysIngressToPortsRulesKafkaRole {
    #[serde(rename = "produce")]
    Produce,
    #[serde(rename = "consume")]
    Consume,
}

/// TerminatingTLS is the TLS context for the connection terminated by
/// the L7 proxy.  For egress policy this specifies the server-side TLS
/// parameters to be applied on the connections originated from the local
/// endpoint and terminated by the L7 proxy. For ingress policy this specifies
/// the server-side TLS parameters to be applied on the connections
/// originated from a remote source and terminated by the L7 proxy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressToPortsTerminatingTls {
    /// Certificate is the file name or k8s secret item name for the certificate
    /// chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
    /// item must exist.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    /// PrivateKey is the file name or k8s secret item name for the private key
    /// matching the certificate chain. If omitted, 'tls.key' is assumed, if it
    /// exists. If given, the item must exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// Secret is the secret that contains the certificates and private key for
    /// the TLS context.
    /// By default, Cilium will search in this secret for the following items:
    ///  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
    ///  - 'tls.crt' - Which represents the public key certificate.
    ///  - 'tls.key' - Which represents the private key matching the public key
    ///                certificate.
    pub secret: CiliumClusterwideNetworkPolicysIngressToPortsTerminatingTlsSecret,
    /// TrustedCA is the file name or k8s secret item name for the trusted CA.
    /// If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
    /// exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedCA")]
    pub trusted_ca: Option<String>,
}

/// Secret is the secret that contains the certificates and private key for
/// the TLS context.
/// By default, Cilium will search in this secret for the following items:
///  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
///  - 'tls.crt' - Which represents the public key certificate.
///  - 'tls.key' - Which represents the private key matching the public key
///                certificate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressToPortsTerminatingTlsSecret {
    /// Name is the name of the secret.
    pub name: String,
    /// Namespace is the namespace in which the secret exists. Context of use
    /// determines the default value if left out (e.g., "default").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// IngressDenyRule contains all rule types which can be applied at ingress,
/// i.e. network traffic that originates outside of the endpoint and
/// is entering the endpoint selected by the endpointSelector.
/// 
///   - All members of this structure are optional. If omitted or empty, the
///     member will have no effect on the rule.
/// 
///   - If multiple members are set, all of them need to match in order for
///     the rule to take effect. The exception to this rule is FromRequires field;
///     the effects of any Requires field in any rule will apply to all other
///     rules as well.
/// 
///   - FromEndpoints, FromCIDR, FromCIDRSet, FromGroups and FromEntities are mutually
///     exclusive. Only one of these members may be present within an individual
///     rule.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressDeny {
    /// FromCIDR is a list of IP blocks which the endpoint subject to the
    /// rule is allowed to receive connections from. Only connections which
    /// do *not* originate from the cluster or from the local host are subject
    /// to CIDR rules. In order to allow in-cluster connectivity, use the
    /// FromEndpoints field.  This will match on the source IP address of
    /// incoming connections. Adding  a prefix into FromCIDR or into
    /// FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
    /// allowed between FromCIDR and FromCIDRSet.
    /// 
    /// Example:
    /// Any endpoint with the label "app=my-legacy-pet" is allowed to receive
    /// connections from 10.3.9.1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromCIDR")]
    pub from_cidr: Option<Vec<String>>,
    /// FromCIDRSet is a list of IP blocks which the endpoint subject to the
    /// rule is allowed to receive connections from in addition to FromEndpoints,
    /// along with a list of subnets contained within their corresponding IP block
    /// from which traffic should not be allowed.
    /// This will match on the source IP address of incoming connections. Adding
    /// a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
    /// equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
    /// 
    /// Example:
    /// Any endpoint with the label "app=my-legacy-pet" is allowed to receive
    /// connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromCIDRSet")]
    pub from_cidr_set: Option<Vec<CiliumClusterwideNetworkPolicysIngressDenyFromCidrSet>>,
    /// FromEndpoints is a list of endpoints identified by an
    /// EndpointSelector which are allowed to communicate with the endpoint
    /// subject to the rule.
    /// 
    /// Example:
    /// Any endpoint with the label "role=backend" can be consumed by any
    /// endpoint carrying the label "role=frontend".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEndpoints")]
    pub from_endpoints: Option<Vec<CiliumClusterwideNetworkPolicysIngressDenyFromEndpoints>>,
    /// FromEntities is a list of special entities which the endpoint subject
    /// to the rule is allowed to receive connections from. Supported entities are
    /// `world`, `cluster`, `host`, `remote-node`, `kube-apiserver`, `ingress`, `init`,
    /// `health`, `unmanaged`, `none` and `all`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEntities")]
    pub from_entities: Option<Vec<String>>,
    /// FromGroups is a directive that allows the integration with multiple outside
    /// providers. Currently, only AWS is supported, and the rule can select by
    /// multiple sub directives:
    /// 
    /// Example:
    /// FromGroups:
    /// - aws:
    ///     securityGroupsIds:
    ///     - 'sg-XXXXXXXXXXXXX'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromGroups")]
    pub from_groups: Option<Vec<CiliumClusterwideNetworkPolicysIngressDenyFromGroups>>,
    /// FromNodes is a list of nodes identified by an
    /// EndpointSelector which are allowed to communicate with the endpoint
    /// subject to the rule.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromNodes")]
    pub from_nodes: Option<Vec<CiliumClusterwideNetworkPolicysIngressDenyFromNodes>>,
    /// FromRequires is a list of additional constraints which must be met
    /// in order for the selected endpoints to be reachable. These
    /// additional constraints do no by itself grant access privileges and
    /// must always be accompanied with at least one matching FromEndpoints.
    /// 
    /// Example:
    /// Any Endpoint with the label "team=A" requires consuming endpoint
    /// to also carry the label "team=A".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromRequires")]
    pub from_requires: Option<Vec<CiliumClusterwideNetworkPolicysIngressDenyFromRequires>>,
    /// ICMPs is a list of ICMP rule identified by type number
    /// which the endpoint subject to the rule is not allowed to
    /// receive connections on.
    /// 
    /// Example:
    /// Any endpoint with the label "app=httpd" can not accept incoming
    /// type 8 ICMP connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icmps: Option<Vec<CiliumClusterwideNetworkPolicysIngressDenyIcmps>>,
    /// ToPorts is a list of destination ports identified by port number and
    /// protocol which the endpoint subject to the rule is not allowed to
    /// receive connections on.
    /// 
    /// Example:
    /// Any endpoint with the label "app=httpd" can not accept incoming
    /// connections on port 80/tcp.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toPorts")]
    pub to_ports: Option<Vec<CiliumClusterwideNetworkPolicysIngressDenyToPorts>>,
}

/// CIDRRule is a rule that specifies a CIDR prefix to/from which outside
/// communication  is allowed, along with an optional list of subnets within that
/// CIDR prefix to/from which outside communication is not allowed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressDenyFromCidrSet {
    /// CIDR is a CIDR prefix / IP Block.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    /// CIDRGroupRef is a reference to a CiliumCIDRGroup object.
    /// A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
    /// the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
    /// connections from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupRef")]
    pub cidr_group_ref: Option<String>,
    /// CIDRGroupSelector selects CiliumCIDRGroups by their labels,
    /// rather than by name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupSelector")]
    pub cidr_group_selector: Option<CiliumClusterwideNetworkPolicysIngressDenyFromCidrSetCidrGroupSelector>,
    /// ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
    /// is not allowed to initiate connections to. These CIDR prefixes should be
    /// contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
    /// supported yet.
    /// These exceptions are only applied to the Cidr in this CIDRRule, and do not
    /// apply to any other CIDR prefixes in any other CIDRRules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub except: Option<Vec<String>>,
}

/// CIDRGroupSelector selects CiliumCIDRGroups by their labels,
/// rather than by name.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressDenyFromCidrSetCidrGroupSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysIngressDenyFromCidrSetCidrGroupSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressDenyFromCidrSetCidrGroupSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysIngressDenyFromCidrSetCidrGroupSelectorMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysIngressDenyFromCidrSetCidrGroupSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressDenyFromEndpoints {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysIngressDenyFromEndpointsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressDenyFromEndpointsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysIngressDenyFromEndpointsMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysIngressDenyFromEndpointsMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// Groups structure to store all kinds of new integrations that needs a new
/// derivative policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressDenyFromGroups {
    /// AWSGroup is an structure that can be used to whitelisting information from AWS integration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<CiliumClusterwideNetworkPolicysIngressDenyFromGroupsAws>,
}

/// AWSGroup is an structure that can be used to whitelisting information from AWS integration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressDenyFromGroupsAws {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    pub security_groups_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsNames")]
    pub security_groups_names: Option<Vec<String>>,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressDenyFromNodes {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysIngressDenyFromNodesMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressDenyFromNodesMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysIngressDenyFromNodesMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysIngressDenyFromNodesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// EndpointSelector is a wrapper for k8s LabelSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressDenyFromRequires {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysIngressDenyFromRequiresMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressDenyFromRequiresMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysIngressDenyFromRequiresMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysIngressDenyFromRequiresMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// ICMPRule is a list of ICMP fields.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressDenyIcmps {
    /// Fields is a list of ICMP fields.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<CiliumClusterwideNetworkPolicysIngressDenyIcmpsFields>>,
}

/// ICMPField is a ICMP field.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressDenyIcmpsFields {
    /// Family is a IP address version.
    /// Currently, we support `IPv4` and `IPv6`.
    /// `IPv4` is set as default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<CiliumClusterwideNetworkPolicysIngressDenyIcmpsFieldsFamily>,
    /// Type is a ICMP-type.
    /// It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
    /// Allowed ICMP types are:
    ///     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
    /// 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
    /// 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
    ///     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
    /// 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
    /// 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
    /// 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
    /// 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
    /// 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
    /// 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
    /// 			 ExtendedEchoRequest | ExtendedEchoReply
    #[serde(rename = "type")]
    pub r#type: IntOrString,
}

/// ICMPField is a ICMP field.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysIngressDenyIcmpsFieldsFamily {
    IPv4,
    IPv6,
}

/// PortDenyRule is a list of ports/protocol that should be used for deny
/// policies. This structure lacks the L7Rules since it's not supported in deny
/// policies.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressDenyToPorts {
    /// Ports is a list of L4 port/protocol
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<CiliumClusterwideNetworkPolicysIngressDenyToPortsPorts>>,
}

/// PortProtocol specifies an L4 port with an optional transport protocol
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysIngressDenyToPortsPorts {
    /// EndPort can only be an L4 port number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endPort")]
    pub end_port: Option<i32>,
    /// Port can be an L4 port number, or a name in the form of "http"
    /// or "http-8080".
    pub port: String,
    /// Protocol is the L4 protocol. If omitted or empty, any protocol
    /// matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
    /// 
    /// Matching on ICMP is not supported.
    /// 
    /// Named port specified for a container may narrow this down, but may not
    /// contradict this.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<CiliumClusterwideNetworkPolicysIngressDenyToPortsPortsProtocol>,
}

/// PortProtocol specifies an L4 port with an optional transport protocol
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysIngressDenyToPortsPortsProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "SCTP")]
    Sctp,
    #[serde(rename = "ANY")]
    Any,
}

/// Label is the Cilium's representation of a container label.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysLabels {
    pub key: String,
    /// Source can be one of the above values (e.g.: LabelSourceContainer).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Log specifies custom policy-specific Hubble logging configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysLog {
    /// Value is a free-form string that is included in Hubble flows
    /// that match this policy. The string is limited to 32 printable characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// NodeSelector selects all nodes which should be subject to this rule.
/// EndpointSelector and NodeSelector cannot be both empty and are mutually
/// exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysNodeSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumClusterwideNetworkPolicysNodeSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CiliumClusterwideNetworkPolicysNodeSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: CiliumClusterwideNetworkPolicysNodeSelectorMatchExpressionsOperator,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CiliumClusterwideNetworkPolicysNodeSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// Status is the status of the Cilium policy rule.
/// 
/// The reason this field exists in this structure is due a bug in the k8s
/// code-generator that doesn't create a `UpdateStatus` method because the
/// field does not exist in the structure.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// DerivativePolicies is the status of all policies derived from the Cilium
    /// policy
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "derivativePolicies")]
    pub derivative_policies: Option<BTreeMap<String, CiliumClusterwideNetworkPolicyStatusDerivativePolicies>>,
}

/// DerivativePolicies is the status of all policies derived from the Cilium
/// policy
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CiliumClusterwideNetworkPolicyStatusDerivativePolicies {
    /// Annotations corresponds to the Annotations in the ObjectMeta of the CNP
    /// that have been realized on the node for CNP. That is, if a CNP has been
    /// imported and has been assigned annotation X=Y by the user,
    /// Annotations in CiliumNetworkPolicyNodeStatus will be X=Y once the
    /// CNP that was imported corresponding to Annotation X=Y has been realized on
    /// the node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Enforcing is set to true once all endpoints present at the time the
    /// policy has been imported are enforcing this policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enforcing: Option<bool>,
    /// Error describes any error that occurred when parsing or importing the
    /// policy, or realizing the policy for the endpoints to which it applies
    /// on the node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    /// LastUpdated contains the last time this status was updated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastUpdated")]
    pub last_updated: Option<String>,
    /// Revision is the policy revision of the repository which first implemented
    /// this policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localPolicyRevision")]
    pub local_policy_revision: Option<i64>,
    /// OK is true when the policy has been parsed and imported successfully
    /// into the in-memory policy repository on the node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ok: Option<bool>,
}

