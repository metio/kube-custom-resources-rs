// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/Altinity/clickhouse-operator/clickhouse-keeper.altinity.com/v1/clickhousekeeperinstallations.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// Specification of the desired behavior of one or more ClickHouse clusters
/// More info: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md>
/// 
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "clickhouse-keeper.altinity.com", version = "v1", kind = "ClickHouseKeeperInstallation", plural = "clickhousekeeperinstallations")]
#[kube(namespaced)]
#[kube(status = "ClickHouseKeeperInstallationStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ClickHouseKeeperInstallationSpec {
    /// allows configure multiple aspects and behavior for `clickhouse-server` instance and also allows describe multiple `clickhouse-server` clusters inside one `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configuration: Option<ClickHouseKeeperInstallationConfiguration>,
    /// define default behavior for whole ClickHouseInstallation, some behavior can be re-define on cluster, shard and replica level
    /// More info: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md#specdefaults>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub defaults: Option<ClickHouseKeeperInstallationDefaults>,
    /// Custom domain pattern which will be used for DNS names of `Service` or `Pod`.
    /// Typical use scenario - custom cluster domain in Kubernetes cluster
    /// Example: %s.svc.my.test
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceDomainPattern")]
    pub namespace_domain_pattern: Option<String>,
    /// Optional, allows tuning reconciling cycle for ClickhouseInstallation from clickhouse-operator side
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reconciling: Option<ClickHouseKeeperInstallationReconciling>,
    /// Allows to stop all ClickHouse clusters defined in a CHI.
    /// Works as the following:
    ///  - When `stop` is `1` operator sets `Replicas: 0` in each StatefulSet. Thie leads to having all `Pods` and `Service` deleted. All PVCs are kept intact.
    ///  - When `stop` is `0` operator sets `Replicas: 1` and `Pod`s and `Service`s will created again and all retained PVCs will be attached to `Pod`s.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stop: Option<ClickHouseKeeperInstallationStop>,
    /// Suspend reconciliation of resources managed by a ClickHouse Keeper.
    /// Works as the following:
    ///  - When `suspend` is `true` operator stops reconciling all resources.
    ///  - When `suspend` is `false` or not set, operator reconciles all resources.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suspend: Option<ClickHouseKeeperInstallationSuspend>,
    /// Allows to define custom taskID for CHI update and watch status of this update execution.
    /// Displayed in all .status.taskID* fields.
    /// By default (if not filled) every update of CHI manifest will generate random taskID
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskID")]
    pub task_id: Option<String>,
    /// allows define templates which will use for render Kubernetes resources like StatefulSet, ConfigMap, Service, PVC, by default, clickhouse-operator have own templates, but you can override it
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub templates: Option<ClickHouseKeeperInstallationTemplates>,
}

/// allows configure multiple aspects and behavior for `clickhouse-server` instance and also allows describe multiple `clickhouse-server` clusters inside one `chi` resource
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationConfiguration {
    /// describes clusters layout and allows change settings on cluster-level and replica-level
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clusters: Option<Vec<ClickHouseKeeperInstallationConfigurationClusters>>,
    /// allows define content of any setting
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<BTreeMap<String, serde_json::Value>>,
    /// allows configure multiple aspects and behavior for `clickhouse-keeper` instance
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<BTreeMap<String, serde_json::Value>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationConfigurationClusters {
    /// optional, allows define content of any setting file inside each `Pod` on current cluster during generate `ConfigMap` which will mount in `/etc/clickhouse-server/config.d/` or `/etc/clickhouse-server/conf.d/` or `/etc/clickhouse-server/users.d/`
    /// override top-level `chi.spec.configuration.files`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<BTreeMap<String, serde_json::Value>>,
    /// describe current cluster layout, how much shards in cluster, how much replica in shard
    /// allows override settings on each shard and replica separatelly
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub layout: Option<ClickHouseKeeperInstallationConfigurationClustersLayout>,
    /// cluster name, used to identify set of servers and wide used during generate names of related Kubernetes resources
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specifies whether the Pod Disruption Budget (PDB) should be managed.
    /// During the next installation, if PDB management is enabled, the operator will
    /// attempt to retrieve any existing PDB. If none is found, it will create a new one
    /// and initiate a reconciliation loop. If PDB management is disabled, the existing PDB
    /// will remain intact, and the reconciliation loop will not be executed. By default,
    /// PDB management is enabled.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pdbManaged")]
    pub pdb_managed: Option<ClickHouseKeeperInstallationConfigurationClustersPdbManaged>,
    /// Pod eviction is allowed if at most "pdbMaxUnavailable" pods are unavailable after the eviction,
    /// i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions
    /// by specifying 0. This is a mutually exclusive setting with "minAvailable".
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pdbMaxUnavailable")]
    pub pdb_max_unavailable: Option<i64>,
    /// optional, allows configure `clickhouse-server` settings inside <yandex>...</yandex> tag in each `Pod` only in one cluster during generate `ConfigMap` which will mount in `/etc/clickhouse-server/config.d/`
    /// override top-level `chi.spec.configuration.settings`
    /// More details: <https://clickhouse.tech/docs/en/operations/settings/settings/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, configuration of the templates names which will use for generate Kubernetes resources according to selected cluster
    /// override top-level `chi.spec.configuration.templates`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub templates: Option<ClickHouseKeeperInstallationConfigurationClustersTemplates>,
}

/// describe current cluster layout, how much shards in cluster, how much replica in shard
/// allows override settings on each shard and replica separatelly
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationConfigurationClustersLayout {
    /// optional, allows override top-level `chi.spec.configuration` and cluster-level `chi.spec.configuration.clusters` configuration for each replica and each shard relates to selected replica, use it only if you fully understand what you do
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<Vec<ClickHouseKeeperInstallationConfigurationClustersLayoutReplicas>>,
    /// how much replicas in each shards for current cluster will run in Kubernetes,
    /// each replica is a separate `StatefulSet` which contains only one `Pod` with `clickhouse-server` instance,
    /// every shard contains 1 replica by default"
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicasCount")]
    pub replicas_count: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationConfigurationClustersLayoutReplicas {
    /// optional, allows define content of any setting file inside each `Pod` only in one replica during generate `ConfigMap` which will mount in `/etc/clickhouse-server/config.d/` or `/etc/clickhouse-server/conf.d/` or `/etc/clickhouse-server/users.d/`
    /// override top-level `chi.spec.configuration.files` and cluster-level `chi.spec.configuration.clusters.files`, will ignore if `chi.spec.configuration.clusters.layout.shards` presents
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, by default replica name is generated, but you can override it and setup custom name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional, allows configure `clickhouse-server` settings inside <yandex>...</yandex> tag in `Pod` only in one replica during generate `ConfigMap` which will mount in `/etc/clickhouse-server/conf.d/`
    /// override top-level `chi.spec.configuration.settings`, cluster-level `chi.spec.configuration.clusters.settings` and will ignore if shard-level `chi.spec.configuration.clusters.layout.shards` present
    /// More details: <https://clickhouse.tech/docs/en/operations/settings/settings/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, list of shards related to current replica, will ignore if `chi.spec.configuration.clusters.layout.shards` presents
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shards: Option<Vec<ClickHouseKeeperInstallationConfigurationClustersLayoutReplicasShards>>,
    /// optional, count of shards related to current replica, you can override each shard behavior on low-level `chi.spec.configuration.clusters.layout.replicas.shards`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardsCount")]
    pub shards_count: Option<i64>,
    /// optional, configuration of the templates names which will use for generate Kubernetes resources according to selected replica
    /// override top-level `chi.spec.configuration.templates`, cluster-level `chi.spec.configuration.clusters.templates`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub templates: Option<ClickHouseKeeperInstallationConfigurationClustersLayoutReplicasTemplates>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationConfigurationClustersLayoutReplicasShards {
    /// optional, allows define content of any setting file inside each `Pod` only in one shard related to current replica during generate `ConfigMap` which will mount in `/etc/clickhouse-server/config.d/` or `/etc/clickhouse-server/conf.d/` or `/etc/clickhouse-server/users.d/`
    /// override top-level `chi.spec.configuration.files` and cluster-level `chi.spec.configuration.clusters.files`, will ignore if `chi.spec.configuration.clusters.layout.shards` presents
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, by default shard name is generated, but you can override it and setup custom name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "raftPort")]
    pub raft_port: Option<i64>,
    /// optional, allows configure `clickhouse-server` settings inside <yandex>...</yandex> tag in `Pod` only in one shard related to current replica during generate `ConfigMap` which will mount in `/etc/clickhouse-server/conf.d/`
    /// override top-level `chi.spec.configuration.settings`, cluster-level `chi.spec.configuration.clusters.settings` and replica-level `chi.spec.configuration.clusters.layout.replicas.settings`
    /// More details: <https://clickhouse.tech/docs/en/operations/settings/settings/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, configuration of the templates names which will use for generate Kubernetes resources according to selected replica
    /// override top-level `chi.spec.configuration.templates`, cluster-level `chi.spec.configuration.clusters.templates`, replica-level `chi.spec.configuration.clusters.layout.replicas.templates`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub templates: Option<ClickHouseKeeperInstallationConfigurationClustersLayoutReplicasShardsTemplates>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zkPort")]
    pub zk_port: Option<i64>,
}

/// optional, configuration of the templates names which will use for generate Kubernetes resources according to selected replica
/// override top-level `chi.spec.configuration.templates`, cluster-level `chi.spec.configuration.clusters.templates`, replica-level `chi.spec.configuration.clusters.layout.replicas.templates`
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationConfigurationClustersLayoutReplicasShardsTemplates {
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterServiceTemplate")]
    pub cluster_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataVolumeClaimTemplate")]
    pub data_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.hostTemplates, which will apply to configure every `clickhouse-server` instance during render ConfigMap resources which will mount into `Pod`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostTemplate")]
    pub host_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse log directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logVolumeClaimTemplate")]
    pub log_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.podTemplates, allows customization each `Pod` resource during render and reconcile each StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each replica inside each shard inside each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceTemplate")]
    pub replica_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates. used for customization of the `Service` resource, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplate")]
    pub service_template: Option<String>,
    /// optional, template names from chi.spec.templates.serviceTemplates. used for customization of the `Service` resources, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplates")]
    pub service_templates: Option<Vec<String>>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each shard inside clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardServiceTemplate")]
    pub shard_service_template: Option<String>,
    /// optional, alias for dataVolumeClaimTemplate, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<String>,
}

/// optional, configuration of the templates names which will use for generate Kubernetes resources according to selected replica
/// override top-level `chi.spec.configuration.templates`, cluster-level `chi.spec.configuration.clusters.templates`
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationConfigurationClustersLayoutReplicasTemplates {
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterServiceTemplate")]
    pub cluster_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataVolumeClaimTemplate")]
    pub data_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.hostTemplates, which will apply to configure every `clickhouse-server` instance during render ConfigMap resources which will mount into `Pod`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostTemplate")]
    pub host_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse log directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logVolumeClaimTemplate")]
    pub log_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.podTemplates, allows customization each `Pod` resource during render and reconcile each StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each replica inside each shard inside each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceTemplate")]
    pub replica_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates. used for customization of the `Service` resource, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplate")]
    pub service_template: Option<String>,
    /// optional, template names from chi.spec.templates.serviceTemplates. used for customization of the `Service` resources, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplates")]
    pub service_templates: Option<Vec<String>>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each shard inside clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardServiceTemplate")]
    pub shard_service_template: Option<String>,
    /// optional, alias for dataVolumeClaimTemplate, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationConfigurationClustersPdbManaged {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// optional, configuration of the templates names which will use for generate Kubernetes resources according to selected cluster
/// override top-level `chi.spec.configuration.templates`
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationConfigurationClustersTemplates {
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterServiceTemplate")]
    pub cluster_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataVolumeClaimTemplate")]
    pub data_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.hostTemplates, which will apply to configure every `clickhouse-server` instance during render ConfigMap resources which will mount into `Pod`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostTemplate")]
    pub host_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse log directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logVolumeClaimTemplate")]
    pub log_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.podTemplates, allows customization each `Pod` resource during render and reconcile each StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each replica inside each shard inside each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceTemplate")]
    pub replica_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates. used for customization of the `Service` resource, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplate")]
    pub service_template: Option<String>,
    /// optional, template names from chi.spec.templates.serviceTemplates. used for customization of the `Service` resources, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplates")]
    pub service_templates: Option<Vec<String>>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each shard inside clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardServiceTemplate")]
    pub shard_service_template: Option<String>,
    /// optional, alias for dataVolumeClaimTemplate, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<String>,
}

/// define default behavior for whole ClickHouseInstallation, some behavior can be re-define on cluster, shard and replica level
/// More info: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md#specdefaults>
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationDefaults {
    /// allows change `<yandex><distributed_ddl></distributed_ddl></yandex>` settings
    /// More info: <https://clickhouse.tech/docs/en/operations/server-configuration-parameters/settings/#server-settings-distributed_ddl>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "distributedDDL")]
    pub distributed_ddl: Option<ClickHouseKeeperInstallationDefaultsDistributedDdl>,
    /// define should replicas be specified by FQDN in `<host></host>`.
    /// In case of "no" will use short hostname and clickhouse-server will use kubernetes default suffixes for DNS lookup
    /// "no" by default
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicasUseFQDN")]
    pub replicas_use_fqdn: Option<ClickHouseKeeperInstallationDefaultsReplicasUseFqdn>,
    /// default storage management options
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageManagement")]
    pub storage_management: Option<ClickHouseKeeperInstallationDefaultsStorageManagement>,
    /// optional, configuration of the templates names which will use for generate Kubernetes resources according to one or more ClickHouse clusters described in current ClickHouseInstallation (chi) resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub templates: Option<ClickHouseKeeperInstallationDefaultsTemplates>,
}

/// allows change `<yandex><distributed_ddl></distributed_ddl></yandex>` settings
/// More info: <https://clickhouse.tech/docs/en/operations/server-configuration-parameters/settings/#server-settings-distributed_ddl>
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationDefaultsDistributedDdl {
    /// Settings from this profile will be used to execute DDL queries
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub profile: Option<String>,
}

/// define default behavior for whole ClickHouseInstallation, some behavior can be re-define on cluster, shard and replica level
/// More info: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md#specdefaults>
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationDefaultsReplicasUseFqdn {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// default storage management options
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationDefaultsStorageManagement {
    /// defines `PVC` provisioner - be it StatefulSet or the Operator
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provisioner: Option<ClickHouseKeeperInstallationDefaultsStorageManagementProvisioner>,
    /// defines behavior of `PVC` deletion.
    /// `Delete` by default, if `Retain` specified then `PVC` will be kept when deleting StatefulSet
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reclaimPolicy")]
    pub reclaim_policy: Option<ClickHouseKeeperInstallationDefaultsStorageManagementReclaimPolicy>,
}

/// default storage management options
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationDefaultsStorageManagementProvisioner {
    #[serde(rename = "")]
    KopiumEmpty,
    StatefulSet,
    Operator,
}

/// default storage management options
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationDefaultsStorageManagementReclaimPolicy {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// optional, configuration of the templates names which will use for generate Kubernetes resources according to one or more ClickHouse clusters described in current ClickHouseInstallation (chi) resource
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationDefaultsTemplates {
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterServiceTemplate")]
    pub cluster_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataVolumeClaimTemplate")]
    pub data_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.hostTemplates, which will apply to configure every `clickhouse-server` instance during render ConfigMap resources which will mount into `Pod`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostTemplate")]
    pub host_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse log directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logVolumeClaimTemplate")]
    pub log_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.podTemplates, allows customization each `Pod` resource during render and reconcile each StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each replica inside each shard inside each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceTemplate")]
    pub replica_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates. used for customization of the `Service` resource, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplate")]
    pub service_template: Option<String>,
    /// optional, template names from chi.spec.templates.serviceTemplates. used for customization of the `Service` resources, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplates")]
    pub service_templates: Option<Vec<String>>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each shard inside clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardServiceTemplate")]
    pub shard_service_template: Option<String>,
    /// optional, alias for dataVolumeClaimTemplate, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<String>,
}

/// Optional, allows tuning reconciling cycle for ClickhouseInstallation from clickhouse-operator side
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationReconciling {
    /// Optional, defines behavior for cleanup Kubernetes resources during reconcile cycle
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cleanup: Option<ClickHouseKeeperInstallationReconcilingCleanup>,
    /// Timeout in seconds for `clickhouse-operator` to wait for modified `ConfigMap` to propagate into the `Pod`
    /// More details: <https://kubernetes.io/docs/concepts/configuration/configmap/#mounted-configmaps-are-updated-automatically>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapPropagationTimeout")]
    pub config_map_propagation_timeout: Option<i64>,
    /// DISCUSSED TO BE DEPRECATED
    /// Syntax sugar
    /// Overrides all three 'reconcile.host.wait.{exclude, queries, include}' values from the operator's config
    /// Possible values:
    ///  - wait - should wait to exclude host, complete queries and include host back into the cluster
    ///  - nowait - should NOT wait to exclude host, complete queries and include host back into the cluster
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClickHouseKeeperInstallationReconcilingPolicy>,
}

/// Optional, defines behavior for cleanup Kubernetes resources during reconcile cycle
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationReconcilingCleanup {
    /// Describes what clickhouse-operator should do with Kubernetes resources which are failed during reconcile.
    /// Default behavior is `Retain`"
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reconcileFailedObjects")]
    pub reconcile_failed_objects: Option<ClickHouseKeeperInstallationReconcilingCleanupReconcileFailedObjects>,
    /// Describes what clickhouse-operator should do with found Kubernetes resources which should be managed by clickhouse-operator,
    /// but do not have `ownerReference` to any currently managed `ClickHouseInstallation` resource.
    /// Default behavior is `Delete`"
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unknownObjects")]
    pub unknown_objects: Option<ClickHouseKeeperInstallationReconcilingCleanupUnknownObjects>,
}

/// Describes what clickhouse-operator should do with Kubernetes resources which are failed during reconcile.
/// Default behavior is `Retain`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationReconcilingCleanupReconcileFailedObjects {
    /// Behavior policy for failed ConfigMap, `Retain` by default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ClickHouseKeeperInstallationReconcilingCleanupReconcileFailedObjectsConfigMap>,
    /// Behavior policy for failed PVC, `Retain` by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pvc: Option<ClickHouseKeeperInstallationReconcilingCleanupReconcileFailedObjectsPvc>,
    /// Behavior policy for failed Service, `Retain` by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<ClickHouseKeeperInstallationReconcilingCleanupReconcileFailedObjectsService>,
    /// Behavior policy for failed StatefulSet, `Retain` by default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulSet")]
    pub stateful_set: Option<ClickHouseKeeperInstallationReconcilingCleanupReconcileFailedObjectsStatefulSet>,
}

/// Describes what clickhouse-operator should do with Kubernetes resources which are failed during reconcile.
/// Default behavior is `Retain`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationReconcilingCleanupReconcileFailedObjectsConfigMap {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Describes what clickhouse-operator should do with Kubernetes resources which are failed during reconcile.
/// Default behavior is `Retain`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationReconcilingCleanupReconcileFailedObjectsPvc {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Describes what clickhouse-operator should do with Kubernetes resources which are failed during reconcile.
/// Default behavior is `Retain`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationReconcilingCleanupReconcileFailedObjectsService {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Describes what clickhouse-operator should do with Kubernetes resources which are failed during reconcile.
/// Default behavior is `Retain`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationReconcilingCleanupReconcileFailedObjectsStatefulSet {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Describes what clickhouse-operator should do with found Kubernetes resources which should be managed by clickhouse-operator,
/// but do not have `ownerReference` to any currently managed `ClickHouseInstallation` resource.
/// Default behavior is `Delete`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationReconcilingCleanupUnknownObjects {
    /// Behavior policy for unknown ConfigMap, `Delete` by default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ClickHouseKeeperInstallationReconcilingCleanupUnknownObjectsConfigMap>,
    /// Behavior policy for unknown PVC, `Delete` by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pvc: Option<ClickHouseKeeperInstallationReconcilingCleanupUnknownObjectsPvc>,
    /// Behavior policy for unknown Service, `Delete` by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<ClickHouseKeeperInstallationReconcilingCleanupUnknownObjectsService>,
    /// Behavior policy for unknown StatefulSet, `Delete` by default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulSet")]
    pub stateful_set: Option<ClickHouseKeeperInstallationReconcilingCleanupUnknownObjectsStatefulSet>,
}

/// Describes what clickhouse-operator should do with found Kubernetes resources which should be managed by clickhouse-operator,
/// but do not have `ownerReference` to any currently managed `ClickHouseInstallation` resource.
/// Default behavior is `Delete`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationReconcilingCleanupUnknownObjectsConfigMap {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Describes what clickhouse-operator should do with found Kubernetes resources which should be managed by clickhouse-operator,
/// but do not have `ownerReference` to any currently managed `ClickHouseInstallation` resource.
/// Default behavior is `Delete`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationReconcilingCleanupUnknownObjectsPvc {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Describes what clickhouse-operator should do with found Kubernetes resources which should be managed by clickhouse-operator,
/// but do not have `ownerReference` to any currently managed `ClickHouseInstallation` resource.
/// Default behavior is `Delete`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationReconcilingCleanupUnknownObjectsService {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Describes what clickhouse-operator should do with found Kubernetes resources which should be managed by clickhouse-operator,
/// but do not have `ownerReference` to any currently managed `ClickHouseInstallation` resource.
/// Default behavior is `Delete`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationReconcilingCleanupUnknownObjectsStatefulSet {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Optional, allows tuning reconciling cycle for ClickhouseInstallation from clickhouse-operator side
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationReconcilingPolicy {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "wait")]
    Wait,
    #[serde(rename = "nowait")]
    Nowait,
}

/// Specification of the desired behavior of one or more ClickHouse clusters
/// More info: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md>
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationStop {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// Specification of the desired behavior of one or more ClickHouse clusters
/// More info: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md>
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationSuspend {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// allows define templates which will use for render Kubernetes resources like StatefulSet, ConfigMap, Service, PVC, by default, clickhouse-operator have own templates, but you can override it
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationTemplates {
    /// hostTemplate will use during apply to generate `clickhose-server` config files
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostTemplates")]
    pub host_templates: Option<Vec<ClickHouseKeeperInstallationTemplatesHostTemplates>>,
    /// podTemplate will use during render `Pod` inside `StatefulSet.spec` and allows define rendered `Pod.spec`, pod scheduling distribution and pod zone
    /// More information: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md#spectemplatespodtemplates>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplates")]
    pub pod_templates: Option<Vec<ClickHouseKeeperInstallationTemplatesPodTemplates>>,
    /// allows define template for rendering `Service` which would get endpoint from Pods which scoped chi-wide, cluster-wide, shard-wide, replica-wide level
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplates")]
    pub service_templates: Option<Vec<ClickHouseKeeperInstallationTemplatesServiceTemplates>>,
    /// allows define template for rendering `PVC` kubernetes resource, which would use inside `Pod` for mount clickhouse `data`, clickhouse `logs` or something else
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplates")]
    pub volume_claim_templates: Option<Vec<ClickHouseKeeperInstallationTemplatesVolumeClaimTemplates>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationTemplatesHostTemplates {
    /// template name, could use to link inside top-level `chi.spec.defaults.templates.hostTemplate`, cluster-level `chi.spec.configuration.clusters.templates.hostTemplate`, shard-level `chi.spec.configuration.clusters.layout.shards.temlates.hostTemplate`, replica-level `chi.spec.configuration.clusters.layout.replicas.templates.hostTemplate`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// define how will distribute numeric values of named ports in `Pod.spec.containers.ports` and clickhouse-server configs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portDistribution")]
    pub port_distribution: Option<Vec<ClickHouseKeeperInstallationTemplatesHostTemplatesPortDistribution>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<ClickHouseKeeperInstallationTemplatesHostTemplatesSpec>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationTemplatesHostTemplatesPortDistribution {
    /// type of distribution, when `Unspecified` (default value) then all listen ports on clickhouse-server configuration in all Pods will have the same value, when `ClusterScopeIndex` then ports will increment to offset from base value depends on shard and replica index inside cluster with combination of `chi.spec.templates.podTemlates.spec.HostNetwork` it allows setup ClickHouse cluster inside Kubernetes and provide access via external network bypass Kubernetes internal network
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<ClickHouseKeeperInstallationTemplatesHostTemplatesPortDistributionType>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationTemplatesHostTemplatesPortDistributionType {
    #[serde(rename = "")]
    KopiumEmpty,
    Unspecified,
    ClusterScopeIndex,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationTemplatesHostTemplatesSpec {
    /// optional, allows define content of any setting file inside each `Pod` where this template will apply during generate `ConfigMap` which will mount in `/etc/clickhouse-server/config.d/` or `/etc/clickhouse-server/conf.d/` or `/etc/clickhouse-server/users.d/`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<BTreeMap<String, serde_json::Value>>,
    /// by default, hostname will generate, but this allows define custom name for each `clickhuse-server`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "raftPort")]
    pub raft_port: Option<i64>,
    /// optional, allows configure `clickhouse-server` settings inside <yandex>...</yandex> tag in each `Pod` where this template will apply during generate `ConfigMap` which will mount in `/etc/clickhouse-server/conf.d/`
    /// More details: <https://clickhouse.tech/docs/en/operations/settings/settings/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<BTreeMap<String, serde_json::Value>>,
    /// be careful, this part of CRD allows override template inside template, don't use it if you don't understand what you do
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub templates: Option<ClickHouseKeeperInstallationTemplatesHostTemplatesSpecTemplates>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "zkPort")]
    pub zk_port: Option<i64>,
}

/// be careful, this part of CRD allows override template inside template, don't use it if you don't understand what you do
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationTemplatesHostTemplatesSpecTemplates {
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterServiceTemplate")]
    pub cluster_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataVolumeClaimTemplate")]
    pub data_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.hostTemplates, which will apply to configure every `clickhouse-server` instance during render ConfigMap resources which will mount into `Pod`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostTemplate")]
    pub host_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse log directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logVolumeClaimTemplate")]
    pub log_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.podTemplates, allows customization each `Pod` resource during render and reconcile each StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each replica inside each shard inside each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceTemplate")]
    pub replica_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates. used for customization of the `Service` resource, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplate")]
    pub service_template: Option<String>,
    /// optional, template names from chi.spec.templates.serviceTemplates. used for customization of the `Service` resources, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplates")]
    pub service_templates: Option<Vec<String>>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each shard inside clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardServiceTemplate")]
    pub shard_service_template: Option<String>,
    /// optional, alias for dataVolumeClaimTemplate, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationTemplatesPodTemplates {
    /// DEPRECATED, shortcut for `chi.spec.templates.podTemplates.spec.affinity.podAntiAffinity`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribution: Option<ClickHouseKeeperInstallationTemplatesPodTemplatesDistribution>,
    /// allows define format for generated `Pod` name, look to <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md#spectemplatesservicetemplates> for details about available template variables
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generateName")]
    pub generate_name: Option<String>,
    /// allows pass standard object's metadata from template to Pod
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, serde_json::Value>>,
    /// template name, could use to link inside top-level `chi.spec.defaults.templates.podTemplate`, cluster-level `chi.spec.configuration.clusters.templates.podTemplate`, shard-level `chi.spec.configuration.clusters.layout.shards.temlates.podTemplate`, replica-level `chi.spec.configuration.clusters.layout.replicas.templates.podTemplate`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// define ClickHouse Pod distribution policy between Kubernetes Nodes inside Shard, Replica, Namespace, CHI, another ClickHouse cluster
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podDistribution")]
    pub pod_distribution: Option<Vec<ClickHouseKeeperInstallationTemplatesPodTemplatesPodDistribution>>,
    /// allows define whole Pod.spec inside StaefulSet.spec, look to <https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates> for details
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<BTreeMap<String, serde_json::Value>>,
    /// allows define custom zone name and will separate ClickHouse `Pods` between nodes, shortcut for `chi.spec.templates.podTemplates.spec.affinity.podAntiAffinity`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zone: Option<ClickHouseKeeperInstallationTemplatesPodTemplatesZone>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationTemplatesPodTemplatesDistribution {
    #[serde(rename = "")]
    KopiumEmpty,
    Unspecified,
    OnePerHost,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationTemplatesPodTemplatesPodDistribution {
    /// define, how much ClickHouse Pods could be inside selected scope with selected distribution type
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number: Option<i64>,
    /// scope for apply each podDistribution
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<ClickHouseKeeperInstallationTemplatesPodTemplatesPodDistributionScope>,
    /// use for inter-pod affinity look to `pod.spec.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution.podAffinityTerm.topologyKey`,
    /// more info: <https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity">
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topologyKey")]
    pub topology_key: Option<String>,
    /// you can define multiple affinity policy types
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<ClickHouseKeeperInstallationTemplatesPodTemplatesPodDistributionType>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationTemplatesPodTemplatesPodDistributionScope {
    #[serde(rename = "")]
    KopiumEmpty,
    Unspecified,
    Shard,
    Replica,
    Cluster,
    ClickHouseInstallation,
    Namespace,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationTemplatesPodTemplatesPodDistributionType {
    #[serde(rename = "")]
    KopiumEmpty,
    Unspecified,
    ClickHouseAntiAffinity,
    ShardAntiAffinity,
    ReplicaAntiAffinity,
    AnotherNamespaceAntiAffinity,
    AnotherClickHouseInstallationAntiAffinity,
    AnotherClusterAntiAffinity,
    MaxNumberPerNode,
    NamespaceAffinity,
    ClickHouseInstallationAffinity,
    ClusterAffinity,
    ShardAffinity,
    ReplicaAffinity,
    PreviousTailAffinity,
    CircularReplication,
}

/// allows define custom zone name and will separate ClickHouse `Pods` between nodes, shortcut for `chi.spec.templates.podTemplates.spec.affinity.podAntiAffinity`
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationTemplatesPodTemplatesZone {
    /// optional, if defined, allows select kubernetes nodes by label with `name` equal `key`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// optional, if defined, allows select kubernetes nodes by label with `value` in `values`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationTemplatesServiceTemplates {
    /// allows define format for generated `Service` name,
    /// look to <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md#spectemplatesservicetemplates>
    /// for details about available template variables"
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generateName")]
    pub generate_name: Option<String>,
    /// allows pass standard object's metadata from template to Service
    /// Could be use for define specificly for Cloud Provider metadata which impact to behavior of service
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, serde_json::Value>>,
    /// template name, could use to link inside
    /// chi-level `chi.spec.defaults.templates.serviceTemplate`
    /// cluster-level `chi.spec.configuration.clusters.templates.clusterServiceTemplate`
    /// shard-level `chi.spec.configuration.clusters.layout.shards.temlates.shardServiceTemplate`
    /// replica-level `chi.spec.configuration.clusters.layout.replicas.templates.replicaServiceTemplate` or `chi.spec.configuration.clusters.layout.shards.replicas.replicaServiceTemplate`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// describe behavior of generated Service
    /// More info: <https://kubernetes.io/docs/concepts/services-networking/service/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<BTreeMap<String, serde_json::Value>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationTemplatesVolumeClaimTemplates {
    /// allows to pass standard object's metadata from template to PVC
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, serde_json::Value>>,
    /// template name, could use to link inside
    /// top-level `chi.spec.defaults.templates.dataVolumeClaimTemplate` or `chi.spec.defaults.templates.logVolumeClaimTemplate`,
    /// cluster-level `chi.spec.configuration.clusters.templates.dataVolumeClaimTemplate` or `chi.spec.configuration.clusters.templates.logVolumeClaimTemplate`,
    /// shard-level `chi.spec.configuration.clusters.layout.shards.temlates.dataVolumeClaimTemplate` or `chi.spec.configuration.clusters.layout.shards.temlates.logVolumeClaimTemplate`
    /// replica-level `chi.spec.configuration.clusters.layout.replicas.templates.dataVolumeClaimTemplate` or `chi.spec.configuration.clusters.layout.replicas.templates.logVolumeClaimTemplate`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// defines `PVC` provisioner - be it StatefulSet or the Operator
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provisioner: Option<ClickHouseKeeperInstallationTemplatesVolumeClaimTemplatesProvisioner>,
    /// defines behavior of `PVC` deletion.
    /// `Delete` by default, if `Retain` specified then `PVC` will be kept when deleting StatefulSet
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reclaimPolicy")]
    pub reclaim_policy: Option<ClickHouseKeeperInstallationTemplatesVolumeClaimTemplatesReclaimPolicy>,
    /// allows define all aspects of `PVC` resource
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<BTreeMap<String, serde_json::Value>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationTemplatesVolumeClaimTemplatesProvisioner {
    #[serde(rename = "")]
    KopiumEmpty,
    StatefulSet,
    Operator,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseKeeperInstallationTemplatesVolumeClaimTemplatesReclaimPolicy {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Status contains many fields like a normalized configuration, clickhouse-operator version, current action and all applied action list, current taskID and all applied taskIDs and other
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseKeeperInstallationStatus {
    /// Action
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// Actions
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<Vec<String>>,
    /// Operator git commit SHA
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chop-commit")]
    pub chop_commit: Option<String>,
    /// Operator build date
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chop-date")]
    pub chop_date: Option<String>,
    /// IP address of the operator's pod which managed this resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chop-ip")]
    pub chop_ip: Option<String>,
    /// Operator version
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chop-version")]
    pub chop_version: Option<String>,
    /// Clusters count
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clusters: Option<i64>,
    /// Endpoint
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// All endpoints
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoints: Option<Vec<String>>,
    /// Last error
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    /// Errors
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub errors: Option<Vec<String>>,
    /// Pods FQDNs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdns: Option<Vec<String>>,
    /// Generation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub generation: Option<i64>,
    /// Hosts count
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<i64>,
    /// Added Hosts count
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostsAdded")]
    pub hosts_added: Option<i64>,
    /// Completed Hosts count
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostsCompleted")]
    pub hosts_completed: Option<i64>,
    /// About to delete Hosts count
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostsDelete")]
    pub hosts_delete: Option<i64>,
    /// Deleted Hosts count
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostsDeleted")]
    pub hosts_deleted: Option<i64>,
    /// Unchanged Hosts count
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostsUnchanged")]
    pub hosts_unchanged: Option<i64>,
    /// Updated Hosts count
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostsUpdated")]
    pub hosts_updated: Option<i64>,
    /// List of hosts with replica caught up
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostsWithReplicaCaughtUp")]
    pub hosts_with_replica_caught_up: Option<Vec<String>>,
    /// List of hosts with tables created by the operator
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostsWithTablesCreated")]
    pub hosts_with_tables_created: Option<Vec<String>>,
    /// Normalized resource requested
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub normalized: Option<BTreeMap<String, serde_json::Value>>,
    /// Normalized resource completed
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "normalizedCompleted")]
    pub normalized_completed: Option<BTreeMap<String, serde_json::Value>>,
    /// Pod IPs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pod-ips")]
    pub pod_ips: Option<Vec<String>>,
    /// Pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pods: Option<Vec<String>>,
    /// Replicas count
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i64>,
    /// Shards count
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shards: Option<i64>,
    /// Status
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// Current task id
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskID")]
    pub task_id: Option<String>,
    /// Completed task ids
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskIDsCompleted")]
    pub task_i_ds_completed: Option<Vec<String>>,
    /// Started task ids
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskIDsStarted")]
    pub task_i_ds_started: Option<Vec<String>>,
    /// List of templates used to build this CHI
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usedTemplates")]
    pub used_templates: Option<Vec<BTreeMap<String, serde_json::Value>>>,
}

