// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/openshift/hive/hive.openshift.io/v1/clusterdeployments.yaml
// kopium version: 0.22.3

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ClusterDeploymentSpec defines the desired state of ClusterDeployment
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "hive.openshift.io", version = "v1", kind = "ClusterDeployment", plural = "clusterdeployments")]
#[kube(namespaced)]
#[kube(status = "ClusterDeploymentStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ClusterDeploymentSpec {
    /// BaseDomain is the base domain to which the cluster should belong.
    #[serde(rename = "baseDomain")]
    pub base_domain: String,
    /// BoundServiceAccountSigningKeySecretRef refers to a Secret that contains a
    /// 'bound-service-account-signing-key.key' data key pointing to the private
    /// key that will be used to sign ServiceAccount objects. Primarily used to
    /// provision AWS clusters to use Amazon's Security Token Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "boundServiceAccountSigningKeySecretRef")]
    pub bound_service_account_signing_key_secret_ref: Option<ClusterDeploymentBoundServiceAccountSigningKeySecretRef>,
    /// CertificateBundles is a list of certificate bundles associated with this cluster
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateBundles")]
    pub certificate_bundles: Option<Vec<ClusterDeploymentCertificateBundles>>,
    /// ClusterInstallLocalReference provides reference to an object that implements
    /// the hivecontract ClusterInstall. The namespace of the object is same as the
    /// ClusterDeployment.
    /// This cannot be set when Provisioning is also set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterInstallRef")]
    pub cluster_install_ref: Option<ClusterDeploymentClusterInstallRef>,
    /// ClusterMetadata contains metadata information about the installed cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterMetadata")]
    pub cluster_metadata: Option<ClusterDeploymentClusterMetadata>,
    /// ClusterName is the friendly name of the cluster. It is used for subdomains,
    /// some resource tagging, and other instances where a friendly name for the
    /// cluster is useful.
    #[serde(rename = "clusterName")]
    pub cluster_name: String,
    /// ClusterPoolRef is a reference to the ClusterPool that this ClusterDeployment originated from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterPoolRef")]
    pub cluster_pool_ref: Option<ClusterDeploymentClusterPoolRef>,
    /// ControlPlaneConfig contains additional configuration for the target cluster's control plane
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controlPlaneConfig")]
    pub control_plane_config: Option<ClusterDeploymentControlPlaneConfig>,
    /// HibernateAfter will transition a cluster to hibernating power state after it has been running for the
    /// given duration. The time that a cluster has been running is the time since the cluster was installed or the
    /// time since the cluster last came out of hibernation.
    /// This is a Duration value; see <https://pkg.go.dev/time#ParseDuration> for accepted formats.
    /// Note: due to discrepancies in validation vs parsing, we use a Pattern instead of `Format=duration`. See
    /// <https://bugzilla.redhat.com/show_bug.cgi?id=2050332>
    /// <https://github.com/kubernetes/apimachinery/issues/131>
    /// <https://github.com/kubernetes/apiextensions-apiserver/issues/56>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hibernateAfter")]
    pub hibernate_after: Option<String>,
    /// Ingress allows defining desired clusteringress/shards to be configured on the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<Vec<ClusterDeploymentIngress>>,
    /// InstallAttemptsLimit is the maximum number of times Hive will attempt to install the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "installAttemptsLimit")]
    pub install_attempts_limit: Option<i32>,
    /// Installed is true if the cluster has been installed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installed: Option<bool>,
    /// ManageDNS specifies whether a DNSZone should be created and managed automatically
    /// for this ClusterDeployment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "manageDNS")]
    pub manage_dns: Option<bool>,
    /// Platform is the configuration for the specific platform upon which to
    /// perform the installation.
    pub platform: ClusterDeploymentPlatform,
    /// PowerState indicates whether a cluster should be running or hibernating. When omitted,
    /// PowerState defaults to the Running state.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "powerState")]
    pub power_state: Option<ClusterDeploymentPowerState>,
    /// PreserveOnDelete allows the user to disconnect a cluster from Hive without deprovisioning it. This can also be
    /// used to abandon ongoing cluster deprovision.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preserveOnDelete")]
    pub preserve_on_delete: Option<bool>,
    /// Provisioning contains settings used only for initial cluster provisioning.
    /// May be unset in the case of adopted clusters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provisioning: Option<ClusterDeploymentProvisioning>,
    /// PullSecretRef is the reference to the secret to use when pulling images.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullSecretRef")]
    pub pull_secret_ref: Option<ClusterDeploymentPullSecretRef>,
}

/// BoundServiceAccountSigningKeySecretRef refers to a Secret that contains a
/// 'bound-service-account-signing-key.key' data key pointing to the private
/// key that will be used to sign ServiceAccount objects. Primarily used to
/// provision AWS clusters to use Amazon's Security Token Service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentBoundServiceAccountSigningKeySecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// CertificateBundleSpec specifies a certificate bundle associated with a cluster deployment
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentCertificateBundles {
    /// CertificateSecretRef is the reference to the secret that contains the certificate bundle. If
    /// the certificate bundle is to be generated, it will be generated with the name in this
    /// reference. Otherwise, it is expected that the secret should exist in the same namespace
    /// as the ClusterDeployment
    #[serde(rename = "certificateSecretRef")]
    pub certificate_secret_ref: ClusterDeploymentCertificateBundlesCertificateSecretRef,
    /// Generate indicates whether this bundle should have real certificates generated for it.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub generate: Option<bool>,
    /// Name is an identifier that must be unique within the bundle and must be referenced by
    /// an ingress or by the control plane serving certs
    pub name: String,
}

/// CertificateSecretRef is the reference to the secret that contains the certificate bundle. If
/// the certificate bundle is to be generated, it will be generated with the name in this
/// reference. Otherwise, it is expected that the secret should exist in the same namespace
/// as the ClusterDeployment
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentCertificateBundlesCertificateSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// ClusterInstallLocalReference provides reference to an object that implements
/// the hivecontract ClusterInstall. The namespace of the object is same as the
/// ClusterDeployment.
/// This cannot be set when Provisioning is also set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentClusterInstallRef {
    pub group: String,
    pub kind: String,
    pub name: String,
    pub version: String,
}

/// ClusterMetadata contains metadata information about the installed cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentClusterMetadata {
    /// AdminKubeconfigSecretRef references the secret containing the admin kubeconfig for this cluster.
    #[serde(rename = "adminKubeconfigSecretRef")]
    pub admin_kubeconfig_secret_ref: ClusterDeploymentClusterMetadataAdminKubeconfigSecretRef,
    /// AdminPasswordSecretRef references the secret containing the admin username/password which can be used to login to this cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminPasswordSecretRef")]
    pub admin_password_secret_ref: Option<ClusterDeploymentClusterMetadataAdminPasswordSecretRef>,
    /// ClusterID is a globally unique identifier for this cluster generated during installation. Used for reporting metrics among other places.
    #[serde(rename = "clusterID")]
    pub cluster_id: String,
    /// InfraID is an identifier for this cluster generated during installation and used for tagging/naming resources in cloud providers.
    #[serde(rename = "infraID")]
    pub infra_id: String,
    /// Platform holds platform-specific cluster metadata
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub platform: Option<ClusterDeploymentClusterMetadataPlatform>,
}

/// AdminKubeconfigSecretRef references the secret containing the admin kubeconfig for this cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentClusterMetadataAdminKubeconfigSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// AdminPasswordSecretRef references the secret containing the admin username/password which can be used to login to this cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentClusterMetadataAdminPasswordSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Platform holds platform-specific cluster metadata
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentClusterMetadataPlatform {
    /// AWS holds AWS-specific cluster metadata
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<ClusterDeploymentClusterMetadataPlatformAws>,
    /// Azure holds azure-specific cluster metadata
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub azure: Option<ClusterDeploymentClusterMetadataPlatformAzure>,
    /// GCP holds GCP-specific cluster metadata
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gcp: Option<ClusterDeploymentClusterMetadataPlatformGcp>,
}

/// AWS holds AWS-specific cluster metadata
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentClusterMetadataPlatformAws {
    /// HostedZoneRole is the role to assume when performing operations
    /// on a hosted zone owned by another account.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostedZoneRole")]
    pub hosted_zone_role: Option<String>,
}

/// Azure holds azure-specific cluster metadata
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentClusterMetadataPlatformAzure {
    /// ResourceGroupName is the name of the resource group in which the cluster resources were created.
    #[serde(rename = "resourceGroupName")]
    pub resource_group_name: String,
}

/// GCP holds GCP-specific cluster metadata
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentClusterMetadataPlatformGcp {
    /// NetworkProjectID is used for shared VPC setups
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkProjectID")]
    pub network_project_id: Option<String>,
}

/// ClusterPoolRef is a reference to the ClusterPool that this ClusterDeployment originated from.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentClusterPoolRef {
    /// ClaimName is the name of the ClusterClaim that claimed the cluster from the pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "claimName")]
    pub claim_name: Option<String>,
    /// ClaimedTimestamp is the time this cluster was assigned to a ClusterClaim. This is only used for
    /// ClusterDeployments belonging to ClusterPools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "claimedTimestamp")]
    pub claimed_timestamp: Option<String>,
    /// CustomizationRef is the ClusterPool Inventory claimed customization for this ClusterDeployment.
    /// The Customization exists in the ClusterPool namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterDeploymentCustomization")]
    pub cluster_deployment_customization: Option<ClusterDeploymentClusterPoolRefClusterDeploymentCustomization>,
    /// Namespace is the namespace where the ClusterPool resides.
    pub namespace: String,
    /// PoolName is the name of the ClusterPool for which the cluster was created.
    #[serde(rename = "poolName")]
    pub pool_name: String,
}

/// CustomizationRef is the ClusterPool Inventory claimed customization for this ClusterDeployment.
/// The Customization exists in the ClusterPool namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentClusterPoolRefClusterDeploymentCustomization {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// ControlPlaneConfig contains additional configuration for the target cluster's control plane
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentControlPlaneConfig {
    /// APIServerIPOverride is the optional override of the API server IP address.
    /// Hive will use this IP address for creating TCP connections.
    /// Port from the original API server URL will be used.
    /// This field can be used when repointing the APIServer's DNS is not viable option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiServerIPOverride")]
    pub api_server_ip_override: Option<String>,
    /// APIURLOverride is the optional URL override to which Hive will transition for communication with the API
    /// server of the remote cluster. When a remote cluster is created, Hive will initially communicate using the
    /// API URL established during installation. If an API URL Override is specified, Hive will periodically attempt
    /// to connect to the remote cluster using the override URL. Once Hive has determined that the override URL is
    /// active, Hive will use the override URL for further communications with the API server of the remote cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiURLOverride")]
    pub api_url_override: Option<String>,
    /// ServingCertificates specifies serving certificates for the control plane
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "servingCertificates")]
    pub serving_certificates: Option<ClusterDeploymentControlPlaneConfigServingCertificates>,
}

/// ServingCertificates specifies serving certificates for the control plane
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentControlPlaneConfigServingCertificates {
    /// Additional is a list of additional domains and certificates that are also associated with
    /// the control plane's api endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub additional: Option<Vec<ClusterDeploymentControlPlaneConfigServingCertificatesAdditional>>,
    /// Default references the name of a CertificateBundle in the ClusterDeployment that should be
    /// used for the control plane's default endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<String>,
}

/// ControlPlaneAdditionalCertificate defines an additional serving certificate for a control plane
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentControlPlaneConfigServingCertificatesAdditional {
    /// Domain is the domain of the additional control plane certificate
    pub domain: String,
    /// Name references a CertificateBundle in the ClusterDeployment.Spec that should be
    /// used for this additional certificate.
    pub name: String,
}

/// ClusterIngress contains the configurable pieces for any ClusterIngress objects
/// that should exist on the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentIngress {
    /// Domain (sometimes referred to as shard) is the full DNS suffix that the resulting
    /// IngressController object will service (eg abcd.mycluster.mydomain.com).
    pub domain: String,
    /// HttpErrorCodePages allows configuring custom HTTP error pages using the IngressController object
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpErrorCodePages")]
    pub http_error_code_pages: Option<ClusterDeploymentIngressHttpErrorCodePages>,
    /// Name of the ClusterIngress object to create.
    pub name: String,
    /// NamespaceSelector allows filtering the list of namespaces serviced by the
    /// ingress controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<ClusterDeploymentIngressNamespaceSelector>,
    /// RouteSelector allows filtering the set of Routes serviced by the ingress controller
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelector")]
    pub route_selector: Option<ClusterDeploymentIngressRouteSelector>,
    /// ServingCertificate references a CertificateBundle in the ClusterDeployment.Spec that
    /// should be used for this Ingress
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "servingCertificate")]
    pub serving_certificate: Option<String>,
}

/// HttpErrorCodePages allows configuring custom HTTP error pages using the IngressController object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentIngressHttpErrorCodePages {
    /// name is the metadata.name of the referenced config map
    pub name: String,
}

/// NamespaceSelector allows filtering the list of namespaces serviced by the
/// ingress controller.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentIngressNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterDeploymentIngressNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentIngressNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// RouteSelector allows filtering the set of Routes serviced by the ingress controller
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentIngressRouteSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterDeploymentIngressRouteSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentIngressRouteSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Platform is the configuration for the specific platform upon which to
/// perform the installation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatform {
    /// AgentBareMetal is the configuration used when performing an Assisted Agent based installation
    /// to bare metal.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agentBareMetal")]
    pub agent_bare_metal: Option<ClusterDeploymentPlatformAgentBareMetal>,
    /// AWS is the configuration used when installing on AWS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<ClusterDeploymentPlatformAws>,
    /// Azure is the configuration used when installing on Azure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub azure: Option<ClusterDeploymentPlatformAzure>,
    /// BareMetal is the configuration used when installing on bare metal.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub baremetal: Option<ClusterDeploymentPlatformBaremetal>,
    /// GCP is the configuration used when installing on Google Cloud Platform.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gcp: Option<ClusterDeploymentPlatformGcp>,
    /// IBMCloud is the configuration used when installing on IBM Cloud
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ibmcloud: Option<ClusterDeploymentPlatformIbmcloud>,
    /// None indicates platform-agnostic install.
    /// <https://docs.openshift.com/container-platform/4.7/installing/installing_platform_agnostic/installing-platform-agnostic.html>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub none: Option<ClusterDeploymentPlatformNone>,
    /// Nutanix is the configuration used when installing on Nutanix Prism Central.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nutanix: Option<ClusterDeploymentPlatformNutanix>,
    /// OpenStack is the configuration used when installing on OpenStack
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub openstack: Option<ClusterDeploymentPlatformOpenstack>,
    /// VSphere is the configuration used when installing on vSphere
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vsphere: Option<ClusterDeploymentPlatformVsphere>,
}

/// AgentBareMetal is the configuration used when performing an Assisted Agent based installation
/// to bare metal.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformAgentBareMetal {
    /// AgentSelector is a label selector used for associating relevant custom resources with this cluster.
    /// (Agent, BareMetalHost, etc)
    #[serde(rename = "agentSelector")]
    pub agent_selector: ClusterDeploymentPlatformAgentBareMetalAgentSelector,
}

/// AgentSelector is a label selector used for associating relevant custom resources with this cluster.
/// (Agent, BareMetalHost, etc)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformAgentBareMetalAgentSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterDeploymentPlatformAgentBareMetalAgentSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformAgentBareMetalAgentSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// AWS is the configuration used when installing on AWS.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformAws {
    /// CredentialsAssumeRole refers to the IAM role that must be assumed to obtain
    /// AWS account access for the cluster operations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsAssumeRole")]
    pub credentials_assume_role: Option<ClusterDeploymentPlatformAwsCredentialsAssumeRole>,
    /// CredentialsSecretRef refers to a secret that contains the AWS account access
    /// credentials.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsSecretRef")]
    pub credentials_secret_ref: Option<ClusterDeploymentPlatformAwsCredentialsSecretRef>,
    /// PrivateLink allows uses to enable access to the cluster's API server using AWS
    /// PrivateLink. AWS PrivateLink includes a pair of VPC Endpoint Service and VPC
    /// Endpoint accross AWS accounts and allows clients to connect to services using AWS's
    /// internal networking instead of the Internet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateLink")]
    pub private_link: Option<ClusterDeploymentPlatformAwsPrivateLink>,
    /// Region specifies the AWS region where the cluster will be created.
    pub region: String,
    /// UserTags specifies additional tags for AWS resources created for the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userTags")]
    pub user_tags: Option<BTreeMap<String, String>>,
}

/// CredentialsAssumeRole refers to the IAM role that must be assumed to obtain
/// AWS account access for the cluster operations.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformAwsCredentialsAssumeRole {
    /// ExternalID is random string generated by platform so that assume role
    /// is protected from confused deputy problem.
    /// more info: <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalID")]
    pub external_id: Option<String>,
    #[serde(rename = "roleARN")]
    pub role_arn: String,
}

/// CredentialsSecretRef refers to a secret that contains the AWS account access
/// credentials.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformAwsCredentialsSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// PrivateLink allows uses to enable access to the cluster's API server using AWS
/// PrivateLink. AWS PrivateLink includes a pair of VPC Endpoint Service and VPC
/// Endpoint accross AWS accounts and allows clients to connect to services using AWS's
/// internal networking instead of the Internet.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformAwsPrivateLink {
    /// AdditionalAllowedPrincipals is a list of additional allowed principal ARNs to be configured
    /// for the Private Link cluster's VPC Endpoint Service.
    /// ARNs provided as AdditionalAllowedPrincipals will be configured for the cluster's VPC Endpoint
    /// Service in addition to the IAM entity used by Hive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalAllowedPrincipals")]
    pub additional_allowed_principals: Option<Vec<String>>,
    pub enabled: bool,
}

/// Azure is the configuration used when installing on Azure.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformAzure {
    /// BaseDomainResourceGroupName specifies the resource group where the azure DNS zone for the base domain is found
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseDomainResourceGroupName")]
    pub base_domain_resource_group_name: Option<String>,
    /// cloudName is the name of the Azure cloud environment which can be used to configure the Azure SDK
    /// with the appropriate Azure API endpoints.
    /// If empty, the value is equal to "AzurePublicCloud".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudName")]
    pub cloud_name: Option<ClusterDeploymentPlatformAzureCloudName>,
    /// CredentialsSecretRef refers to a secret that contains the Azure account access
    /// credentials.
    #[serde(rename = "credentialsSecretRef")]
    pub credentials_secret_ref: ClusterDeploymentPlatformAzureCredentialsSecretRef,
    /// Region specifies the Azure region where the cluster will be created.
    pub region: String,
}

/// Azure is the configuration used when installing on Azure.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterDeploymentPlatformAzureCloudName {
    #[serde(rename = "")]
    KopiumEmpty,
    AzurePublicCloud,
    #[serde(rename = "AzureUSGovernmentCloud")]
    AzureUsGovernmentCloud,
    AzureChinaCloud,
    AzureGermanCloud,
}

/// CredentialsSecretRef refers to a secret that contains the Azure account access
/// credentials.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformAzureCredentialsSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// BareMetal is the configuration used when installing on bare metal.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformBaremetal {
    /// LibvirtSSHPrivateKeySecretRef is the reference to the secret that contains the private SSH key to use
    /// for access to the libvirt provisioning host.
    /// The SSH private key is expected to be in the secret data under the "ssh-privatekey" key.
    #[serde(rename = "libvirtSSHPrivateKeySecretRef")]
    pub libvirt_ssh_private_key_secret_ref: ClusterDeploymentPlatformBaremetalLibvirtSshPrivateKeySecretRef,
}

/// LibvirtSSHPrivateKeySecretRef is the reference to the secret that contains the private SSH key to use
/// for access to the libvirt provisioning host.
/// The SSH private key is expected to be in the secret data under the "ssh-privatekey" key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformBaremetalLibvirtSshPrivateKeySecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// GCP is the configuration used when installing on Google Cloud Platform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformGcp {
    /// CredentialsSecretRef refers to a secret that contains the GCP account access credentials.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsSecretRef")]
    pub credentials_secret_ref: Option<ClusterDeploymentPlatformGcpCredentialsSecretRef>,
    /// DiscardLocalSsdOnHibernate passes the specified value through to the GCP API to indicate
    /// whether the content of any local SSDs should be preserved or discarded. See
    /// <https://cloud.google.com/compute/docs/disks/local-ssd#stop_instance>
    /// This field is required when attempting to hibernate clusters with instances possessing
    /// SSDs -- e.g. those with GPUs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discardLocalSsdOnHibernate")]
    pub discard_local_ssd_on_hibernate: Option<bool>,
    /// PrivateSericeConnect allows users to enable access to the cluster's API server using GCP
    /// Private Service Connect. It includes a forwarding rule paired with a Service Attachment
    /// across GCP accounts and allows clients to connect to services using GCP internal networking
    /// of using public load balancers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateServiceConnect")]
    pub private_service_connect: Option<ClusterDeploymentPlatformGcpPrivateServiceConnect>,
    /// Region specifies the GCP region where the cluster will be created.
    pub region: String,
}

/// CredentialsSecretRef refers to a secret that contains the GCP account access credentials.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformGcpCredentialsSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// PrivateSericeConnect allows users to enable access to the cluster's API server using GCP
/// Private Service Connect. It includes a forwarding rule paired with a Service Attachment
/// across GCP accounts and allows clients to connect to services using GCP internal networking
/// of using public load balancers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformGcpPrivateServiceConnect {
    /// Enabled specifies if Private Service Connect is to be enabled on the cluster.
    pub enabled: bool,
    /// ServiceAttachment configures the service attachment to be used by the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAttachment")]
    pub service_attachment: Option<ClusterDeploymentPlatformGcpPrivateServiceConnectServiceAttachment>,
}

/// ServiceAttachment configures the service attachment to be used by the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformGcpPrivateServiceConnectServiceAttachment {
    /// Subnet configures the subnetwork that contains the service attachment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subnet: Option<ClusterDeploymentPlatformGcpPrivateServiceConnectServiceAttachmentSubnet>,
}

/// Subnet configures the subnetwork that contains the service attachment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformGcpPrivateServiceConnectServiceAttachmentSubnet {
    /// Cidr specifies the cidr to use when creating a service attachment subnet.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    /// Existing specifies a pre-existing subnet to use instead of creating a new service attachment subnet.
    /// This is required when using BYO VPCs. It must be in the same region as the api-int load balancer, be
    /// configured with a purpose of "Private Service Connect", and have sufficient routing and firewall rules
    /// to access the api-int load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub existing: Option<ClusterDeploymentPlatformGcpPrivateServiceConnectServiceAttachmentSubnetExisting>,
}

/// Existing specifies a pre-existing subnet to use instead of creating a new service attachment subnet.
/// This is required when using BYO VPCs. It must be in the same region as the api-int load balancer, be
/// configured with a purpose of "Private Service Connect", and have sufficient routing and firewall rules
/// to access the api-int load balancer.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformGcpPrivateServiceConnectServiceAttachmentSubnetExisting {
    /// Name specifies the name of the existing subnet.
    pub name: String,
    /// Project specifies the project the subnet exists in.
    /// This is required for Shared VPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
}

/// IBMCloud is the configuration used when installing on IBM Cloud
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformIbmcloud {
    /// AccountID is the IBM Cloud Account ID.
    /// AccountID is DEPRECATED and is gathered via the IBM Cloud API for the provided
    /// credentials. This field will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accountID")]
    pub account_id: Option<String>,
    /// CISInstanceCRN is the IBM Cloud Internet Services Instance CRN
    /// CISInstanceCRN is DEPRECATED and gathered via the IBM Cloud API for the provided
    /// credentials and cluster deployment base domain. This field will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cisInstanceCRN")]
    pub cis_instance_crn: Option<String>,
    /// CredentialsSecretRef refers to a secret that contains IBM Cloud account access
    /// credentials.
    #[serde(rename = "credentialsSecretRef")]
    pub credentials_secret_ref: ClusterDeploymentPlatformIbmcloudCredentialsSecretRef,
    /// Region specifies the IBM Cloud region where the cluster will be
    /// created.
    pub region: String,
}

/// CredentialsSecretRef refers to a secret that contains IBM Cloud account access
/// credentials.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformIbmcloudCredentialsSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// None indicates platform-agnostic install.
/// <https://docs.openshift.com/container-platform/4.7/installing/installing_platform_agnostic/installing-platform-agnostic.html>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformNone {
}

/// Nutanix is the configuration used when installing on Nutanix Prism Central.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformNutanix {
    /// CertificatesSecretRef refers to a secret that contains the Prism Central CA certificates
    /// necessary for communicating with the Prism Central.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificatesSecretRef")]
    pub certificates_secret_ref: Option<ClusterDeploymentPlatformNutanixCertificatesSecretRef>,
    /// CredentialsSecretRef refers to a secret that contains the Nutanix account access
    /// credentials.
    #[serde(rename = "credentialsSecretRef")]
    pub credentials_secret_ref: ClusterDeploymentPlatformNutanixCredentialsSecretRef,
    /// FailureDomains configures failure domains for the Nutanix platform.
    /// Required for using MachinePools
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureDomains")]
    pub failure_domains: Option<Vec<ClusterDeploymentPlatformNutanixFailureDomains>>,
    /// PrismCentral is the endpoint (address and port) to connect to the Prism Central.
    /// This serves as the default Prism-Central.
    #[serde(rename = "prismCentral")]
    pub prism_central: ClusterDeploymentPlatformNutanixPrismCentral,
}

/// CertificatesSecretRef refers to a secret that contains the Prism Central CA certificates
/// necessary for communicating with the Prism Central.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformNutanixCertificatesSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// CredentialsSecretRef refers to a secret that contains the Nutanix account access
/// credentials.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformNutanixCredentialsSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// FailureDomain configures failure domain information for the Nutanix platform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformNutanixFailureDomains {
    /// DataSourceImages identifies the datasource images in the Prism Element.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceImages")]
    pub data_source_images: Option<Vec<ClusterDeploymentPlatformNutanixFailureDomainsDataSourceImages>>,
    /// Name defines the unique name of a failure domain.
    pub name: String,
    /// PrismElement holds the identification (name, UUID) and the optional endpoint address and
    /// port of the Nutanix Prism Element. When a cluster-wide proxy is installed, this endpoint will,
    /// by default, be accessed through the cluster-wide proxy configured for the platform.
    /// If communication with this endpoint should bypass the proxy, add the endpoint to the install-config
    /// `spec.noProxy` list in the proxy configuration.
    #[serde(rename = "prismElement")]
    pub prism_element: ClusterDeploymentPlatformNutanixFailureDomainsPrismElement,
    /// StorageContainers identifies the storage containers in the Prism Element.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageContainers")]
    pub storage_containers: Option<Vec<ClusterDeploymentPlatformNutanixFailureDomainsStorageContainers>>,
    /// SubnetUUIDs identifies the network subnets of the Prism Element.
    /// Currently we only support one subnet for a failure domain.
    #[serde(rename = "subnetUUIDs")]
    pub subnet_uui_ds: Vec<String>,
}

/// StorageResourceReference holds reference information of a storage resource (storage container, data source image, etc.)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformNutanixFailureDomainsDataSourceImages {
    /// Name is the name of the storage container resource in the Prism Element.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// ReferenceName is the identifier of the storage resource configured in the FailureDomain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "referenceName")]
    pub reference_name: Option<String>,
    /// UUID is the UUID of the storage container resource in the Prism Element.
    pub uuid: String,
}

/// PrismElement holds the identification (name, UUID) and the optional endpoint address and
/// port of the Nutanix Prism Element. When a cluster-wide proxy is installed, this endpoint will,
/// by default, be accessed through the cluster-wide proxy configured for the platform.
/// If communication with this endpoint should bypass the proxy, add the endpoint to the install-config
/// `spec.noProxy` list in the proxy configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformNutanixFailureDomainsPrismElement {
    /// Endpoint holds the address and port of the Prism Element
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<ClusterDeploymentPlatformNutanixFailureDomainsPrismElementEndpoint>,
    /// Name is the Prism Element (cluster) name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// UUID is the UUID of the Prism Element (cluster)
    pub uuid: String,
}

/// Endpoint holds the address and port of the Prism Element
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformNutanixFailureDomainsPrismElementEndpoint {
    /// address is the endpoint address (DNS name or IP address) of the Nutanix Prism Central or Element (cluster)
    pub address: String,
    /// port is the port number to access the Nutanix Prism Central or Element (cluster)
    pub port: i32,
}

/// StorageResourceReference holds reference information of a storage resource (storage container, data source image, etc.)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformNutanixFailureDomainsStorageContainers {
    /// Name is the name of the storage container resource in the Prism Element.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// ReferenceName is the identifier of the storage resource configured in the FailureDomain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "referenceName")]
    pub reference_name: Option<String>,
    /// UUID is the UUID of the storage container resource in the Prism Element.
    pub uuid: String,
}

/// PrismCentral is the endpoint (address and port) to connect to the Prism Central.
/// This serves as the default Prism-Central.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformNutanixPrismCentral {
    /// address is the endpoint address (DNS name or IP address) of the Nutanix Prism Central or Element (cluster)
    pub address: String,
    /// port is the port number to access the Nutanix Prism Central or Element (cluster)
    pub port: i32,
}

/// OpenStack is the configuration used when installing on OpenStack
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformOpenstack {
    /// CertificatesSecretRef refers to a secret that contains CA certificates
    /// necessary for communicating with the OpenStack.
    /// There is additional configuration required for the OpenShift cluster to trust
    /// the certificates provided in this secret.
    /// The "clouds.yaml" file included in the credentialsSecretRef Secret must also include
    /// a reference to the certificate bundle file for the OpenShift cluster being created to
    /// trust the OpenStack endpoints.
    /// The "clouds.yaml" file must set the "cacert" field to
    /// either "/etc/openstack-ca/<key name containing the trust bundle in credentialsSecretRef Secret>" or
    /// "/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem".
    /// 
    /// For example,
    /// """clouds.yaml
    /// clouds:
    ///   shiftstack:
    ///     auth: ...
    ///     cacert: "/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem"
    /// """
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificatesSecretRef")]
    pub certificates_secret_ref: Option<ClusterDeploymentPlatformOpenstackCertificatesSecretRef>,
    /// Cloud will be used to indicate the OS_CLOUD value to use the right section
    /// from the clouds.yaml in the CredentialsSecretRef.
    pub cloud: String,
    /// CredentialsSecretRef refers to a secret that contains the OpenStack account access
    /// credentials.
    #[serde(rename = "credentialsSecretRef")]
    pub credentials_secret_ref: ClusterDeploymentPlatformOpenstackCredentialsSecretRef,
    /// TrunkSupport indicates whether or not to use trunk ports in your OpenShift cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trunkSupport")]
    pub trunk_support: Option<bool>,
}

/// CertificatesSecretRef refers to a secret that contains CA certificates
/// necessary for communicating with the OpenStack.
/// There is additional configuration required for the OpenShift cluster to trust
/// the certificates provided in this secret.
/// The "clouds.yaml" file included in the credentialsSecretRef Secret must also include
/// a reference to the certificate bundle file for the OpenShift cluster being created to
/// trust the OpenStack endpoints.
/// The "clouds.yaml" file must set the "cacert" field to
/// either "/etc/openstack-ca/<key name containing the trust bundle in credentialsSecretRef Secret>" or
/// "/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem".
/// 
/// For example,
/// """clouds.yaml
/// clouds:
///   shiftstack:
///     auth: ...
///     cacert: "/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem"
/// """
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformOpenstackCertificatesSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// CredentialsSecretRef refers to a secret that contains the OpenStack account access
/// credentials.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformOpenstackCredentialsSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// VSphere is the configuration used when installing on vSphere
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformVsphere {
    /// CertificatesSecretRef refers to a secret that contains the vSphere CA certificates
    /// necessary for communicating with the VCenter.
    #[serde(rename = "certificatesSecretRef")]
    pub certificates_secret_ref: ClusterDeploymentPlatformVsphereCertificatesSecretRef,
    /// Cluster is the name of the cluster virtual machines will be cloned into.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster: Option<String>,
    /// CredentialsSecretRef refers to a secret that contains the vSphere account access
    /// credentials: GOVC_USERNAME, GOVC_PASSWORD fields.
    #[serde(rename = "credentialsSecretRef")]
    pub credentials_secret_ref: ClusterDeploymentPlatformVsphereCredentialsSecretRef,
    /// Datacenter is the name of the datacenter to use in the vCenter.
    pub datacenter: String,
    /// DefaultDatastore is the default datastore to use for provisioning volumes.
    #[serde(rename = "defaultDatastore")]
    pub default_datastore: String,
    /// Folder is the name of the folder that will be used and/or created for
    /// virtual machines.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub folder: Option<String>,
    /// Network specifies the name of the network to be used by the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    /// VCenter is the domain name or IP address of the vCenter.
    #[serde(rename = "vCenter")]
    pub v_center: String,
}

/// CertificatesSecretRef refers to a secret that contains the vSphere CA certificates
/// necessary for communicating with the VCenter.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformVsphereCertificatesSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// CredentialsSecretRef refers to a secret that contains the vSphere account access
/// credentials: GOVC_USERNAME, GOVC_PASSWORD fields.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPlatformVsphereCredentialsSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// ClusterDeploymentSpec defines the desired state of ClusterDeployment
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterDeploymentPowerState {
    #[serde(rename = "")]
    KopiumEmpty,
    Running,
    Hibernating,
}

/// Provisioning contains settings used only for initial cluster provisioning.
/// May be unset in the case of adopted clusters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentProvisioning {
    /// CustomizationRef is a reference to a ClusterDeploymentCustomization containing
    /// InstallerManifestPatches to be applied to the manifests generated by openshift-install prior
    /// to starting the installation. (InstallConfigPatches will be ignored -- those changes should
    /// be made directly to the install-config.yaml referenced by InstallConfigSecretRef.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customizationRef")]
    pub customization_ref: Option<ClusterDeploymentProvisioningCustomizationRef>,
    /// ImageSetRef is a reference to a ClusterImageSet. If a value is specified for ReleaseImage,
    /// that will take precedence over the one from the ClusterImageSet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageSetRef")]
    pub image_set_ref: Option<ClusterDeploymentProvisioningImageSetRef>,
    /// InstallConfigSecretRef is the reference to a secret that contains an openshift-install
    /// InstallConfig. This file will be passed through directly to the installer.
    /// Any version of InstallConfig can be used, provided it can be parsed by the openshift-install
    /// version for the release you are provisioning.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "installConfigSecretRef")]
    pub install_config_secret_ref: Option<ClusterDeploymentProvisioningInstallConfigSecretRef>,
    /// InstallerEnv are extra environment variables to pass through to the installer. This may be used to enable
    /// additional features of the installer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "installerEnv")]
    pub installer_env: Option<Vec<ClusterDeploymentProvisioningInstallerEnv>>,
    /// InstallerImageOverride allows specifying a URI for the installer image, normally gleaned from
    /// the metadata within the ReleaseImage.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "installerImageOverride")]
    pub installer_image_override: Option<String>,
    /// ManifestsConfigMapRef is a reference to user-provided manifests to add to or replace manifests
    /// that are generated by the installer. It serves the same purpose as, and is mutually exclusive
    /// with, ManifestsSecretRef.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "manifestsConfigMapRef")]
    pub manifests_config_map_ref: Option<ClusterDeploymentProvisioningManifestsConfigMapRef>,
    /// ManifestsSecretRef is a reference to user-provided manifests to add to or replace manifests
    /// that are generated by the installer. It serves the same purpose as, and is mutually exclusive
    /// with, ManifestsConfigMapRef.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "manifestsSecretRef")]
    pub manifests_secret_ref: Option<ClusterDeploymentProvisioningManifestsSecretRef>,
    /// ReleaseImage is the image containing metadata for all components that run in the cluster, and
    /// is the primary and best way to specify what specific version of OpenShift you wish to install.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "releaseImage")]
    pub release_image: Option<String>,
    /// SSHKnownHosts are known hosts to be configured in the hive install manager pod to avoid ssh prompts.
    /// Use of ssh in the install pod is somewhat limited today (failure log gathering from cluster, some bare metal
    /// provisioning scenarios), so this setting is often not needed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sshKnownHosts")]
    pub ssh_known_hosts: Option<Vec<String>>,
    /// SSHPrivateKeySecretRef is the reference to the secret that contains the private SSH key to use
    /// for access to compute instances. This private key should correspond to the public key included
    /// in the InstallConfig. The private key is used by Hive to gather logs on the target cluster if
    /// there are install failures.
    /// The SSH private key is expected to be in the secret data under the "ssh-privatekey" key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sshPrivateKeySecretRef")]
    pub ssh_private_key_secret_ref: Option<ClusterDeploymentProvisioningSshPrivateKeySecretRef>,
}

/// CustomizationRef is a reference to a ClusterDeploymentCustomization containing
/// InstallerManifestPatches to be applied to the manifests generated by openshift-install prior
/// to starting the installation. (InstallConfigPatches will be ignored -- those changes should
/// be made directly to the install-config.yaml referenced by InstallConfigSecretRef.)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentProvisioningCustomizationRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// ImageSetRef is a reference to a ClusterImageSet. If a value is specified for ReleaseImage,
/// that will take precedence over the one from the ClusterImageSet.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentProvisioningImageSetRef {
    /// Name is the name of the ClusterImageSet that this refers to
    pub name: String,
}

/// InstallConfigSecretRef is the reference to a secret that contains an openshift-install
/// InstallConfig. This file will be passed through directly to the installer.
/// Any version of InstallConfig can be used, provided it can be parsed by the openshift-install
/// version for the release you are provisioning.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentProvisioningInstallConfigSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentProvisioningInstallerEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterDeploymentProvisioningInstallerEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentProvisioningInstallerEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ClusterDeploymentProvisioningInstallerEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ClusterDeploymentProvisioningInstallerEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ClusterDeploymentProvisioningInstallerEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterDeploymentProvisioningInstallerEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentProvisioningInstallerEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentProvisioningInstallerEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentProvisioningInstallerEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentProvisioningInstallerEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ManifestsConfigMapRef is a reference to user-provided manifests to add to or replace manifests
/// that are generated by the installer. It serves the same purpose as, and is mutually exclusive
/// with, ManifestsSecretRef.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentProvisioningManifestsConfigMapRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// ManifestsSecretRef is a reference to user-provided manifests to add to or replace manifests
/// that are generated by the installer. It serves the same purpose as, and is mutually exclusive
/// with, ManifestsConfigMapRef.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentProvisioningManifestsSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// SSHPrivateKeySecretRef is the reference to the secret that contains the private SSH key to use
/// for access to compute instances. This private key should correspond to the public key included
/// in the InstallConfig. The private key is used by Hive to gather logs on the target cluster if
/// there are install failures.
/// The SSH private key is expected to be in the secret data under the "ssh-privatekey" key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentProvisioningSshPrivateKeySecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// PullSecretRef is the reference to the secret to use when pulling images.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentPullSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// ClusterDeploymentStatus defines the observed state of ClusterDeployment
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatus {
    /// APIURL is the URL where the cluster's API can be accessed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiURL")]
    pub api_url: Option<String>,
    /// CertificateBundles contains of the status of the certificate bundles associated with this cluster deployment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateBundles")]
    pub certificate_bundles: Option<Vec<ClusterDeploymentStatusCertificateBundles>>,
    /// CLIImage is the name of the oc cli image to use when installing the target cluster
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cliImage")]
    pub cli_image: Option<String>,
    /// ClusterVersionStatus is a wholesale copy of the Status section of the spoke cluster's
    /// `clusterversion version` object. This is not officially supported, and is only populated
    /// on request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterVersionStatus")]
    pub cluster_version_status: Option<ClusterDeploymentStatusClusterVersionStatus>,
    /// Conditions includes more detailed status for the cluster deployment
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// InstallRestarts is the total count of container restarts on the clusters install job.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "installRestarts")]
    pub install_restarts: Option<i64>,
    /// InstallStartedTimestamp is the time when all pre-requisites were met and cluster installation was launched.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "installStartedTimestamp")]
    pub install_started_timestamp: Option<String>,
    /// InstallVersion is the version of OpenShift as reported by the release image
    /// resolved for the installation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "installVersion")]
    pub install_version: Option<String>,
    /// InstalledTimestamp is the time we first detected that the cluster has been successfully installed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "installedTimestamp")]
    pub installed_timestamp: Option<String>,
    /// InstallerImage is the name of the installer image to use when installing the target cluster
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "installerImage")]
    pub installer_image: Option<String>,
    /// Platform contains the observed state for the specific platform upon which to
    /// perform the installation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "platformStatus")]
    pub platform_status: Option<ClusterDeploymentStatusPlatformStatus>,
    /// PowerState indicates the powerstate of cluster
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "powerState")]
    pub power_state: Option<String>,
    /// ProvisionRef is a reference to the last ClusterProvision created for the deployment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisionRef")]
    pub provision_ref: Option<ClusterDeploymentStatusProvisionRef>,
    /// WebConsoleURL is the URL for the cluster's web console UI.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webConsoleURL")]
    pub web_console_url: Option<String>,
}

/// CertificateBundleStatus specifies whether a certificate bundle was generated for this
/// cluster deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusCertificateBundles {
    /// Generated indicates whether the certificate bundle was generated
    pub generated: bool,
    /// Name of the certificate bundle
    pub name: String,
}

/// ClusterVersionStatus is a wholesale copy of the Status section of the spoke cluster's
/// `clusterversion version` object. This is not officially supported, and is only populated
/// on request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusClusterVersionStatus {
    /// availableUpdates contains updates recommended for this
    /// cluster. Updates which appear in conditionalUpdates but not in
    /// availableUpdates may expose this cluster to known issues. This list
    /// may be empty if no updates are recommended, if the update service
    /// is unavailable, or if an invalid channel has been specified.
    #[serde(rename = "availableUpdates")]
    pub available_updates: Vec<ClusterDeploymentStatusClusterVersionStatusAvailableUpdates>,
    /// capabilities describes the state of optional, core cluster components.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ClusterDeploymentStatusClusterVersionStatusCapabilities>,
    /// conditionalUpdates contains the list of updates that may be
    /// recommended for this cluster if it meets specific required
    /// conditions. Consumers interested in the set of updates that are
    /// actually recommended for this cluster should use
    /// availableUpdates. This list may be empty if no updates are
    /// recommended, if the update service is unavailable, or if an empty
    /// or invalid channel has been specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionalUpdates")]
    pub conditional_updates: Option<Vec<ClusterDeploymentStatusClusterVersionStatusConditionalUpdates>>,
    /// conditions provides information about the cluster version. The condition
    /// "Available" is set to true if the desiredUpdate has been reached. The
    /// condition "Progressing" is set to true if an update is being applied.
    /// The condition "Degraded" is set to true if an update is currently blocked
    /// by a temporary or permanent error. Conditions are only valid for the
    /// current desiredUpdate when metadata.generation is equal to
    /// status.generation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// desired is the version that the cluster is reconciling towards.
    /// If the cluster is not yet fully initialized desired will be set
    /// with the information available, which may be an image or a tag.
    pub desired: ClusterDeploymentStatusClusterVersionStatusDesired,
    /// history contains a list of the most recent versions applied to the cluster.
    /// This value may be empty during cluster startup, and then will be updated
    /// when a new update is being applied. The newest update is first in the
    /// list and it is ordered by recency. Updates in the history have state
    /// Completed if the rollout completed - if an update was failing or halfway
    /// applied the state will be Partial. Only a limited amount of update history
    /// is preserved.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub history: Option<Vec<ClusterDeploymentStatusClusterVersionStatusHistory>>,
    /// observedGeneration reports which version of the spec is being synced.
    /// If this value is not equal to metadata.generation, then the desired
    /// and conditions fields may represent a previous version.
    #[serde(rename = "observedGeneration")]
    pub observed_generation: i64,
    /// versionHash is a fingerprint of the content that the cluster will be
    /// updated with. It is used by the operator to avoid unnecessary work
    /// and is for internal use only.
    #[serde(rename = "versionHash")]
    pub version_hash: String,
}

/// Release represents an OpenShift release image and associated metadata.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusClusterVersionStatusAvailableUpdates {
    /// architecture is an optional field that indicates the
    /// value of the cluster architecture. In this context cluster
    /// architecture means either a single architecture or a multi
    /// architecture.
    /// Valid values are 'Multi' and empty.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub architecture: Option<ClusterDeploymentStatusClusterVersionStatusAvailableUpdatesArchitecture>,
    /// channels is the set of Cincinnati channels to which the release
    /// currently belongs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channels: Option<Vec<String>>,
    /// image is a container image location that contains the update. When this
    /// field is part of spec, image is optional if version is specified and the
    /// availableUpdates field contains a matching version.
    pub image: String,
    /// url contains information about this release. This URL is set by
    /// the 'url' metadata property on a release or the metadata returned by
    /// the update API and should be displayed as a link in user
    /// interfaces. The URL field may not be set for test or nightly
    /// releases.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// version is a semantic version identifying the update version. When this
    /// field is part of spec, version is optional if image is specified.
    pub version: String,
}

/// Release represents an OpenShift release image and associated metadata.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterDeploymentStatusClusterVersionStatusAvailableUpdatesArchitecture {
    Multi,
    #[serde(rename = "")]
    KopiumEmpty,
}

/// capabilities describes the state of optional, core cluster components.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusClusterVersionStatusCapabilities {
    /// enabledCapabilities lists all the capabilities that are currently managed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enabledCapabilities")]
    pub enabled_capabilities: Option<Vec<String>>,
    /// knownCapabilities lists all the capabilities known to the current cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "knownCapabilities")]
    pub known_capabilities: Option<Vec<String>>,
}

/// ConditionalUpdate represents an update which is recommended to some
/// clusters on the version the current cluster is reconciling, but which
/// may not be recommended for the current cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusClusterVersionStatusConditionalUpdates {
    /// conditions represents the observations of the conditional update's
    /// current status. Known types are:
    /// * Recommended, for whether the update is recommended for the current cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// release is the target of the update.
    pub release: ClusterDeploymentStatusClusterVersionStatusConditionalUpdatesRelease,
    /// risks represents the range of issues associated with
    /// updating to the target release. The cluster-version
    /// operator will evaluate all entries, and only recommend the
    /// update if there is at least one entry and all entries
    /// recommend the update.
    pub risks: Vec<ClusterDeploymentStatusClusterVersionStatusConditionalUpdatesRisks>,
}

/// release is the target of the update.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusClusterVersionStatusConditionalUpdatesRelease {
    /// architecture is an optional field that indicates the
    /// value of the cluster architecture. In this context cluster
    /// architecture means either a single architecture or a multi
    /// architecture.
    /// Valid values are 'Multi' and empty.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub architecture: Option<ClusterDeploymentStatusClusterVersionStatusConditionalUpdatesReleaseArchitecture>,
    /// channels is the set of Cincinnati channels to which the release
    /// currently belongs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channels: Option<Vec<String>>,
    /// image is a container image location that contains the update. When this
    /// field is part of spec, image is optional if version is specified and the
    /// availableUpdates field contains a matching version.
    pub image: String,
    /// url contains information about this release. This URL is set by
    /// the 'url' metadata property on a release or the metadata returned by
    /// the update API and should be displayed as a link in user
    /// interfaces. The URL field may not be set for test or nightly
    /// releases.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// version is a semantic version identifying the update version. When this
    /// field is part of spec, version is optional if image is specified.
    pub version: String,
}

/// release is the target of the update.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterDeploymentStatusClusterVersionStatusConditionalUpdatesReleaseArchitecture {
    Multi,
    #[serde(rename = "")]
    KopiumEmpty,
}

/// ConditionalUpdateRisk represents a reason and cluster-state
/// for not recommending a conditional update.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusClusterVersionStatusConditionalUpdatesRisks {
    /// matchingRules is a slice of conditions for deciding which
    /// clusters match the risk and which do not. The slice is
    /// ordered by decreasing precedence. The cluster-version
    /// operator will walk the slice in order, and stop after the
    /// first it can successfully evaluate. If no condition can be
    /// successfully evaluated, the update will not be recommended.
    #[serde(rename = "matchingRules")]
    pub matching_rules: Vec<ClusterDeploymentStatusClusterVersionStatusConditionalUpdatesRisksMatchingRules>,
    /// message provides additional information about the risk of
    /// updating, in the event that matchingRules match the cluster
    /// state. This is only to be consumed by humans. It may
    /// contain Line Feed characters (U+000A), which should be
    /// rendered as new lines.
    pub message: String,
    /// name is the CamelCase reason for not recommending a
    /// conditional update, in the event that matchingRules match the
    /// cluster state.
    pub name: String,
    /// url contains information about this risk.
    pub url: String,
}

/// ClusterCondition is a union of typed cluster conditions.  The 'type'
/// property determines which of the type-specific properties are relevant.
/// When evaluated on a cluster, the condition may match, not match, or
/// fail to evaluate.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterDeploymentStatusClusterVersionStatusConditionalUpdatesRisksMatchingRules {
    /// promql represents a cluster condition based on PromQL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub promql: Option<ClusterDeploymentStatusClusterVersionStatusConditionalUpdatesRisksMatchingRulesPromql>,
    /// type represents the cluster-condition type. This defines
    /// the members and semantics of any additional properties.
    #[serde(rename = "type")]
    pub r#type: ClusterDeploymentStatusClusterVersionStatusConditionalUpdatesRisksMatchingRulesType,
}

/// promql represents a cluster condition based on PromQL.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusClusterVersionStatusConditionalUpdatesRisksMatchingRulesPromql {
    /// promql is a PromQL query classifying clusters. This query
    /// query should return a 1 in the match case and a 0 in the
    /// does-not-match case. Queries which return no time
    /// series, or which return values besides 0 or 1, are
    /// evaluation failures.
    pub promql: String,
}

/// ClusterCondition is a union of typed cluster conditions.  The 'type'
/// property determines which of the type-specific properties are relevant.
/// When evaluated on a cluster, the condition may match, not match, or
/// fail to evaluate.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterDeploymentStatusClusterVersionStatusConditionalUpdatesRisksMatchingRulesType {
    Always,
    #[serde(rename = "PromQL")]
    PromQl,
}

/// desired is the version that the cluster is reconciling towards.
/// If the cluster is not yet fully initialized desired will be set
/// with the information available, which may be an image or a tag.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusClusterVersionStatusDesired {
    /// architecture is an optional field that indicates the
    /// value of the cluster architecture. In this context cluster
    /// architecture means either a single architecture or a multi
    /// architecture.
    /// Valid values are 'Multi' and empty.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub architecture: Option<ClusterDeploymentStatusClusterVersionStatusDesiredArchitecture>,
    /// channels is the set of Cincinnati channels to which the release
    /// currently belongs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channels: Option<Vec<String>>,
    /// image is a container image location that contains the update. When this
    /// field is part of spec, image is optional if version is specified and the
    /// availableUpdates field contains a matching version.
    pub image: String,
    /// url contains information about this release. This URL is set by
    /// the 'url' metadata property on a release or the metadata returned by
    /// the update API and should be displayed as a link in user
    /// interfaces. The URL field may not be set for test or nightly
    /// releases.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// version is a semantic version identifying the update version. When this
    /// field is part of spec, version is optional if image is specified.
    pub version: String,
}

/// desired is the version that the cluster is reconciling towards.
/// If the cluster is not yet fully initialized desired will be set
/// with the information available, which may be an image or a tag.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterDeploymentStatusClusterVersionStatusDesiredArchitecture {
    Multi,
    #[serde(rename = "")]
    KopiumEmpty,
}

/// UpdateHistory is a single attempted update to the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusClusterVersionStatusHistory {
    /// acceptedRisks records risks which were accepted to initiate the update.
    /// For example, it may menition an Upgradeable=False or missing signature
    /// that was overriden via desiredUpdate.force, or an update that was
    /// initiated despite not being in the availableUpdates set of recommended
    /// update targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acceptedRisks")]
    pub accepted_risks: Option<String>,
    /// completionTime, if set, is when the update was fully applied. The update
    /// that is currently being applied will have a null completion time.
    /// Completion time will always be set for entries that are not the current
    /// update (usually to the started time of the next update).
    #[serde(rename = "completionTime")]
    pub completion_time: String,
    /// image is a container image location that contains the update. This value
    /// is always populated.
    pub image: String,
    /// startedTime is the time at which the update was started.
    #[serde(rename = "startedTime")]
    pub started_time: String,
    /// state reflects whether the update was fully applied. The Partial state
    /// indicates the update is not fully applied, while the Completed state
    /// indicates the update was successfully rolled out at least once (all
    /// parts of the update successfully applied).
    pub state: String,
    /// verified indicates whether the provided update was properly verified
    /// before it was installed. If this is false the cluster may not be trusted.
    /// Verified does not cover upgradeable checks that depend on the cluster
    /// state at the time when the update target was accepted.
    pub verified: bool,
    /// version is a semantic version identifying the update version. If the
    /// requested image does not define a version, or if a failure occurs
    /// retrieving the image, this value may be empty.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Platform contains the observed state for the specific platform upon which to
/// perform the installation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusPlatformStatus {
    /// AWS is the observed state on AWS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<ClusterDeploymentStatusPlatformStatusAws>,
    /// GCP is the observed state on GCP
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gcp: Option<ClusterDeploymentStatusPlatformStatusGcp>,
}

/// AWS is the observed state on AWS.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusPlatformStatusAws {
    /// PrivateLinkAccessStatus contains the observed state for PrivateLinkAccess resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateLink")]
    pub private_link: Option<ClusterDeploymentStatusPlatformStatusAwsPrivateLink>,
}

/// PrivateLinkAccessStatus contains the observed state for PrivateLinkAccess resources.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusPlatformStatusAwsPrivateLink {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostedZoneID")]
    pub hosted_zone_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcEndpointID")]
    pub vpc_endpoint_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcEndpointService")]
    pub vpc_endpoint_service: Option<ClusterDeploymentStatusPlatformStatusAwsPrivateLinkVpcEndpointService>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusPlatformStatusAwsPrivateLinkVpcEndpointService {
    /// AdditionalAllowedPrincipals is a list of additional allowed principal ARNs that have been configured
    /// for the Private Link cluster's VPC Endpoint Service. This list in Status is used to determine if a sync
    /// of Allowed Principals is needed outside of the regular reconcile period of 2hrs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalAllowedPrincipals")]
    pub additional_allowed_principals: Option<Vec<String>>,
    /// DefaultAllowedPrincipal is the ARN of the IAM entity used by Hive as configured for the Private
    /// Link cluster's VPC Endpoint Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultAllowedPrincipal")]
    pub default_allowed_principal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// GCP is the observed state on GCP
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusPlatformStatusGcp {
    /// PrivateServiceConnect contains the private service connect resource references
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateServiceConnect")]
    pub private_service_connect: Option<ClusterDeploymentStatusPlatformStatusGcpPrivateServiceConnect>,
}

/// PrivateServiceConnect contains the private service connect resource references
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusPlatformStatusGcpPrivateServiceConnect {
    /// Endpoint is the selfLink of the endpoint created for the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// EndpointAddress is the selfLink of the address created for the cluster endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointAddress")]
    pub endpoint_address: Option<String>,
    /// ServiceAttachment is the selfLink of the service attachment created for the clsuter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAttachment")]
    pub service_attachment: Option<String>,
    /// ServiceAttachmentFirewall is the selfLink of the firewall that allows traffic between
    /// the service attachment and the cluster's internal api load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAttachmentFirewall")]
    pub service_attachment_firewall: Option<String>,
    /// ServiceAttachmentSubnet is the selfLink of the subnet that will contain the service attachment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAttachmentSubnet")]
    pub service_attachment_subnet: Option<String>,
}

/// ProvisionRef is a reference to the last ClusterProvision created for the deployment
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterDeploymentStatusProvisionRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

