// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/openshift/hive/hive.openshift.io/v1/syncsets.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// SyncSetSpec defines the SyncSetCommonSpec resources and patches to sync along with
/// ClusterDeploymentRefs indicating which clusters the SyncSet applies to in the
/// SyncSet's namespace.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "hive.openshift.io", version = "v1", kind = "SyncSet", plural = "syncsets")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct SyncSetSpec {
    /// ApplyBehavior indicates how resources in this syncset will be applied to the target
    /// cluster. The default value of "Apply" indicates that resources should be applied
    /// using the 'oc apply' command. If no value is set, "Apply" is assumed.
    /// A value of "CreateOnly" indicates that the resource will only be created if it does
    /// not already exist in the target cluster. Otherwise, it will be left alone.
    /// A value of "CreateOrUpdate" indicates that the resource will be created/updated without
    /// the use of the 'oc apply' command, allowing larger resources to be synced, but losing
    /// some functionality of the 'oc apply' command such as the ability to remove annotations,
    /// labels, and other map entries in general.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applyBehavior")]
    pub apply_behavior: Option<SyncSetApplyBehavior>,
    /// ClusterDeploymentRefs is the list of LocalObjectReference indicating which clusters the
    /// SyncSet applies to in the SyncSet's namespace.
    #[serde(rename = "clusterDeploymentRefs")]
    pub cluster_deployment_refs: Vec<SyncSetClusterDeploymentRefs>,
    /// EnablePatchTemplates, if True, causes hive to honor golang text/templates in Patches[].Patch
    /// strings. While the standard syntax is supported, it won't do you a whole lot of good as the
    /// parser does not pass a data object (i.e. there is no "dot" for you to use). This currently
    /// exists to expose a single function: {{ fromCDLabel "some.label/key" }} will be substituted
    /// with the string value of ClusterDeployment.Labels["some.label/key"]. The empty string is
    /// interpolated if there are no labels, or if the indicated key does not exist. Note that the
    /// patch string must be valid JSON after interpolation. This may make for odd-looking quoting
    /// in the uninterpolated string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enablePatchTemplates")]
    pub enable_patch_templates: Option<bool>,
    /// EnableResourceTemplates, if True, causes hive to honor golang text/templates in Resources.
    /// While the standard syntax is supported, it won't do you a whole lot of good as the parser
    /// does not pass a data object (i.e. there is no "dot" for you to use). This currently exists
    /// to expose a single function: {{ fromCDLabel "some.label/key" }} will
    /// be substituted with the string value of ClusterDeployment.Labels["some.label/key"]. The
    /// empty string is interpolated if there are no labels, or if the indicated key does not exist.
    /// Note that this only works in values (not e.g. map keys) that are of type string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableResourceTemplates")]
    pub enable_resource_templates: Option<bool>,
    /// Patches is the list of patches to apply.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patches: Option<Vec<SyncSetPatches>>,
    /// ResourceApplyMode indicates if the Resource apply mode is "Upsert" (default) or "Sync".
    /// ApplyMode "Upsert" indicates create and update.
    /// ApplyMode "Sync" indicates create, update and delete.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceApplyMode")]
    pub resource_apply_mode: Option<String>,
    /// Resources is the list of objects to sync from RawExtension definitions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// Secrets is the list of secrets to sync along with their respective destinations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretMappings")]
    pub secret_mappings: Option<Vec<SyncSetSecretMappings>>,
}

/// SyncSetSpec defines the SyncSetCommonSpec resources and patches to sync along with
/// ClusterDeploymentRefs indicating which clusters the SyncSet applies to in the
/// SyncSet's namespace.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SyncSetApplyBehavior {
    #[serde(rename = "")]
    KopiumEmpty,
    Apply,
    CreateOnly,
    CreateOrUpdate,
}

/// LocalObjectReference contains enough information to let you locate the
/// referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SyncSetClusterDeploymentRefs {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// SyncObjectPatch represents a patch to be applied to a specific object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SyncSetPatches {
    /// APIVersion is the Group and Version of the object to be patched.
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    /// Kind is the Kind of the object to be patched.
    pub kind: String,
    /// Name is the name of the object to be patched.
    pub name: String,
    /// Namespace is the Namespace in which the object to patch exists.
    /// Defaults to the SyncSet's Namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Patch is the patch to apply.
    pub patch: String,
    /// PatchType indicates the PatchType as "strategic" (default), "json", or "merge".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patchType")]
    pub patch_type: Option<String>,
}

/// SecretMapping defines a source and destination for a secret to be synced by a SyncSet
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SyncSetSecretMappings {
    /// SourceRef specifies the name and namespace of a secret on the management cluster
    #[serde(rename = "sourceRef")]
    pub source_ref: SyncSetSecretMappingsSourceRef,
    /// TargetRef specifies the target name and namespace of the secret on the target cluster
    #[serde(rename = "targetRef")]
    pub target_ref: SyncSetSecretMappingsTargetRef,
}

/// SourceRef specifies the name and namespace of a secret on the management cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SyncSetSecretMappingsSourceRef {
    /// Name is the name of the secret
    pub name: String,
    /// Namespace is the namespace where the secret lives. If not present for the source
    /// secret reference, it is assumed to be the same namespace as the syncset with the
    /// reference.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// TargetRef specifies the target name and namespace of the secret on the target cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SyncSetSecretMappingsTargetRef {
    /// Name is the name of the secret
    pub name: String,
    /// Namespace is the namespace where the secret lives. If not present for the source
    /// secret reference, it is assumed to be the same namespace as the syncset with the
    /// reference.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// SyncSetStatus defines the observed state of a SyncSet
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SyncSetStatus {
}

