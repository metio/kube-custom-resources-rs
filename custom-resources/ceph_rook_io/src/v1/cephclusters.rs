// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/rook/rook/ceph.rook.io/v1/cephclusters.yaml
// kopium version: 0.22.3

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use k8s_openapi::api::core::v1::ObjectReference;
}
use self::prelude::*;

/// ClusterSpec represents the specification of Ceph Cluster
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "ceph.rook.io", version = "v1", kind = "CephCluster", plural = "cephclusters")]
#[kube(namespaced)]
#[kube(status = "CephClusterStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct CephClusterSpec {
    /// The annotations-related configuration to add/set on each Pod related object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, BTreeMap<String, String>>>,
    /// Ceph Config options
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cephConfig")]
    pub ceph_config: Option<BTreeMap<String, BTreeMap<String, String>>>,
    /// CephConfigFromSecret works exactly like CephConfig but takes config value from Secret Key reference.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cephConfigFromSecret")]
    pub ceph_config_from_secret: Option<BTreeMap<String, BTreeMap<String, CephClusterCephConfigFromSecret>>>,
    /// The version information that instructs Rook to orchestrate a particular version of Ceph.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cephVersion")]
    pub ceph_version: Option<CephClusterCephVersion>,
    /// Indicates user intent when deleting a cluster; blocks orchestration and should not be set if cluster
    /// deletion is not imminent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cleanupPolicy")]
    pub cleanup_policy: Option<CephClusterCleanupPolicy>,
    /// ContinueUpgradeAfterChecksEvenIfNotHealthy defines if an upgrade should continue even if PGs are not clean
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "continueUpgradeAfterChecksEvenIfNotHealthy")]
    pub continue_upgrade_after_checks_even_if_not_healthy: Option<bool>,
    /// A spec for the crash controller
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crashCollector")]
    pub crash_collector: Option<CephClusterCrashCollector>,
    /// CSI Driver Options applied per cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub csi: Option<CephClusterCsi>,
    /// Dashboard settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dashboard: Option<CephClusterDashboard>,
    /// The path on the host where config and data can be persisted
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataDirHostPath")]
    pub data_dir_host_path: Option<String>,
    /// A spec for configuring disruption management.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disruptionManagement")]
    pub disruption_management: Option<CephClusterDisruptionManagement>,
    /// Whether the Ceph Cluster is running external to this Kubernetes cluster
    /// mon, mgr, osd, mds, and discover daemons will not be created for external clusters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub external: Option<CephClusterExternal>,
    /// Internal daemon healthchecks and liveness probe
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    pub health_check: Option<CephClusterHealthCheck>,
    /// The labels-related configuration to add/set on each Pod related object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, BTreeMap<String, String>>>,
    /// Logging represents loggings settings
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logCollector")]
    pub log_collector: Option<CephClusterLogCollector>,
    /// A spec for mgr related options
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mgr: Option<CephClusterMgr>,
    /// A spec for mon related options
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mon: Option<CephClusterMon>,
    /// Prometheus based Monitoring settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub monitoring: Option<CephClusterMonitoring>,
    /// Network related configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<CephClusterNetwork>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub placement: Option<BTreeMap<String, CephClusterPlacement>>,
    /// PriorityClassNames sets priority classes on components
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityClassNames")]
    pub priority_class_names: Option<BTreeMap<String, String>>,
    /// Remove the OSD that is out and safe to remove only if this option is true
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeOSDsIfOutAndSafeToRemove")]
    pub remove_os_ds_if_out_and_safe_to_remove: Option<bool>,
    /// Resources set resource requests and limits
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<BTreeMap<String, CephClusterResources>>,
    /// Security represents security settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<CephClusterSecurity>,
    /// SkipUpgradeChecks defines if an upgrade should be forced even if one of the check fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "skipUpgradeChecks")]
    pub skip_upgrade_checks: Option<bool>,
    /// A spec for available storage in the cluster and how it should be used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<CephClusterStorage>,
    /// UpgradeOSDRequiresHealthyPGs defines if OSD upgrade requires PGs are clean. If set to `true` OSD upgrade process won't start until PGs are healthy.
    /// This configuration will be ignored if `skipUpgradeChecks` is `true`.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeOSDRequiresHealthyPGs")]
    pub upgrade_osd_requires_healthy_p_gs: Option<bool>,
    /// WaitTimeoutForHealthyOSDInMinutes defines the time the operator would wait before an OSD can be stopped for upgrade or restart.
    /// If the timeout exceeds and OSD is not ok to stop, then the operator would skip upgrade for the current OSD and proceed with the next one
    /// if `continueUpgradeAfterChecksEvenIfNotHealthy` is `false`. If `continueUpgradeAfterChecksEvenIfNotHealthy` is `true`, then operator would
    /// continue with the upgrade of an OSD even if its not ok to stop after the timeout. This timeout won't be applied if `skipUpgradeChecks` is `true`.
    /// The default wait timeout is 10 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "waitTimeoutForHealthyOSDInMinutes")]
    pub wait_timeout_for_healthy_osd_in_minutes: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterCephConfigFromSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The version information that instructs Rook to orchestrate a particular version of Ceph.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterCephVersion {
    /// Whether to allow unsupported versions (do not set to true in production)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowUnsupported")]
    pub allow_unsupported: Option<bool>,
    /// Image is the container image used to launch the ceph daemons, such as quay.io/ceph/ceph:<tag>
    /// The full list of images can be found at <https://quay.io/repository/ceph/ceph?tab=tags>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// ImagePullPolicy describes a policy for if/when to pull a container image
    /// One of Always, Never, IfNotPresent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<CephClusterCephVersionImagePullPolicy>,
}

/// The version information that instructs Rook to orchestrate a particular version of Ceph.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephClusterCephVersionImagePullPolicy {
    IfNotPresent,
    Always,
    Never,
    #[serde(rename = "")]
    KopiumEmpty,
}

/// Indicates user intent when deleting a cluster; blocks orchestration and should not be set if cluster
/// deletion is not imminent.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterCleanupPolicy {
    /// AllowUninstallWithVolumes defines whether we can proceed with the uninstall if they are RBD images still present
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowUninstallWithVolumes")]
    pub allow_uninstall_with_volumes: Option<bool>,
    /// Confirmation represents the cleanup confirmation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub confirmation: Option<String>,
    /// SanitizeDisks represents way we sanitize disks
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sanitizeDisks")]
    pub sanitize_disks: Option<CephClusterCleanupPolicySanitizeDisks>,
    /// WipeDevicesFromOtherClusters wipes the OSD disks belonging to other clusters. This is useful in scenarios where ceph cluster
    /// was reinstalled but OSD disk still contains the metadata from previous ceph cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wipeDevicesFromOtherClusters")]
    pub wipe_devices_from_other_clusters: Option<bool>,
}

/// SanitizeDisks represents way we sanitize disks
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterCleanupPolicySanitizeDisks {
    /// DataSource is the data source to use to sanitize the disk with
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<CephClusterCleanupPolicySanitizeDisksDataSource>,
    /// Iteration is the number of pass to apply the sanitizing
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iteration: Option<i32>,
    /// Method is the method we use to sanitize disks
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<CephClusterCleanupPolicySanitizeDisksMethod>,
}

/// SanitizeDisks represents way we sanitize disks
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephClusterCleanupPolicySanitizeDisksDataSource {
    #[serde(rename = "zero")]
    Zero,
    #[serde(rename = "random")]
    Random,
}

/// SanitizeDisks represents way we sanitize disks
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephClusterCleanupPolicySanitizeDisksMethod {
    #[serde(rename = "complete")]
    Complete,
    #[serde(rename = "quick")]
    Quick,
}

/// A spec for the crash controller
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterCrashCollector {
    /// DaysToRetain represents the number of days to retain crash until they get pruned
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "daysToRetain")]
    pub days_to_retain: Option<i64>,
    /// Disable determines whether we should enable the crash collector
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disable: Option<bool>,
}

/// CSI Driver Options applied per cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterCsi {
    /// CephFS defines CSI Driver settings for CephFS driver.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cephfs: Option<CephClusterCsiCephfs>,
    /// ReadAffinity defines the read affinity settings for CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readAffinity")]
    pub read_affinity: Option<CephClusterCsiReadAffinity>,
    /// SkipUserCreation determines whether CSI users and their associated secrets should be skipped.
    /// If set to true, the user must manually manage these secrets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "skipUserCreation")]
    pub skip_user_creation: Option<bool>,
}

/// CephFS defines CSI Driver settings for CephFS driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterCsiCephfs {
    /// FuseMountOptions defines the mount options for ceph fuse mounter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fuseMountOptions")]
    pub fuse_mount_options: Option<String>,
    /// KernelMountOptions defines the mount options for kernel mounter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kernelMountOptions")]
    pub kernel_mount_options: Option<String>,
}

/// ReadAffinity defines the read affinity settings for CSI driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterCsiReadAffinity {
    /// CrushLocationLabels defines which node labels to use
    /// as CRUSH location. This should correspond to the values set in
    /// the CRUSH map.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crushLocationLabels")]
    pub crush_location_labels: Option<Vec<String>>,
    /// Enables read affinity for CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Dashboard settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterDashboard {
    /// Enabled determines whether to enable the dashboard
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Port is the dashboard webserver port
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// Endpoint for the Prometheus host
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prometheusEndpoint")]
    pub prometheus_endpoint: Option<String>,
    /// Whether to verify the ssl endpoint for prometheus. Set to false for a self-signed cert.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prometheusEndpointSSLVerify")]
    pub prometheus_endpoint_ssl_verify: Option<bool>,
    /// SSL determines whether SSL should be used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ssl: Option<bool>,
    /// URLPrefix is a prefix for all URLs to use the dashboard with a reverse proxy
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlPrefix")]
    pub url_prefix: Option<String>,
}

/// A spec for configuring disruption management.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterDisruptionManagement {
    /// Deprecated. Namespace to look for MDBs by the machineDisruptionBudgetController
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineDisruptionBudgetNamespace")]
    pub machine_disruption_budget_namespace: Option<String>,
    /// Deprecated. This enables management of machinedisruptionbudgets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "manageMachineDisruptionBudgets")]
    pub manage_machine_disruption_budgets: Option<bool>,
    /// This enables management of poddisruptionbudgets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managePodBudgets")]
    pub manage_pod_budgets: Option<bool>,
    /// OSDMaintenanceTimeout sets how many additional minutes the DOWN/OUT interval is for drained failure domains
    /// it only works if managePodBudgets is true.
    /// the default is 30 minutes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "osdMaintenanceTimeout")]
    pub osd_maintenance_timeout: Option<i64>,
    /// DEPRECATED: PGHealthCheckTimeout is no longer implemented
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pgHealthCheckTimeout")]
    pub pg_health_check_timeout: Option<i64>,
    /// PgHealthyRegex is the regular expression that is used to determine which PG states should be considered healthy.
    /// The default is `^(active\+clean|active\+clean\+scrubbing|active\+clean\+scrubbing\+deep)$`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pgHealthyRegex")]
    pub pg_healthy_regex: Option<String>,
}

/// Whether the Ceph Cluster is running external to this Kubernetes cluster
/// mon, mgr, osd, mds, and discover daemons will not be created for external clusters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterExternal {
    /// Enable determines whether external mode is enabled or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
}

/// Internal daemon healthchecks and liveness probe
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheck {
    /// DaemonHealth is the health check for a given daemon
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "daemonHealth")]
    pub daemon_health: Option<CephClusterHealthCheckDaemonHealth>,
    /// LivenessProbe allows changing the livenessProbe configuration for a given daemon
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<BTreeMap<String, CephClusterHealthCheckLivenessProbe>>,
    /// StartupProbe allows changing the startupProbe configuration for a given daemon
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<BTreeMap<String, CephClusterHealthCheckStartupProbe>>,
}

/// DaemonHealth is the health check for a given daemon
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckDaemonHealth {
    /// Monitor represents the health check settings for the Ceph monitor
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mon: Option<CephClusterHealthCheckDaemonHealthMon>,
    /// ObjectStorageDaemon represents the health check settings for the Ceph OSDs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub osd: Option<CephClusterHealthCheckDaemonHealthOsd>,
    /// Status represents the health check settings for the Ceph health
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<CephClusterHealthCheckDaemonHealthStatus>,
}

/// Monitor represents the health check settings for the Ceph monitor
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckDaemonHealthMon {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Interval is the internal in second or minute for the health check to run like 60s for 60 seconds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
}

/// ObjectStorageDaemon represents the health check settings for the Ceph OSDs
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckDaemonHealthOsd {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Interval is the internal in second or minute for the health check to run like 60s for 60 seconds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
}

/// Status represents the health check settings for the Ceph health
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckDaemonHealthStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Interval is the internal in second or minute for the health check to run like 60s for 60 seconds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
}

/// LivenessProbe allows changing the livenessProbe configuration for a given daemon
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckLivenessProbe {
    /// Disabled determines whether probe is disable or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Probe describes a health check to be performed against a container to determine whether it is
    /// alive or ready to receive traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probe: Option<CephClusterHealthCheckLivenessProbeProbe>,
}

/// Probe describes a health check to be performed against a container to determine whether it is
/// alive or ready to receive traffic.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckLivenessProbeProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<CephClusterHealthCheckLivenessProbeProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<CephClusterHealthCheckLivenessProbeProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<CephClusterHealthCheckLivenessProbeProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<CephClusterHealthCheckLivenessProbeProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckLivenessProbeProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckLivenessProbeProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckLivenessProbeProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<CephClusterHealthCheckLivenessProbeProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckLivenessProbeProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckLivenessProbeProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// StartupProbe allows changing the startupProbe configuration for a given daemon
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckStartupProbe {
    /// Disabled determines whether probe is disable or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Probe describes a health check to be performed against a container to determine whether it is
    /// alive or ready to receive traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probe: Option<CephClusterHealthCheckStartupProbeProbe>,
}

/// Probe describes a health check to be performed against a container to determine whether it is
/// alive or ready to receive traffic.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckStartupProbeProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<CephClusterHealthCheckStartupProbeProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<CephClusterHealthCheckStartupProbeProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<CephClusterHealthCheckStartupProbeProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<CephClusterHealthCheckStartupProbeProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckStartupProbeProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckStartupProbeProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckStartupProbeProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<CephClusterHealthCheckStartupProbeProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckStartupProbeProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterHealthCheckStartupProbeProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// Logging represents loggings settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterLogCollector {
    /// Enabled represents whether the log collector is enabled
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// MaxLogSize is the maximum size of the log per ceph daemons. Must be at least 1M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxLogSize")]
    pub max_log_size: Option<IntOrString>,
    /// Periodicity is the periodicity of the log rotation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub periodicity: Option<String>,
}

/// A spec for mgr related options
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMgr {
    /// AllowMultiplePerNode allows to run multiple managers on the same node (not recommended)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMultiplePerNode")]
    pub allow_multiple_per_node: Option<bool>,
    /// Count is the number of manager daemons to run
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<i64>,
    /// Modules is the list of ceph manager modules to enable/disable
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modules: Option<Vec<CephClusterMgrModules>>,
}

/// Module represents mgr modules that the user wants to enable or disable
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMgrModules {
    /// Enabled determines whether a module should be enabled or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Name is the name of the ceph manager module
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Settings to further configure the module
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<CephClusterMgrModulesSettings>,
}

/// Settings to further configure the module
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMgrModulesSettings {
    /// BalancerMode sets the `balancer` module with different modes like `upmap`, `crush-compact` etc
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "balancerMode")]
    pub balancer_mode: Option<CephClusterMgrModulesSettingsBalancerMode>,
}

/// Settings to further configure the module
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephClusterMgrModulesSettingsBalancerMode {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "crush-compat")]
    CrushCompat,
    #[serde(rename = "upmap")]
    Upmap,
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "upmap-read")]
    UpmapRead,
}

/// A spec for mon related options
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMon {
    /// AllowMultiplePerNode determines if we can run multiple monitors on the same node (not recommended)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMultiplePerNode")]
    pub allow_multiple_per_node: Option<bool>,
    /// Count is the number of Ceph monitors
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<i64>,
    /// ExternalMonIDs - optional list of monitor IDs which are deployed externally and not managed by Rook.
    /// If set, Rook will not remove mons with given IDs from quorum.
    /// This parameter is used only for local Rook cluster running in normal mode
    /// and will be ignored if external or stretched mode is used.
    /// leading
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalMonIDs")]
    pub external_mon_i_ds: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureDomainLabel")]
    pub failure_domain_label: Option<String>,
    /// StretchCluster is the stretch cluster specification
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stretchCluster")]
    pub stretch_cluster: Option<CephClusterMonStretchCluster>,
    /// VolumeClaimTemplate is the PVC definition
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<CephClusterMonVolumeClaimTemplate>,
    /// Zones are specified when we want to provide zonal awareness to mons
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zones: Option<Vec<CephClusterMonZones>>,
}

/// StretchCluster is the stretch cluster specification
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonStretchCluster {
    /// FailureDomainLabel the failure domain name (e,g: zone)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureDomainLabel")]
    pub failure_domain_label: Option<String>,
    /// SubFailureDomain is the failure domain within a zone
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subFailureDomain")]
    pub sub_failure_domain: Option<String>,
    /// Zones is the list of zones
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zones: Option<Vec<CephClusterMonStretchClusterZones>>,
}

/// MonZoneSpec represents the specification of a zone in a Ceph Cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonStretchClusterZones {
    /// Arbiter determines if the zone contains the arbiter used for stretch cluster mode
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arbiter: Option<bool>,
    /// Name is the name of the zone
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// VolumeClaimTemplate is the PVC template
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<CephClusterMonStretchClusterZonesVolumeClaimTemplate>,
}

/// VolumeClaimTemplate is the PVC template
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonStretchClusterZonesVolumeClaimTemplate {
    /// Standard object's metadata.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<CephClusterMonStretchClusterZonesVolumeClaimTemplateMetadata>,
    /// spec defines the desired characteristics of a volume requested by a pod author.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<CephClusterMonStretchClusterZonesVolumeClaimTemplateSpec>,
}

/// Standard object's metadata.
/// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonStretchClusterZonesVolumeClaimTemplateMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub finalizers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// spec defines the desired characteristics of a volume requested by a pod author.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonStretchClusterZonesVolumeClaimTemplateSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<CephClusterMonStretchClusterZonesVolumeClaimTemplateSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<CephClusterMonStretchClusterZonesVolumeClaimTemplateSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CephClusterMonStretchClusterZonesVolumeClaimTemplateSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<CephClusterMonStretchClusterZonesVolumeClaimTemplateSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string or nil value indicates that no
    /// VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
    /// this field can be reset to its previous value (including nil) to cancel the modification.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonStretchClusterZonesVolumeClaimTemplateSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonStretchClusterZonesVolumeClaimTemplateSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonStretchClusterZonesVolumeClaimTemplateSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonStretchClusterZonesVolumeClaimTemplateSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterMonStretchClusterZonesVolumeClaimTemplateSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonStretchClusterZonesVolumeClaimTemplateSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// VolumeClaimTemplate is the PVC definition
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonVolumeClaimTemplate {
    /// Standard object's metadata.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<CephClusterMonVolumeClaimTemplateMetadata>,
    /// spec defines the desired characteristics of a volume requested by a pod author.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<CephClusterMonVolumeClaimTemplateSpec>,
}

/// Standard object's metadata.
/// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonVolumeClaimTemplateMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub finalizers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// spec defines the desired characteristics of a volume requested by a pod author.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonVolumeClaimTemplateSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<CephClusterMonVolumeClaimTemplateSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<CephClusterMonVolumeClaimTemplateSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CephClusterMonVolumeClaimTemplateSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<CephClusterMonVolumeClaimTemplateSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string or nil value indicates that no
    /// VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
    /// this field can be reset to its previous value (including nil) to cancel the modification.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonVolumeClaimTemplateSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonVolumeClaimTemplateSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonVolumeClaimTemplateSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonVolumeClaimTemplateSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterMonVolumeClaimTemplateSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonVolumeClaimTemplateSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// MonZoneSpec represents the specification of a zone in a Ceph Cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonZones {
    /// Arbiter determines if the zone contains the arbiter used for stretch cluster mode
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arbiter: Option<bool>,
    /// Name is the name of the zone
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// VolumeClaimTemplate is the PVC template
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<CephClusterMonZonesVolumeClaimTemplate>,
}

/// VolumeClaimTemplate is the PVC template
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonZonesVolumeClaimTemplate {
    /// Standard object's metadata.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<CephClusterMonZonesVolumeClaimTemplateMetadata>,
    /// spec defines the desired characteristics of a volume requested by a pod author.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<CephClusterMonZonesVolumeClaimTemplateSpec>,
}

/// Standard object's metadata.
/// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonZonesVolumeClaimTemplateMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub finalizers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// spec defines the desired characteristics of a volume requested by a pod author.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonZonesVolumeClaimTemplateSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<CephClusterMonZonesVolumeClaimTemplateSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<CephClusterMonZonesVolumeClaimTemplateSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CephClusterMonZonesVolumeClaimTemplateSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<CephClusterMonZonesVolumeClaimTemplateSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string or nil value indicates that no
    /// VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
    /// this field can be reset to its previous value (including nil) to cancel the modification.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonZonesVolumeClaimTemplateSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonZonesVolumeClaimTemplateSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonZonesVolumeClaimTemplateSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonZonesVolumeClaimTemplateSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterMonZonesVolumeClaimTemplateSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonZonesVolumeClaimTemplateSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Prometheus based Monitoring settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonitoring {
    /// Enabled determines whether to create the prometheus rules for the ceph cluster. If true, the prometheus
    /// types must exist or the creation will fail. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Ceph exporter configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exporter: Option<CephClusterMonitoringExporter>,
    /// ExternalMgrEndpoints points to an existing Ceph prometheus exporter endpoint
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalMgrEndpoints")]
    pub external_mgr_endpoints: Option<Vec<CephClusterMonitoringExternalMgrEndpoints>>,
    /// ExternalMgrPrometheusPort Prometheus exporter port
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalMgrPrometheusPort")]
    pub external_mgr_prometheus_port: Option<i64>,
    /// Interval determines prometheus scrape interval
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Whether to disable the metrics reported by Ceph. If false, the prometheus mgr module and Ceph exporter are enabled.
    /// If true, the prometheus mgr module and Ceph exporter are both disabled. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricsDisabled")]
    pub metrics_disabled: Option<bool>,
    /// Port is the prometheus server port
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
}

/// Ceph exporter configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonitoringExporter {
    /// Whether host networking is enabled for CephExporter. If not set, the network settings from CephCluster.spec.networking will be applied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetwork")]
    pub host_network: Option<bool>,
    /// Only performance counters greater than or equal to this option are fetched
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perfCountersPrioLimit")]
    pub perf_counters_prio_limit: Option<i64>,
    /// Time to wait before sending requests again to exporter server (seconds)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statsPeriodSeconds")]
    pub stats_period_seconds: Option<i64>,
}

/// EndpointAddress is a tuple that describes single IP address.
/// Deprecated: This API is deprecated in v1.33+.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonitoringExternalMgrEndpoints {
    /// The Hostname of this endpoint
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// The IP of this endpoint.
    /// May not be loopback (127.0.0.0/8 or ::1), link-local (169.254.0.0/16 or fe80::/10),
    /// or link-local multicast (224.0.0.0/24 or ff02::/16).
    pub ip: String,
    /// Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeName")]
    pub node_name: Option<String>,
    /// Reference to object providing the endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetRef")]
    pub target_ref: Option<ObjectReference>,
}

/// Reference to object providing the endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterMonitoringExternalMgrEndpointsTargetRef {
    /// API version of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// If referring to a piece of an object instead of an entire object, this string
    /// should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
    /// For example, if the object reference is to a container within a pod, this would take on a value like:
    /// "spec.containers{name}" (where "name" refers to the name of the container that triggered
    /// the event) or if no container name is specified "spec.containers[2]" (container with
    /// index 2 in this pod). This syntax is chosen only to have some well-defined way of
    /// referencing a part of an object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldPath")]
    pub field_path: Option<String>,
    /// Kind of the referent.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Specific resourceVersion to which this reference is made, if any.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceVersion")]
    pub resource_version: Option<String>,
    /// UID of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
}

/// Network related configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterNetwork {
    /// AddressRanges specify a list of CIDRs that Rook will apply to Ceph's 'public_network' and/or
    /// 'cluster_network' configurations. This config section may be used for the "host" or "multus"
    /// network providers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addressRanges")]
    pub address_ranges: Option<CephClusterNetworkAddressRanges>,
    /// Settings for network connections such as compression and encryption across the
    /// wire.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub connections: Option<CephClusterNetworkConnections>,
    /// DualStack determines whether Ceph daemons should listen on both IPv4 and IPv6
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dualStack")]
    pub dual_stack: Option<bool>,
    /// HostNetwork to enable host network.
    /// If host networking is enabled or disabled on a running cluster, then the operator will automatically fail over all the mons to
    /// apply the new network settings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetwork")]
    pub host_network: Option<bool>,
    /// IPFamily is the single stack IPv6 or IPv4 protocol
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipFamily")]
    pub ip_family: Option<CephClusterNetworkIpFamily>,
    /// Enable multiClusterService to export the Services between peer clusters
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multiClusterService")]
    pub multi_cluster_service: Option<CephClusterNetworkMultiClusterService>,
    /// Provider is what provides network connectivity to the cluster e.g. "host" or "multus".
    /// If the Provider is updated from being empty to "host" on a running cluster, then the operator will automatically fail over all the mons to apply the "host" network settings.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provider: Option<CephClusterNetworkProvider>,
    /// Selectors define NetworkAttachmentDefinitions to be used for Ceph public and/or cluster
    /// networks when the "multus" network provider is used. This config section is not used for
    /// other network providers.
    /// 
    /// Valid keys are "public" and "cluster". Refer to Ceph networking documentation for more:
    /// <https://docs.ceph.com/en/latest/rados/configuration/network-config-ref/>
    /// 
    /// Refer to Multus network annotation documentation for help selecting values:
    /// <https://github.com/k8snetworkplumbingwg/multus-cni/blob/master/docs/how-to-use.md#run-pod-with-network-annotation>
    /// 
    /// Rook will make a best-effort attempt to automatically detect CIDR address ranges for given
    /// network attachment definitions. Rook's methods are robust but may be imprecise for
    /// sufficiently complicated networks. Rook's auto-detection process obtains a new IP address
    /// lease for each CephCluster reconcile. If Rook fails to detect, incorrectly detects, only
    /// partially detects, or if underlying networks do not support reusing old IP addresses, it is
    /// best to use the 'addressRanges' config section to specify CIDR ranges for the Ceph cluster.
    /// 
    /// As a contrived example, one can use a theoretical Kubernetes-wide network for Ceph client
    /// traffic and a theoretical Rook-only network for Ceph replication traffic as shown:
    ///   selectors:
    ///     public: "default/cluster-fast-net"
    ///     cluster: "rook-ceph/ceph-backend-net"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selectors: Option<BTreeMap<String, String>>,
}

/// AddressRanges specify a list of CIDRs that Rook will apply to Ceph's 'public_network' and/or
/// 'cluster_network' configurations. This config section may be used for the "host" or "multus"
/// network providers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterNetworkAddressRanges {
    /// Cluster defines a list of CIDRs to use for Ceph cluster network communication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster: Option<Vec<String>>,
    /// Public defines a list of CIDRs to use for Ceph public network communication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public: Option<Vec<String>>,
}

/// Settings for network connections such as compression and encryption across the
/// wire.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterNetworkConnections {
    /// Compression settings for the network connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compression: Option<CephClusterNetworkConnectionsCompression>,
    /// Encryption settings for the network connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encryption: Option<CephClusterNetworkConnectionsEncryption>,
    /// Whether to require msgr2 (port 3300) even if compression or encryption are not enabled.
    /// If true, the msgr1 port (6789) will be disabled.
    /// Requires a kernel that supports msgr2 (kernel 5.11 or CentOS 8.4 or newer).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireMsgr2")]
    pub require_msgr2: Option<bool>,
}

/// Compression settings for the network connections.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterNetworkConnectionsCompression {
    /// Whether to compress the data in transit across the wire.
    /// The default is not set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Encryption settings for the network connections.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterNetworkConnectionsEncryption {
    /// Whether to encrypt the data in transit across the wire to prevent eavesdropping
    /// the data on the network. The default is not set. Even if encryption is not enabled,
    /// clients still establish a strong initial authentication for the connection
    /// and data integrity is still validated with a crc check. When encryption is enabled,
    /// all communication between clients and Ceph daemons, or between Ceph daemons will
    /// be encrypted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Network related configuration
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephClusterNetworkIpFamily {
    IPv4,
    IPv6,
}

/// Enable multiClusterService to export the Services between peer clusters
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterNetworkMultiClusterService {
    /// ClusterID uniquely identifies a cluster. It is used as a prefix to nslookup exported
    /// services. For example: <clusterid>.<svc>.<ns>.svc.clusterset.local
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterID")]
    pub cluster_id: Option<String>,
    /// Enable multiClusterService to export the mon and OSD services to peer cluster.
    /// Ensure that peer clusters are connected using an MCS API compatible application,
    /// like Globalnet Submariner.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Network related configuration
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephClusterNetworkProvider {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "host")]
    Host,
    #[serde(rename = "multus")]
    Multus,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacement {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<CephClusterPlacementNodeAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<CephClusterPlacementPodAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<CephClusterPlacementPodAntiAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<CephClusterPlacementTolerations>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topologySpreadConstraints")]
    pub topology_spread_constraints: Option<Vec<CephClusterPlacementTopologySpreadConstraints>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephClusterPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<CephClusterPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: CephClusterPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<CephClusterPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<CephClusterPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<CephClusterPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephClusterPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<CephClusterPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: CephClusterPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephClusterPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephClusterPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephClusterPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephClusterPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephClusterPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<CephClusterPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: CephClusterPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephClusterPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephClusterPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephClusterPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephClusterPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementTopologySpreadConstraints {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephClusterPlacementTopologySpreadConstraintsLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(rename = "maxSkew")]
    pub max_skew: i32,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minDomains")]
    pub min_domains: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinityPolicy")]
    pub node_affinity_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeTaintsPolicy")]
    pub node_taints_policy: Option<String>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
    #[serde(rename = "whenUnsatisfiable")]
    pub when_unsatisfiable: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementTopologySpreadConstraintsLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterPlacementTopologySpreadConstraintsLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterPlacementTopologySpreadConstraintsLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Resources set resource requests and limits
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This field depends on the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<CephClusterResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// Security represents security settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterSecurity {
    /// CephX configures CephX key settings. More: <https://docs.ceph.com/en/latest/dev/cephx/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cephx: Option<CephClusterSecurityCephx>,
    /// KeyRotation defines options for rotation of OSD disk encryption keys.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyRotation")]
    pub key_rotation: Option<CephClusterSecurityKeyRotation>,
    /// KeyManagementService is the main Key Management option
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kms: Option<CephClusterSecurityKms>,
}

/// CephX configures CephX key settings. More: <https://docs.ceph.com/en/latest/dev/cephx/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterSecurityCephx {
    /// CSI configures CephX key rotation settings for the Ceph-CSI daemons in the current Kubernetes cluster.
    /// CSI key rotation can affect existing PV connections, so take care when exercising this option.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub csi: Option<CephClusterSecurityCephxCsi>,
    /// Daemon configures CephX key settings for local Ceph daemons managed by Rook and part of the
    /// Ceph cluster. Daemon CephX keys can be rotated without affecting client connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub daemon: Option<CephClusterSecurityCephxDaemon>,
    /// RBDMirrorPeer configures CephX key settings of the `rbd-mirror-peer` user that is used for creating
    /// bootstrap peer token used connect peer clusters. Rotating the `rbd-mirror-peer` user key will update
    /// the mirror peer token.
    /// Rotation will affect any existing peers connected to this cluster, so take care when exercising this option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rbdMirrorPeer")]
    pub rbd_mirror_peer: Option<CephClusterSecurityCephxRbdMirrorPeer>,
}

/// CSI configures CephX key rotation settings for the Ceph-CSI daemons in the current Kubernetes cluster.
/// CSI key rotation can affect existing PV connections, so take care when exercising this option.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterSecurityCephxCsi {
    /// KeepPriorKeyCountMax tells Rook how many prior keys to keep active.
    /// Generally, this would be set to 1 to allow for a migration period for applications.
    /// If desired, set this to 0 to delete prior keys after migration.
    /// This config only applies to prior keys that already exist.
    /// If PriorKeyCount is set to 2 while only a single key currently exists, only a single prior key will be kept,
    /// and the reported status will only indicate the actual number of prior keys,
    /// not necessarily a reflection of PriorKeyCount config here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepPriorKeyCountMax")]
    pub keep_prior_key_count_max: Option<i64>,
    /// KeyGeneration specifies the desired CephX key generation. This is used when KeyRotationPolicy
    /// is KeyGeneration and ignored for other policies. If this is set to greater than the current
    /// key generation, relevant keys will be rotated, and the generation value will be updated to
    /// this new value (generation values are not necessarily incremental, though that is the
    /// intended use case). If this is set to less than or equal to the current key generation, keys
    /// are not rotated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyGeneration")]
    pub key_generation: Option<i32>,
    /// KeyRotationPolicy controls if and when CephX keys are rotated after initial creation.
    /// One of Disabled, or KeyGeneration. Default Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyRotationPolicy")]
    pub key_rotation_policy: Option<CephClusterSecurityCephxCsiKeyRotationPolicy>,
}

/// CSI configures CephX key rotation settings for the Ceph-CSI daemons in the current Kubernetes cluster.
/// CSI key rotation can affect existing PV connections, so take care when exercising this option.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephClusterSecurityCephxCsiKeyRotationPolicy {
    #[serde(rename = "")]
    KopiumEmpty,
    Disabled,
    KeyGeneration,
}

/// Daemon configures CephX key settings for local Ceph daemons managed by Rook and part of the
/// Ceph cluster. Daemon CephX keys can be rotated without affecting client connections.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterSecurityCephxDaemon {
    /// KeyGeneration specifies the desired CephX key generation. This is used when KeyRotationPolicy
    /// is KeyGeneration and ignored for other policies. If this is set to greater than the current
    /// key generation, relevant keys will be rotated, and the generation value will be updated to
    /// this new value (generation values are not necessarily incremental, though that is the
    /// intended use case). If this is set to less than or equal to the current key generation, keys
    /// are not rotated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyGeneration")]
    pub key_generation: Option<i32>,
    /// KeyRotationPolicy controls if and when CephX keys are rotated after initial creation.
    /// One of Disabled, or KeyGeneration. Default Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyRotationPolicy")]
    pub key_rotation_policy: Option<CephClusterSecurityCephxDaemonKeyRotationPolicy>,
}

/// Daemon configures CephX key settings for local Ceph daemons managed by Rook and part of the
/// Ceph cluster. Daemon CephX keys can be rotated without affecting client connections.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephClusterSecurityCephxDaemonKeyRotationPolicy {
    #[serde(rename = "")]
    KopiumEmpty,
    Disabled,
    KeyGeneration,
}

/// RBDMirrorPeer configures CephX key settings of the `rbd-mirror-peer` user that is used for creating
/// bootstrap peer token used connect peer clusters. Rotating the `rbd-mirror-peer` user key will update
/// the mirror peer token.
/// Rotation will affect any existing peers connected to this cluster, so take care when exercising this option.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterSecurityCephxRbdMirrorPeer {
    /// KeyGeneration specifies the desired CephX key generation. This is used when KeyRotationPolicy
    /// is KeyGeneration and ignored for other policies. If this is set to greater than the current
    /// key generation, relevant keys will be rotated, and the generation value will be updated to
    /// this new value (generation values are not necessarily incremental, though that is the
    /// intended use case). If this is set to less than or equal to the current key generation, keys
    /// are not rotated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyGeneration")]
    pub key_generation: Option<i32>,
    /// KeyRotationPolicy controls if and when CephX keys are rotated after initial creation.
    /// One of Disabled, or KeyGeneration. Default Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyRotationPolicy")]
    pub key_rotation_policy: Option<CephClusterSecurityCephxRbdMirrorPeerKeyRotationPolicy>,
}

/// RBDMirrorPeer configures CephX key settings of the `rbd-mirror-peer` user that is used for creating
/// bootstrap peer token used connect peer clusters. Rotating the `rbd-mirror-peer` user key will update
/// the mirror peer token.
/// Rotation will affect any existing peers connected to this cluster, so take care when exercising this option.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephClusterSecurityCephxRbdMirrorPeerKeyRotationPolicy {
    #[serde(rename = "")]
    KopiumEmpty,
    Disabled,
    KeyGeneration,
}

/// KeyRotation defines options for rotation of OSD disk encryption keys.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterSecurityKeyRotation {
    /// Enabled represents whether the key rotation is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Schedule represents the cron schedule for key rotation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schedule: Option<String>,
}

/// KeyManagementService is the main Key Management option
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterSecurityKms {
    /// ConnectionDetails contains the KMS connection details (address, port etc)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionDetails")]
    pub connection_details: Option<BTreeMap<String, String>>,
    /// TokenSecretName is the kubernetes secret containing the KMS token
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenSecretName")]
    pub token_secret_name: Option<String>,
}

/// A spec for available storage in the cluster and how it should be used
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorage {
    /// Whether to allow updating the device class after the OSD is initially provisioned
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowDeviceClassUpdate")]
    pub allow_device_class_update: Option<bool>,
    /// Whether Rook will resize the OSD CRUSH weight when the OSD PVC size is increased.
    /// This allows cluster data to be rebalanced to make most effective use of new OSD space.
    /// The default is false since data rebalancing can cause temporary cluster slowdown.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOsdCrushWeightUpdate")]
    pub allow_osd_crush_weight_update: Option<bool>,
    /// BackfillFullRatio is the ratio at which the cluster is too full for backfill. Backfill will be disabled if above this threshold. Default is 0.90.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backfillFullRatio")]
    pub backfill_full_ratio: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<BTreeMap<String, String>>,
    /// A regular expression to allow more fine-grained selection of devices on nodes across the cluster
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceFilter")]
    pub device_filter: Option<String>,
    /// A regular expression to allow more fine-grained selection of devices with path names
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "devicePathFilter")]
    pub device_path_filter: Option<String>,
    /// List of devices to use as storage devices
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub devices: Option<Vec<CephClusterStorageDevices>>,
    /// FlappingRestartIntervalHours defines the time for which the OSD pods, that failed with zero exit code, will sleep before restarting.
    /// This is needed for OSD flapping where OSD daemons are marked down more than 5 times in 600 seconds by Ceph.
    /// Preventing the OSD pods to restart immediately in such scenarios will prevent Rook from marking OSD as `up` and thus
    /// peering of the PGs mapped to the OSD.
    /// User needs to manually restart the OSD pod if they manage to fix the underlying OSD flapping issue before the restart interval.
    /// The sleep will be disabled if this interval is set to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flappingRestartIntervalHours")]
    pub flapping_restart_interval_hours: Option<i64>,
    /// FullRatio is the ratio at which the cluster is considered full and ceph will stop accepting writes. Default is 0.95.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fullRatio")]
    pub full_ratio: Option<f64>,
    /// Migration handles the OSD migration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub migration: Option<CephClusterStorageMigration>,
    /// NearFullRatio is the ratio at which the cluster is considered nearly full and will raise a ceph health warning. Default is 0.85.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nearFullRatio")]
    pub near_full_ratio: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nodes: Option<Vec<CephClusterStorageNodes>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onlyApplyOSDPlacement")]
    pub only_apply_osd_placement: Option<bool>,
    /// Whether to always schedule OSDs on a node even if the node is not currently scheduleable or ready
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scheduleAlways")]
    pub schedule_always: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassDeviceSets")]
    pub storage_class_device_sets: Option<Vec<CephClusterStorageStorageClassDeviceSets>>,
    /// OSDStore is the backend storage type used for creating the OSDs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub store: Option<CephClusterStorageStore>,
    /// Whether to consume all the storage devices found on a machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useAllDevices")]
    pub use_all_devices: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useAllNodes")]
    pub use_all_nodes: Option<bool>,
    /// PersistentVolumeClaims to use as storage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplates")]
    pub volume_claim_templates: Option<Vec<CephClusterStorageVolumeClaimTemplates>>,
}

/// Device represents a disk to use in the cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageDevices {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fullpath: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Migration handles the OSD migration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageMigration {
    /// A user confirmation to migrate the OSDs. It destroys each OSD one at a time, cleans up the backing disk
    /// and prepares OSD with same ID on that disk
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub confirmation: Option<String>,
}

/// Node is a storage nodes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageNodes {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<BTreeMap<String, String>>,
    /// A regular expression to allow more fine-grained selection of devices on nodes across the cluster
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceFilter")]
    pub device_filter: Option<String>,
    /// A regular expression to allow more fine-grained selection of devices with path names
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "devicePathFilter")]
    pub device_path_filter: Option<String>,
    /// List of devices to use as storage devices
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub devices: Option<Vec<CephClusterStorageNodesDevices>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// ResourceRequirements describes the compute resource requirements.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CephClusterStorageNodesResources>,
    /// Whether to consume all the storage devices found on a machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useAllDevices")]
    pub use_all_devices: Option<bool>,
    /// PersistentVolumeClaims to use as storage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplates")]
    pub volume_claim_templates: Option<Vec<CephClusterStorageNodesVolumeClaimTemplates>>,
}

/// Device represents a disk to use in the cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageNodesDevices {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fullpath: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// ResourceRequirements describes the compute resource requirements.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageNodesResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This field depends on the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<CephClusterStorageNodesResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageNodesResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// VolumeClaimTemplate is a simplified version of K8s corev1's PVC. It has no type meta or status.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageNodesVolumeClaimTemplates {
    /// Standard object's metadata.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<CephClusterStorageNodesVolumeClaimTemplatesMetadata>,
    /// spec defines the desired characteristics of a volume requested by a pod author.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<CephClusterStorageNodesVolumeClaimTemplatesSpec>,
}

/// Standard object's metadata.
/// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageNodesVolumeClaimTemplatesMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub finalizers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// spec defines the desired characteristics of a volume requested by a pod author.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageNodesVolumeClaimTemplatesSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<CephClusterStorageNodesVolumeClaimTemplatesSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<CephClusterStorageNodesVolumeClaimTemplatesSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CephClusterStorageNodesVolumeClaimTemplatesSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<CephClusterStorageNodesVolumeClaimTemplatesSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string or nil value indicates that no
    /// VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
    /// this field can be reset to its previous value (including nil) to cancel the modification.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageNodesVolumeClaimTemplatesSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageNodesVolumeClaimTemplatesSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageNodesVolumeClaimTemplatesSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageNodesVolumeClaimTemplatesSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageNodesVolumeClaimTemplatesSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageNodesVolumeClaimTemplatesSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// StorageClassDeviceSet is a storage class device set
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSets {
    /// Provider-specific device configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<BTreeMap<String, String>>,
    /// Count is the number of devices in this set
    pub count: i64,
    /// Whether to encrypt the deviceSet
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encrypted: Option<bool>,
    /// Name is a unique identifier for the set
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub placement: Option<CephClusterStorageStorageClassDeviceSetsPlacement>,
    /// Portable represents OSD portability across the hosts
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub portable: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preparePlacement")]
    pub prepare_placement: Option<CephClusterStorageStorageClassDeviceSetsPreparePlacement>,
    /// ResourceRequirements describes the compute resource requirements.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CephClusterStorageStorageClassDeviceSetsResources>,
    /// Scheduler name for OSD pod placement
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerName")]
    pub scheduler_name: Option<String>,
    /// TuneSlowDeviceClass Tune the OSD when running on a slow Device Class
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tuneDeviceClass")]
    pub tune_device_class: Option<bool>,
    /// TuneFastDeviceClass Tune the OSD when running on a fast Device Class
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tuneFastDeviceClass")]
    pub tune_fast_device_class: Option<bool>,
    /// VolumeClaimTemplates is a list of PVC templates for the underlying storage devices
    #[serde(rename = "volumeClaimTemplates")]
    pub volume_claim_templates: Vec<CephClusterStorageStorageClassDeviceSetsVolumeClaimTemplates>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacement {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<CephClusterStorageStorageClassDeviceSetsPlacementPodAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementTolerations>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topologySpreadConstraints")]
    pub topology_spread_constraints: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementTopologySpreadConstraints>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementTopologySpreadConstraints {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephClusterStorageStorageClassDeviceSetsPlacementTopologySpreadConstraintsLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(rename = "maxSkew")]
    pub max_skew: i32,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minDomains")]
    pub min_domains: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinityPolicy")]
    pub node_affinity_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeTaintsPolicy")]
    pub node_taints_policy: Option<String>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
    #[serde(rename = "whenUnsatisfiable")]
    pub when_unsatisfiable: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementTopologySpreadConstraintsLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPlacementTopologySpreadConstraintsLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPlacementTopologySpreadConstraintsLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacement {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementTolerations>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topologySpreadConstraints")]
    pub topology_spread_constraints: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementTopologySpreadConstraints>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementTopologySpreadConstraints {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephClusterStorageStorageClassDeviceSetsPreparePlacementTopologySpreadConstraintsLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(rename = "maxSkew")]
    pub max_skew: i32,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minDomains")]
    pub min_domains: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinityPolicy")]
    pub node_affinity_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeTaintsPolicy")]
    pub node_taints_policy: Option<String>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
    #[serde(rename = "whenUnsatisfiable")]
    pub when_unsatisfiable: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementTopologySpreadConstraintsLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsPreparePlacementTopologySpreadConstraintsLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsPreparePlacementTopologySpreadConstraintsLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ResourceRequirements describes the compute resource requirements.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This field depends on the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<CephClusterStorageStorageClassDeviceSetsResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// VolumeClaimTemplate is a simplified version of K8s corev1's PVC. It has no type meta or status.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsVolumeClaimTemplates {
    /// Standard object's metadata.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<CephClusterStorageStorageClassDeviceSetsVolumeClaimTemplatesMetadata>,
    /// spec defines the desired characteristics of a volume requested by a pod author.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<CephClusterStorageStorageClassDeviceSetsVolumeClaimTemplatesSpec>,
}

/// Standard object's metadata.
/// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsVolumeClaimTemplatesMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub finalizers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// spec defines the desired characteristics of a volume requested by a pod author.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsVolumeClaimTemplatesSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<CephClusterStorageStorageClassDeviceSetsVolumeClaimTemplatesSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<CephClusterStorageStorageClassDeviceSetsVolumeClaimTemplatesSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CephClusterStorageStorageClassDeviceSetsVolumeClaimTemplatesSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<CephClusterStorageStorageClassDeviceSetsVolumeClaimTemplatesSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string or nil value indicates that no
    /// VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
    /// this field can be reset to its previous value (including nil) to cancel the modification.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsVolumeClaimTemplatesSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsVolumeClaimTemplatesSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsVolumeClaimTemplatesSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsVolumeClaimTemplatesSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageStorageClassDeviceSetsVolumeClaimTemplatesSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStorageClassDeviceSetsVolumeClaimTemplatesSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// OSDStore is the backend storage type used for creating the OSDs
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageStore {
    /// Type of backend storage to be used while creating OSDs. If empty, then bluestore will be used
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<CephClusterStorageStoreType>,
    /// UpdateStore updates the backend store for existing OSDs. It destroys each OSD one at a time, cleans up the backing disk
    /// and prepares same OSD on that disk
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateStore")]
    pub update_store: Option<String>,
}

/// OSDStore is the backend storage type used for creating the OSDs
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephClusterStorageStoreType {
    #[serde(rename = "bluestore")]
    Bluestore,
    #[serde(rename = "bluestore-rdr")]
    BluestoreRdr,
}

/// VolumeClaimTemplate is a simplified version of K8s corev1's PVC. It has no type meta or status.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageVolumeClaimTemplates {
    /// Standard object's metadata.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<CephClusterStorageVolumeClaimTemplatesMetadata>,
    /// spec defines the desired characteristics of a volume requested by a pod author.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<CephClusterStorageVolumeClaimTemplatesSpec>,
}

/// Standard object's metadata.
/// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageVolumeClaimTemplatesMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub finalizers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// spec defines the desired characteristics of a volume requested by a pod author.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageVolumeClaimTemplatesSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<CephClusterStorageVolumeClaimTemplatesSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<CephClusterStorageVolumeClaimTemplatesSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CephClusterStorageVolumeClaimTemplatesSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<CephClusterStorageVolumeClaimTemplatesSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string or nil value indicates that no
    /// VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
    /// this field can be reset to its previous value (including nil) to cancel the modification.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageVolumeClaimTemplatesSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageVolumeClaimTemplatesSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageVolumeClaimTemplatesSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageVolumeClaimTemplatesSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephClusterStorageVolumeClaimTemplatesSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStorageVolumeClaimTemplatesSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ClusterStatus represents the status of a Ceph cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatus {
    /// CephStatus is the details health of a Ceph Cluster
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ceph: Option<CephClusterStatusCeph>,
    /// ClusterCephxStatus defines the cephx key rotation status of various daemons on the cephCluster resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cephx: Option<CephClusterStatusCephx>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// ObservedGeneration is the latest generation observed by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// ConditionType represent a resource's status
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<String>,
    /// ClusterState represents the state of a Ceph Cluster
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
    /// CephStorage represents flavors of Ceph Cluster Storage
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<CephClusterStatusStorage>,
    /// ClusterVersion represents the version of a Ceph Cluster
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<CephClusterStatusVersion>,
}

/// CephStatus is the details health of a Ceph Cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusCeph {
    /// Capacity is the capacity information of a Ceph Cluster
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capacity: Option<CephClusterStatusCephCapacity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details: Option<BTreeMap<String, CephClusterStatusCephDetails>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fsid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub health: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastChanged")]
    pub last_changed: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastChecked")]
    pub last_checked: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "previousHealth")]
    pub previous_health: Option<String>,
    /// CephDaemonsVersions show the current ceph version for different ceph daemons
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub versions: Option<CephClusterStatusCephVersions>,
}

/// Capacity is the capacity information of a Ceph Cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusCephCapacity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bytesAvailable")]
    pub bytes_available: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bytesTotal")]
    pub bytes_total: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bytesUsed")]
    pub bytes_used: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastUpdated")]
    pub last_updated: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusCephDetails {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severity: Option<String>,
}

/// CephDaemonsVersions show the current ceph version for different ceph daemons
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusCephVersions {
    /// CephFSMirror shows CephFSMirror Ceph version
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cephfs-mirror")]
    pub cephfs_mirror: Option<BTreeMap<String, i64>>,
    /// Mds shows Mds Ceph version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mds: Option<BTreeMap<String, i64>>,
    /// Mgr shows Mgr Ceph version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mgr: Option<BTreeMap<String, i64>>,
    /// Mon shows Mon Ceph version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mon: Option<BTreeMap<String, i64>>,
    /// Osd shows Osd Ceph version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub osd: Option<BTreeMap<String, i64>>,
    /// Overall shows overall Ceph version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overall: Option<BTreeMap<String, i64>>,
    /// RbdMirror shows RbdMirror Ceph version
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rbd-mirror")]
    pub rbd_mirror: Option<BTreeMap<String, i64>>,
    /// Rgw shows Rgw Ceph version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rgw: Option<BTreeMap<String, i64>>,
}

/// ClusterCephxStatus defines the cephx key rotation status of various daemons on the cephCluster resource
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusCephx {
    /// Admin shows the CephX key status for the client.admin key
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub admin: Option<CephClusterStatusCephxAdmin>,
    /// Ceph Exporter represents the cephx key rotation status of the ceph exporter daemon
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cephExporter")]
    pub ceph_exporter: Option<CephClusterStatusCephxCephExporter>,
    /// Crash Collector represents the cephx key rotation status of the crash collector daemon
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crashCollector")]
    pub crash_collector: Option<CephClusterStatusCephxCrashCollector>,
    /// CSI shows the CephX key status for Ceph-CSI components.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub csi: Option<CephClusterStatusCephxCsi>,
    /// Mgr represents the cephx key rotation status of the ceph manager daemon
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mgr: Option<CephClusterStatusCephxMgr>,
    /// Mon represents the CephX key status of the Monitor daemons
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mon: Option<CephClusterStatusCephxMon>,
    /// OSD shows the CephX key status of of OSDs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub osd: Option<CephClusterStatusCephxOsd>,
    /// RBDMirrorPeer represents the cephx key rotation status of the `rbd-mirror-peer` user
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rbdMirrorPeer")]
    pub rbd_mirror_peer: Option<CephClusterStatusCephxRbdMirrorPeer>,
}

/// Admin shows the CephX key status for the client.admin key
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusCephxAdmin {
    /// KeyCephVersion reports the Ceph version that created the current generation's keys. This is
    /// same string format as reported by `CephCluster.status.version.version` to allow them to be
    /// compared. E.g., `20.2.0-0`.
    /// For all newly-created resources, this field set to the version of Ceph that created the key.
    /// The special value "Uninitialized" indicates that keys are being created for the first time.
    /// An empty string indicates that the version is unknown, as expected in brownfield deployments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyCephVersion")]
    pub key_ceph_version: Option<String>,
    /// KeyGeneration represents the CephX key generation for the last successful reconcile.
    /// For all newly-created resources, this field is set to `1`.
    /// When keys are rotated due to any rotation policy, the generation is incremented or updated to
    /// the configured policy generation.
    /// Generation `0` indicates that keys existed prior to the implementation of key tracking.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyGeneration")]
    pub key_generation: Option<i32>,
}

/// Ceph Exporter represents the cephx key rotation status of the ceph exporter daemon
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusCephxCephExporter {
    /// KeyCephVersion reports the Ceph version that created the current generation's keys. This is
    /// same string format as reported by `CephCluster.status.version.version` to allow them to be
    /// compared. E.g., `20.2.0-0`.
    /// For all newly-created resources, this field set to the version of Ceph that created the key.
    /// The special value "Uninitialized" indicates that keys are being created for the first time.
    /// An empty string indicates that the version is unknown, as expected in brownfield deployments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyCephVersion")]
    pub key_ceph_version: Option<String>,
    /// KeyGeneration represents the CephX key generation for the last successful reconcile.
    /// For all newly-created resources, this field is set to `1`.
    /// When keys are rotated due to any rotation policy, the generation is incremented or updated to
    /// the configured policy generation.
    /// Generation `0` indicates that keys existed prior to the implementation of key tracking.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyGeneration")]
    pub key_generation: Option<i32>,
}

/// Crash Collector represents the cephx key rotation status of the crash collector daemon
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusCephxCrashCollector {
    /// KeyCephVersion reports the Ceph version that created the current generation's keys. This is
    /// same string format as reported by `CephCluster.status.version.version` to allow them to be
    /// compared. E.g., `20.2.0-0`.
    /// For all newly-created resources, this field set to the version of Ceph that created the key.
    /// The special value "Uninitialized" indicates that keys are being created for the first time.
    /// An empty string indicates that the version is unknown, as expected in brownfield deployments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyCephVersion")]
    pub key_ceph_version: Option<String>,
    /// KeyGeneration represents the CephX key generation for the last successful reconcile.
    /// For all newly-created resources, this field is set to `1`.
    /// When keys are rotated due to any rotation policy, the generation is incremented or updated to
    /// the configured policy generation.
    /// Generation `0` indicates that keys existed prior to the implementation of key tracking.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyGeneration")]
    pub key_generation: Option<i32>,
}

/// CSI shows the CephX key status for Ceph-CSI components.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusCephxCsi {
    /// KeyCephVersion reports the Ceph version that created the current generation's keys. This is
    /// same string format as reported by `CephCluster.status.version.version` to allow them to be
    /// compared. E.g., `20.2.0-0`.
    /// For all newly-created resources, this field set to the version of Ceph that created the key.
    /// The special value "Uninitialized" indicates that keys are being created for the first time.
    /// An empty string indicates that the version is unknown, as expected in brownfield deployments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyCephVersion")]
    pub key_ceph_version: Option<String>,
    /// KeyGeneration represents the CephX key generation for the last successful reconcile.
    /// For all newly-created resources, this field is set to `1`.
    /// When keys are rotated due to any rotation policy, the generation is incremented or updated to
    /// the configured policy generation.
    /// Generation `0` indicates that keys existed prior to the implementation of key tracking.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyGeneration")]
    pub key_generation: Option<i32>,
    /// PriorKeyCount reports the number of prior-generation CephX keys that remain active for the related component
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorKeyCount")]
    pub prior_key_count: Option<i64>,
}

/// Mgr represents the cephx key rotation status of the ceph manager daemon
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusCephxMgr {
    /// KeyCephVersion reports the Ceph version that created the current generation's keys. This is
    /// same string format as reported by `CephCluster.status.version.version` to allow them to be
    /// compared. E.g., `20.2.0-0`.
    /// For all newly-created resources, this field set to the version of Ceph that created the key.
    /// The special value "Uninitialized" indicates that keys are being created for the first time.
    /// An empty string indicates that the version is unknown, as expected in brownfield deployments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyCephVersion")]
    pub key_ceph_version: Option<String>,
    /// KeyGeneration represents the CephX key generation for the last successful reconcile.
    /// For all newly-created resources, this field is set to `1`.
    /// When keys are rotated due to any rotation policy, the generation is incremented or updated to
    /// the configured policy generation.
    /// Generation `0` indicates that keys existed prior to the implementation of key tracking.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyGeneration")]
    pub key_generation: Option<i32>,
}

/// Mon represents the CephX key status of the Monitor daemons
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusCephxMon {
    /// KeyCephVersion reports the Ceph version that created the current generation's keys. This is
    /// same string format as reported by `CephCluster.status.version.version` to allow them to be
    /// compared. E.g., `20.2.0-0`.
    /// For all newly-created resources, this field set to the version of Ceph that created the key.
    /// The special value "Uninitialized" indicates that keys are being created for the first time.
    /// An empty string indicates that the version is unknown, as expected in brownfield deployments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyCephVersion")]
    pub key_ceph_version: Option<String>,
    /// KeyGeneration represents the CephX key generation for the last successful reconcile.
    /// For all newly-created resources, this field is set to `1`.
    /// When keys are rotated due to any rotation policy, the generation is incremented or updated to
    /// the configured policy generation.
    /// Generation `0` indicates that keys existed prior to the implementation of key tracking.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyGeneration")]
    pub key_generation: Option<i32>,
}

/// OSD shows the CephX key status of of OSDs
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusCephxOsd {
    /// KeyCephVersion reports the Ceph version that created the current generation's keys. This is
    /// same string format as reported by `CephCluster.status.version.version` to allow them to be
    /// compared. E.g., `20.2.0-0`.
    /// For all newly-created resources, this field set to the version of Ceph that created the key.
    /// The special value "Uninitialized" indicates that keys are being created for the first time.
    /// An empty string indicates that the version is unknown, as expected in brownfield deployments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyCephVersion")]
    pub key_ceph_version: Option<String>,
    /// KeyGeneration represents the CephX key generation for the last successful reconcile.
    /// For all newly-created resources, this field is set to `1`.
    /// When keys are rotated due to any rotation policy, the generation is incremented or updated to
    /// the configured policy generation.
    /// Generation `0` indicates that keys existed prior to the implementation of key tracking.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyGeneration")]
    pub key_generation: Option<i32>,
}

/// RBDMirrorPeer represents the cephx key rotation status of the `rbd-mirror-peer` user
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusCephxRbdMirrorPeer {
    /// KeyCephVersion reports the Ceph version that created the current generation's keys. This is
    /// same string format as reported by `CephCluster.status.version.version` to allow them to be
    /// compared. E.g., `20.2.0-0`.
    /// For all newly-created resources, this field set to the version of Ceph that created the key.
    /// The special value "Uninitialized" indicates that keys are being created for the first time.
    /// An empty string indicates that the version is unknown, as expected in brownfield deployments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyCephVersion")]
    pub key_ceph_version: Option<String>,
    /// KeyGeneration represents the CephX key generation for the last successful reconcile.
    /// For all newly-created resources, this field is set to `1`.
    /// When keys are rotated due to any rotation policy, the generation is incremented or updated to
    /// the configured policy generation.
    /// Generation `0` indicates that keys existed prior to the implementation of key tracking.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyGeneration")]
    pub key_generation: Option<i32>,
}

/// CephStorage represents flavors of Ceph Cluster Storage
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusStorage {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deprecatedOSDs")]
    pub deprecated_os_ds: Option<BTreeMap<String, Vec<i64>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceClasses")]
    pub device_classes: Option<Vec<CephClusterStatusStorageDeviceClasses>>,
    /// OSDStatus represents OSD status of the ceph Cluster
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub osd: Option<CephClusterStatusStorageOsd>,
}

/// DeviceClasses represents device classes of a Ceph Cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusStorageDeviceClasses {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// OSDStatus represents OSD status of the ceph Cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusStorageOsd {
    /// MigrationStatus status represents the current status of any OSD migration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "migrationStatus")]
    pub migration_status: Option<CephClusterStatusStorageOsdMigrationStatus>,
    /// StoreType is a mapping between the OSD backend stores and number of OSDs using these stores
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storeType")]
    pub store_type: Option<BTreeMap<String, i64>>,
}

/// MigrationStatus status represents the current status of any OSD migration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusStorageOsdMigrationStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pending: Option<i64>,
}

/// ClusterVersion represents the version of a Ceph Cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephClusterStatusVersion {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

