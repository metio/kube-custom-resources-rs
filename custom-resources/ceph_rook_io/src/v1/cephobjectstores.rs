// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/rook/rook/ceph.rook.io/v1/cephobjectstores.yaml
// kopium version: 0.22.3

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ObjectStoreSpec represent the spec of a pool
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "ceph.rook.io", version = "v1", kind = "CephObjectStore", plural = "cephobjectstores")]
#[kube(namespaced)]
#[kube(status = "CephObjectStoreStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct CephObjectStoreSpec {
    /// The list of allowed namespaces in addition to the object store namespace
    /// where ceph object store users may be created. Specify "*" to allow all
    /// namespaces, otherwise list individual namespaces that are to be allowed.
    /// This is useful for applications that need object store credentials
    /// to be created in their own namespace, where neither OBCs nor COSI
    /// is being used to create buckets. The default is empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowUsersInNamespaces")]
    pub allow_users_in_namespaces: Option<Vec<String>>,
    /// The authentication configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth: Option<CephObjectStoreAuth>,
    /// The data pool settings
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataPool")]
    pub data_pool: Option<CephObjectStoreDataPool>,
    /// Set this realm as the default in Ceph. Only one realm should be default.
    /// Do not set this true on more than one CephObjectStore.
    /// This may not be set when zone is also specified; in this case, the realm
    /// referenced by the zone's zonegroup should configure defaulting behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRealm")]
    pub default_realm: Option<bool>,
    /// The rgw pod info
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway: Option<CephObjectStoreGateway>,
    /// The RGW health probes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    pub health_check: Option<CephObjectStoreHealthCheck>,
    /// Hosting settings for the object store.
    /// A common use case for hosting configuration is to inform Rook of endpoints that support DNS
    /// wildcards, which in turn allows virtual host-style bucket addressing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosting: Option<CephObjectStoreHosting>,
    /// The metadata pool settings
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataPool")]
    pub metadata_pool: Option<CephObjectStoreMetadataPool>,
    /// Preserve pools on object store deletion
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preservePoolsOnDelete")]
    pub preserve_pools_on_delete: Option<bool>,
    /// The protocol specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocols: Option<CephObjectStoreProtocols>,
    /// Security represents security settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<CephObjectStoreSecurity>,
    /// The pool information when configuring RADOS namespaces in existing pools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedPools")]
    pub shared_pools: Option<CephObjectStoreSharedPools>,
    /// The multisite info
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zone: Option<CephObjectStoreZone>,
}

/// The authentication configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreAuth {
    /// The spec for Keystone
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keystone: Option<CephObjectStoreAuthKeystone>,
}

/// The spec for Keystone
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreAuthKeystone {
    /// The roles requires to serve requests.
    #[serde(rename = "acceptedRoles")]
    pub accepted_roles: Vec<String>,
    /// Create new users in their own tenants of the same name. Possible values are true, false, swift and s3. The latter have the effect of splitting the identity space such that only the indicated protocol will use implicit tenants.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "implicitTenants")]
    pub implicit_tenants: Option<String>,
    /// The number of seconds between token revocation checks.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "revocationInterval")]
    pub revocation_interval: Option<i64>,
    /// The name of the secret containing the credentials for the service user account used by RGW. It has to be in the same namespace as the object store resource.
    #[serde(rename = "serviceUserSecretName")]
    pub service_user_secret_name: String,
    /// The maximum number of entries in each Keystone token cache.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenCacheSize")]
    pub token_cache_size: Option<i64>,
    /// The URL for the Keystone server.
    pub url: String,
}

/// The data pool settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPool {
    /// The application name to set on the pool. Only expected to be set for rgw pools.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub application: Option<String>,
    /// DEPRECATED: use Parameters instead, e.g., Parameters["compression_mode"] = "force"
    /// The inline compression mode in Bluestore OSD to set to (options are: none, passive, aggressive, force)
    /// Do NOT set a default value for kubebuilder as this will override the Parameters
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compressionMode")]
    pub compression_mode: Option<CephObjectStoreDataPoolCompressionMode>,
    /// The root of the crush hierarchy utilized by the pool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crushRoot")]
    pub crush_root: Option<String>,
    /// The device class the OSD should set to for use in the pool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceClass")]
    pub device_class: Option<String>,
    /// Allow rook operator to change the pool CRUSH tunables once the pool is created
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableCrushUpdates")]
    pub enable_crush_updates: Option<bool>,
    /// EnableRBDStats is used to enable gathering of statistics for all RBD images in the pool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRBDStats")]
    pub enable_rbd_stats: Option<bool>,
    /// The erasure code settings
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "erasureCoded")]
    pub erasure_coded: Option<CephObjectStoreDataPoolErasureCoded>,
    /// The failure domain: osd/host/(region or zone if available) - technically also any type in the crush map
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureDomain")]
    pub failure_domain: Option<String>,
    /// The mirroring settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirroring: Option<CephObjectStoreDataPoolMirroring>,
    /// Parameters is a list of properties to enable on a given pool
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<BTreeMap<String, String>>,
    /// The quota settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quotas: Option<CephObjectStoreDataPoolQuotas>,
    /// The replication settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicated: Option<CephObjectStoreDataPoolReplicated>,
    /// The mirroring statusCheck
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statusCheck")]
    pub status_check: Option<CephObjectStoreDataPoolStatusCheck>,
}

/// The data pool settings
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephObjectStoreDataPoolCompressionMode {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "passive")]
    Passive,
    #[serde(rename = "aggressive")]
    Aggressive,
    #[serde(rename = "force")]
    Force,
    #[serde(rename = "")]
    KopiumEmpty,
}

/// The erasure code settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolErasureCoded {
    /// The algorithm for erasure coding.
    /// If absent, defaults to the plugin specified in osd_pool_default_erasure_code_profile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub algorithm: Option<CephObjectStoreDataPoolErasureCodedAlgorithm>,
    /// Number of coding chunks per object in an erasure coded storage pool (required for erasure-coded pool type).
    /// This is the number of OSDs that can be lost simultaneously before data cannot be recovered.
    #[serde(rename = "codingChunks")]
    pub coding_chunks: i64,
    /// Number of data chunks per object in an erasure coded storage pool (required for erasure-coded pool type).
    /// The number of chunks required to recover an object when any single OSD is lost is the same
    /// as dataChunks so be aware that the larger the number of data chunks, the higher the cost of recovery.
    #[serde(rename = "dataChunks")]
    pub data_chunks: i64,
}

/// The erasure code settings
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephObjectStoreDataPoolErasureCodedAlgorithm {
    #[serde(rename = "isa")]
    Isa,
    #[serde(rename = "jerasure")]
    Jerasure,
}

/// The mirroring settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolMirroring {
    /// Enabled whether this pool is mirrored or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Mode is the mirroring mode: pool, image or init-only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<CephObjectStoreDataPoolMirroringMode>,
    /// Peers represents the peers spec
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub peers: Option<CephObjectStoreDataPoolMirroringPeers>,
    /// SnapshotSchedules is the scheduling of snapshot for mirrored images/pools
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snapshotSchedules")]
    pub snapshot_schedules: Option<Vec<CephObjectStoreDataPoolMirroringSnapshotSchedules>>,
}

/// The mirroring settings
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephObjectStoreDataPoolMirroringMode {
    #[serde(rename = "pool")]
    Pool,
    #[serde(rename = "image")]
    Image,
    #[serde(rename = "init-only")]
    InitOnly,
}

/// Peers represents the peers spec
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolMirroringPeers {
    /// SecretNames represents the Kubernetes Secret names to add rbd-mirror or cephfs-mirror peers
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretNames")]
    pub secret_names: Option<Vec<String>>,
}

/// SnapshotScheduleSpec represents the snapshot scheduling settings of a mirrored pool
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolMirroringSnapshotSchedules {
    /// Interval represent the periodicity of the snapshot.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Path is the path to snapshot, only valid for CephFS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// StartTime indicates when to start the snapshot
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
}

/// The quota settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolQuotas {
    /// MaxBytes represents the quota in bytes
    /// Deprecated in favor of MaxSize
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytes")]
    pub max_bytes: Option<i64>,
    /// MaxObjects represents the quota in objects
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxObjects")]
    pub max_objects: Option<i64>,
    /// MaxSize represents the quota in bytes as a string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSize")]
    pub max_size: Option<String>,
}

/// The replication settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolReplicated {
    /// HybridStorage represents hybrid storage tier settings
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hybridStorage")]
    pub hybrid_storage: Option<CephObjectStoreDataPoolReplicatedHybridStorage>,
    /// ReplicasPerFailureDomain the number of replica in the specified failure domain
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicasPerFailureDomain")]
    pub replicas_per_failure_domain: Option<i64>,
    /// RequireSafeReplicaSize if false allows you to set replica 1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireSafeReplicaSize")]
    pub require_safe_replica_size: Option<bool>,
    /// Size - Number of copies per object in a replicated storage pool, including the object itself (required for replicated pool type)
    pub size: i64,
    /// SubFailureDomain the name of the sub-failure domain
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subFailureDomain")]
    pub sub_failure_domain: Option<String>,
    /// TargetSizeRatio gives a hint (%) to Ceph in terms of expected consumption of the total cluster capacity
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSizeRatio")]
    pub target_size_ratio: Option<f64>,
}

/// HybridStorage represents hybrid storage tier settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolReplicatedHybridStorage {
    /// PrimaryDeviceClass represents high performance tier (for example SSD or NVME) for Primary OSD
    #[serde(rename = "primaryDeviceClass")]
    pub primary_device_class: String,
    /// SecondaryDeviceClass represents low performance tier (for example HDDs) for remaining OSDs
    #[serde(rename = "secondaryDeviceClass")]
    pub secondary_device_class: String,
}

/// The mirroring statusCheck
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolStatusCheck {
    /// HealthCheckSpec represents the health check of an object store bucket
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror: Option<CephObjectStoreDataPoolStatusCheckMirror>,
}

/// HealthCheckSpec represents the health check of an object store bucket
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolStatusCheckMirror {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Interval is the internal in second or minute for the health check to run like 60s for 60 seconds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
}

/// The rgw pod info
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGateway {
    /// AdditionalVolumeMounts allows additional volumes to be mounted to the RGW pod.
    /// The root directory for each additional volume mount is `/var/rgw`.
    /// Example: for an additional mount at subPath `ldap`, mounted from a secret that has key
    /// `bindpass.secret`, the file would reside at `/var/rgw/ldap/bindpass.secret`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalVolumeMounts")]
    pub additional_volume_mounts: Option<Vec<CephObjectStoreGatewayAdditionalVolumeMounts>>,
    /// The annotations-related configuration to add/set on each Pod related object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// The name of the secret that stores custom ca-bundle with root and intermediate certificates.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caBundleRef")]
    pub ca_bundle_ref: Option<String>,
    /// Whether rgw dashboard is enabled for the rgw daemon. If not set, the rgw dashboard will be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dashboardEnabled")]
    pub dashboard_enabled: Option<bool>,
    /// DisableMultisiteSyncTraffic, when true, prevents this object store's gateways from
    /// transmitting multisite replication data. Note that this value does not affect whether
    /// gateways receive multisite replication traffic: see ObjectZone.spec.customEndpoints for that.
    /// If false or unset, this object store's gateways will be able to transmit multisite
    /// replication data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableMultisiteSyncTraffic")]
    pub disable_multisite_sync_traffic: Option<bool>,
    /// ExternalRgwEndpoints points to external RGW endpoint(s). Multiple endpoints can be given, but
    /// for stability of ObjectBucketClaims, we highly recommend that users give only a single
    /// external RGW endpoint that is a load balancer that sends requests to the multiple RGWs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalRgwEndpoints")]
    pub external_rgw_endpoints: Option<Vec<CephObjectStoreGatewayExternalRgwEndpoints>>,
    /// Whether host networking is enabled for the rgw daemon. If not set, the network settings from the cluster CR will be applied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetwork")]
    pub host_network: Option<bool>,
    /// The number of pods in the rgw replicaset.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instances: Option<i32>,
    /// The labels-related configuration to add/set on each Pod related object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Enable enhanced operation Logs for S3 in a sidecar named ops-log
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "opsLogSidecar")]
    pub ops_log_sidecar: Option<CephObjectStoreGatewayOpsLogSidecar>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub placement: Option<CephObjectStoreGatewayPlacement>,
    /// The port the rgw service will be listening on (http)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// PriorityClassName sets priority classes on the rgw pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityClassName")]
    pub priority_class_name: Option<String>,
    /// ReadAffinity defines the RGW read affinity policy to optimize the read requests for the RGW clients
    /// Note: Only supported from Ceph Tentacle (v20)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readAffinity")]
    pub read_affinity: Option<CephObjectStoreGatewayReadAffinity>,
    /// The resource requirements for the rgw pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CephObjectStoreGatewayResources>,
    /// RgwCommandFlags sets Ceph RGW config values for the gateway clients that serve this object
    /// store. Values are modified at RGW startup, resulting in RGW pod restarts.
    /// This feature is intended for advanced users. It allows breaking configurations to be easily
    /// applied. Use with caution.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rgwCommandFlags")]
    pub rgw_command_flags: Option<BTreeMap<String, String>>,
    /// RgwConfig sets Ceph RGW config values for the gateway clients that serve this object store.
    /// Values are modified at runtime without RGW restart.
    /// This feature is intended for advanced users. It allows breaking configurations to be easily
    /// applied. Use with caution.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rgwConfig")]
    pub rgw_config: Option<BTreeMap<String, String>>,
    /// RgwConfigFromSecret works exactly like RgwConfig but takes config value from Secret Key reference.
    /// Values are modified at runtime without RGW restart.
    /// This feature is intended for advanced users. It allows breaking configurations to be easily
    /// applied. Use with caution.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rgwConfigFromSecret")]
    pub rgw_config_from_secret: Option<BTreeMap<String, CephObjectStoreGatewayRgwConfigFromSecret>>,
    /// The port the rgw service will be listening on (https)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securePort")]
    pub secure_port: Option<i32>,
    /// The configuration related to add/set on each rgw service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<CephObjectStoreGatewayService>,
    /// The name of the secret that stores the ssl certificate for secure rgw connections
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslCertificateRef")]
    pub ssl_certificate_ref: Option<String>,
}

/// AdditionalVolumeMount represents the source from where additional files in pod containers
/// should come from and what subdirectory they are made available in.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMounts {
    /// SubPath defines the sub-path (subdirectory) of the directory root where the volumeSource will
    /// be mounted. All files/keys in the volume source's volume will be mounted to the subdirectory.
    /// This is not the same as the Kubernetes `subPath` volume mount option.
    /// Each subPath definition must be unique and must not contain ':'.
    #[serde(rename = "subPath")]
    pub sub_path: String,
    #[serde(rename = "volumeSource")]
    pub volume_source: CephObjectStoreGatewayAdditionalVolumeMountsVolumeSource,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSource {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceEmptyDir>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceHostPath>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourcePersistentVolumeClaim>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjected>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceSecret>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceEmptyDir {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceHostPath {
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourcePersistentVolumeClaim {
    #[serde(rename = "claimName")]
    pub claim_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjected {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSources {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTrustBundle")]
    pub cluster_trust_bundle: Option<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesClusterTrustBundle>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesDownwardApi>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podCertificate")]
    pub pod_certificate: Option<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesPodCertificate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesServiceAccountToken>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesClusterTrustBundle {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signerName")]
    pub signer_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesDownwardApi {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesDownwardApiItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesDownwardApiItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesDownwardApiItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesDownwardApiItemsFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesPodCertificate {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateChainPath")]
    pub certificate_chain_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialBundlePath")]
    pub credential_bundle_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPath")]
    pub key_path: Option<String>,
    #[serde(rename = "keyType")]
    pub key_type: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxExpirationSeconds")]
    pub max_expiration_seconds: Option<i32>,
    #[serde(rename = "signerName")]
    pub signer_name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceProjectedSourcesServiceAccountToken {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceSecret {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayAdditionalVolumeMountsVolumeSourceSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

/// EndpointAddress is a tuple that describes a single IP address or host name. This is a subset of
/// Kubernetes's v1.EndpointAddress.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayExternalRgwEndpoints {
    /// The DNS-addressable Hostname of this endpoint. This field will be preferred over IP if both are given.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// The IP of this endpoint. As a legacy behavior, this supports being given a DNS-addressable hostname as well.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<String>,
}

/// Enable enhanced operation Logs for S3 in a sidecar named ops-log
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayOpsLogSidecar {
    /// Resources represents the way to specify resource requirements for the ops-log sidecar
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CephObjectStoreGatewayOpsLogSidecarResources>,
}

/// Resources represents the way to specify resource requirements for the ops-log sidecar
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayOpsLogSidecarResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This field depends on the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<CephObjectStoreGatewayOpsLogSidecarResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayOpsLogSidecarResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacement {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<CephObjectStoreGatewayPlacementNodeAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<CephObjectStoreGatewayPlacementPodAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<CephObjectStoreGatewayPlacementPodAntiAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<CephObjectStoreGatewayPlacementTolerations>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topologySpreadConstraints")]
    pub topology_spread_constraints: Option<Vec<CephObjectStoreGatewayPlacementTopologySpreadConstraints>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephObjectStoreGatewayPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<CephObjectStoreGatewayPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: CephObjectStoreGatewayPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<CephObjectStoreGatewayPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<CephObjectStoreGatewayPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<CephObjectStoreGatewayPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementTopologySpreadConstraints {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephObjectStoreGatewayPlacementTopologySpreadConstraintsLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(rename = "maxSkew")]
    pub max_skew: i32,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minDomains")]
    pub min_domains: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinityPolicy")]
    pub node_affinity_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeTaintsPolicy")]
    pub node_taints_policy: Option<String>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
    #[serde(rename = "whenUnsatisfiable")]
    pub when_unsatisfiable: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementTopologySpreadConstraintsLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementTopologySpreadConstraintsLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementTopologySpreadConstraintsLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ReadAffinity defines the RGW read affinity policy to optimize the read requests for the RGW clients
/// Note: Only supported from Ceph Tentacle (v20)
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CephObjectStoreGatewayReadAffinity {
    /// Type defines the RGW ReadAffinity type
    /// localize: read from the nearest OSD based on crush location of the RGW client
    /// balance: picks a random OSD from the PG's active set
    /// default: read from the primary OSD
    #[serde(rename = "type")]
    pub r#type: CephObjectStoreGatewayReadAffinityType,
}

/// ReadAffinity defines the RGW read affinity policy to optimize the read requests for the RGW clients
/// Note: Only supported from Ceph Tentacle (v20)
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephObjectStoreGatewayReadAffinityType {
    #[serde(rename = "localize")]
    Localize,
    #[serde(rename = "balance")]
    Balance,
    #[serde(rename = "default")]
    Default,
}

/// The resource requirements for the rgw pods
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This field depends on the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<CephObjectStoreGatewayResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// RgwConfigFromSecret works exactly like RgwConfig but takes config value from Secret Key reference.
/// Values are modified at runtime without RGW restart.
/// This feature is intended for advanced users. It allows breaking configurations to be easily
/// applied. Use with caution.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayRgwConfigFromSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The configuration related to add/set on each rgw service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayService {
    /// The annotations-related configuration to add/set on each rgw service.
    /// nullable
    /// optional
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
}

/// The RGW health probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheck {
    /// ProbeSpec is a wrapper around Probe so it can be enabled or disabled for a Ceph daemon
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<CephObjectStoreHealthCheckReadinessProbe>,
    /// ProbeSpec is a wrapper around Probe so it can be enabled or disabled for a Ceph daemon
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<CephObjectStoreHealthCheckStartupProbe>,
}

/// ProbeSpec is a wrapper around Probe so it can be enabled or disabled for a Ceph daemon
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckReadinessProbe {
    /// Disabled determines whether probe is disable or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Probe describes a health check to be performed against a container to determine whether it is
    /// alive or ready to receive traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probe: Option<CephObjectStoreHealthCheckReadinessProbeProbe>,
}

/// Probe describes a health check to be performed against a container to determine whether it is
/// alive or ready to receive traffic.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckReadinessProbeProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<CephObjectStoreHealthCheckReadinessProbeProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<CephObjectStoreHealthCheckReadinessProbeProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<CephObjectStoreHealthCheckReadinessProbeProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<CephObjectStoreHealthCheckReadinessProbeProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckReadinessProbeProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckReadinessProbeProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckReadinessProbeProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<CephObjectStoreHealthCheckReadinessProbeProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckReadinessProbeProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckReadinessProbeProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ProbeSpec is a wrapper around Probe so it can be enabled or disabled for a Ceph daemon
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckStartupProbe {
    /// Disabled determines whether probe is disable or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Probe describes a health check to be performed against a container to determine whether it is
    /// alive or ready to receive traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probe: Option<CephObjectStoreHealthCheckStartupProbeProbe>,
}

/// Probe describes a health check to be performed against a container to determine whether it is
/// alive or ready to receive traffic.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckStartupProbeProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<CephObjectStoreHealthCheckStartupProbeProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<CephObjectStoreHealthCheckStartupProbeProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<CephObjectStoreHealthCheckStartupProbeProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<CephObjectStoreHealthCheckStartupProbeProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckStartupProbeProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckStartupProbeProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckStartupProbeProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<CephObjectStoreHealthCheckStartupProbeProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckStartupProbeProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckStartupProbeProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// Hosting settings for the object store.
/// A common use case for hosting configuration is to inform Rook of endpoints that support DNS
/// wildcards, which in turn allows virtual host-style bucket addressing.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHosting {
    /// AdvertiseEndpoint is the default endpoint Rook will return for resources dependent on this
    /// object store. This endpoint will be returned to CephObjectStoreUsers, Object Bucket Claims,
    /// and COSI Buckets/Accesses.
    /// By default, Rook returns the endpoint for the object store's Kubernetes service using HTTPS
    /// with `gateway.securePort` if it is defined (otherwise, HTTP with `gateway.port`).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advertiseEndpoint")]
    pub advertise_endpoint: Option<CephObjectStoreHostingAdvertiseEndpoint>,
    /// A list of DNS host names on which object store gateways will accept client S3 connections.
    /// When specified, object store gateways will reject client S3 connections to hostnames that are
    /// not present in this list, so include all endpoints.
    /// The object store's advertiseEndpoint and Kubernetes service endpoint, plus CephObjectZone
    /// `customEndpoints` are automatically added to the list but may be set here again if desired.
    /// Each DNS name must be valid according RFC-1123.
    /// If the DNS name corresponds to an endpoint with DNS wildcard support, do not include the
    /// wildcard itself in the list of hostnames.
    /// E.g., use "mystore.example.com" instead of "*.mystore.example.com".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsNames")]
    pub dns_names: Option<Vec<String>>,
}

/// AdvertiseEndpoint is the default endpoint Rook will return for resources dependent on this
/// object store. This endpoint will be returned to CephObjectStoreUsers, Object Bucket Claims,
/// and COSI Buckets/Accesses.
/// By default, Rook returns the endpoint for the object store's Kubernetes service using HTTPS
/// with `gateway.securePort` if it is defined (otherwise, HTTP with `gateway.port`).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHostingAdvertiseEndpoint {
    /// DnsName is the DNS name (in RFC-1123 format) of the endpoint.
    /// If the DNS name corresponds to an endpoint with DNS wildcard support, do not include the
    /// wildcard itself in the list of hostnames.
    /// E.g., use "mystore.example.com" instead of "*.mystore.example.com".
    #[serde(rename = "dnsName")]
    pub dns_name: String,
    /// Port is the port on which S3 connections can be made for this endpoint.
    pub port: i32,
    /// UseTls defines whether the endpoint uses TLS (HTTPS) or not (HTTP).
    #[serde(rename = "useTls")]
    pub use_tls: bool,
}

/// The metadata pool settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPool {
    /// The application name to set on the pool. Only expected to be set for rgw pools.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub application: Option<String>,
    /// DEPRECATED: use Parameters instead, e.g., Parameters["compression_mode"] = "force"
    /// The inline compression mode in Bluestore OSD to set to (options are: none, passive, aggressive, force)
    /// Do NOT set a default value for kubebuilder as this will override the Parameters
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compressionMode")]
    pub compression_mode: Option<CephObjectStoreMetadataPoolCompressionMode>,
    /// The root of the crush hierarchy utilized by the pool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crushRoot")]
    pub crush_root: Option<String>,
    /// The device class the OSD should set to for use in the pool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceClass")]
    pub device_class: Option<String>,
    /// Allow rook operator to change the pool CRUSH tunables once the pool is created
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableCrushUpdates")]
    pub enable_crush_updates: Option<bool>,
    /// EnableRBDStats is used to enable gathering of statistics for all RBD images in the pool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRBDStats")]
    pub enable_rbd_stats: Option<bool>,
    /// The erasure code settings
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "erasureCoded")]
    pub erasure_coded: Option<CephObjectStoreMetadataPoolErasureCoded>,
    /// The failure domain: osd/host/(region or zone if available) - technically also any type in the crush map
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureDomain")]
    pub failure_domain: Option<String>,
    /// The mirroring settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirroring: Option<CephObjectStoreMetadataPoolMirroring>,
    /// Parameters is a list of properties to enable on a given pool
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<BTreeMap<String, String>>,
    /// The quota settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quotas: Option<CephObjectStoreMetadataPoolQuotas>,
    /// The replication settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicated: Option<CephObjectStoreMetadataPoolReplicated>,
    /// The mirroring statusCheck
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statusCheck")]
    pub status_check: Option<CephObjectStoreMetadataPoolStatusCheck>,
}

/// The metadata pool settings
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephObjectStoreMetadataPoolCompressionMode {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "passive")]
    Passive,
    #[serde(rename = "aggressive")]
    Aggressive,
    #[serde(rename = "force")]
    Force,
    #[serde(rename = "")]
    KopiumEmpty,
}

/// The erasure code settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolErasureCoded {
    /// The algorithm for erasure coding.
    /// If absent, defaults to the plugin specified in osd_pool_default_erasure_code_profile.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub algorithm: Option<CephObjectStoreMetadataPoolErasureCodedAlgorithm>,
    /// Number of coding chunks per object in an erasure coded storage pool (required for erasure-coded pool type).
    /// This is the number of OSDs that can be lost simultaneously before data cannot be recovered.
    #[serde(rename = "codingChunks")]
    pub coding_chunks: i64,
    /// Number of data chunks per object in an erasure coded storage pool (required for erasure-coded pool type).
    /// The number of chunks required to recover an object when any single OSD is lost is the same
    /// as dataChunks so be aware that the larger the number of data chunks, the higher the cost of recovery.
    #[serde(rename = "dataChunks")]
    pub data_chunks: i64,
}

/// The erasure code settings
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephObjectStoreMetadataPoolErasureCodedAlgorithm {
    #[serde(rename = "isa")]
    Isa,
    #[serde(rename = "jerasure")]
    Jerasure,
}

/// The mirroring settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolMirroring {
    /// Enabled whether this pool is mirrored or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Mode is the mirroring mode: pool, image or init-only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<CephObjectStoreMetadataPoolMirroringMode>,
    /// Peers represents the peers spec
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub peers: Option<CephObjectStoreMetadataPoolMirroringPeers>,
    /// SnapshotSchedules is the scheduling of snapshot for mirrored images/pools
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snapshotSchedules")]
    pub snapshot_schedules: Option<Vec<CephObjectStoreMetadataPoolMirroringSnapshotSchedules>>,
}

/// The mirroring settings
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephObjectStoreMetadataPoolMirroringMode {
    #[serde(rename = "pool")]
    Pool,
    #[serde(rename = "image")]
    Image,
    #[serde(rename = "init-only")]
    InitOnly,
}

/// Peers represents the peers spec
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolMirroringPeers {
    /// SecretNames represents the Kubernetes Secret names to add rbd-mirror or cephfs-mirror peers
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretNames")]
    pub secret_names: Option<Vec<String>>,
}

/// SnapshotScheduleSpec represents the snapshot scheduling settings of a mirrored pool
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolMirroringSnapshotSchedules {
    /// Interval represent the periodicity of the snapshot.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Path is the path to snapshot, only valid for CephFS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// StartTime indicates when to start the snapshot
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
}

/// The quota settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolQuotas {
    /// MaxBytes represents the quota in bytes
    /// Deprecated in favor of MaxSize
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytes")]
    pub max_bytes: Option<i64>,
    /// MaxObjects represents the quota in objects
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxObjects")]
    pub max_objects: Option<i64>,
    /// MaxSize represents the quota in bytes as a string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSize")]
    pub max_size: Option<String>,
}

/// The replication settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolReplicated {
    /// HybridStorage represents hybrid storage tier settings
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hybridStorage")]
    pub hybrid_storage: Option<CephObjectStoreMetadataPoolReplicatedHybridStorage>,
    /// ReplicasPerFailureDomain the number of replica in the specified failure domain
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicasPerFailureDomain")]
    pub replicas_per_failure_domain: Option<i64>,
    /// RequireSafeReplicaSize if false allows you to set replica 1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireSafeReplicaSize")]
    pub require_safe_replica_size: Option<bool>,
    /// Size - Number of copies per object in a replicated storage pool, including the object itself (required for replicated pool type)
    pub size: i64,
    /// SubFailureDomain the name of the sub-failure domain
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subFailureDomain")]
    pub sub_failure_domain: Option<String>,
    /// TargetSizeRatio gives a hint (%) to Ceph in terms of expected consumption of the total cluster capacity
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSizeRatio")]
    pub target_size_ratio: Option<f64>,
}

/// HybridStorage represents hybrid storage tier settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolReplicatedHybridStorage {
    /// PrimaryDeviceClass represents high performance tier (for example SSD or NVME) for Primary OSD
    #[serde(rename = "primaryDeviceClass")]
    pub primary_device_class: String,
    /// SecondaryDeviceClass represents low performance tier (for example HDDs) for remaining OSDs
    #[serde(rename = "secondaryDeviceClass")]
    pub secondary_device_class: String,
}

/// The mirroring statusCheck
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolStatusCheck {
    /// HealthCheckSpec represents the health check of an object store bucket
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror: Option<CephObjectStoreMetadataPoolStatusCheckMirror>,
}

/// HealthCheckSpec represents the health check of an object store bucket
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolStatusCheckMirror {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Interval is the internal in second or minute for the health check to run like 60s for 60 seconds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
}

/// The protocol specification
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreProtocols {
    /// Represents RGW 'rgw_enable_apis' config option. See: <https://docs.ceph.com/en/reef/radosgw/config-ref/#confval-rgw_enable_apis>
    /// If no value provided then all APIs will be enabled: s3, s3website, swift, swift_auth, admin, sts, iam, notifications
    /// If enabled APIs are set, all remaining APIs will be disabled.
    /// This option overrides S3.Enabled value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableAPIs")]
    pub enable_ap_is: Option<Vec<String>>,
    /// The spec for S3
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<CephObjectStoreProtocolsS3>,
    /// The spec for Swift
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub swift: Option<CephObjectStoreProtocolsSwift>,
}

/// The spec for S3
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreProtocolsS3 {
    /// Whether to use Keystone for authentication. This option maps directly to the rgw_s3_auth_use_keystone option. Enabling it allows generating S3 credentials via an OpenStack API call, see the docs. If not given, the defaults of the corresponding RGW option apply.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authUseKeystone")]
    pub auth_use_keystone: Option<bool>,
    /// Deprecated: use protocol.enableAPIs instead.
    /// Whether to enable S3. This defaults to true (even if protocols.s3 is not present in the CRD). This maintains backwards compatibility  by default S3 is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The spec for Swift
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreProtocolsSwift {
    /// Whether or not the Swift account name should be included in the Swift API URL. If set to false (the default), then the Swift API will listen on a URL formed like <http://host:port/<rgw_swift_url_prefix>/v1.> If set to true, the Swift API URL will be <http://host:port/<rgw_swift_url_prefix>/v1/AUTH_<account_name>.> You must set this option to true (and update the Keystone service catalog) if you want radosgw to support publicly-readable containers and temporary URLs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accountInUrl")]
    pub account_in_url: Option<bool>,
    /// The URL prefix for the Swift API, to distinguish it from the S3 API endpoint. The default is swift, which makes the Swift API available at the URL <http://host:port/swift/v1> (or <http://host:port/swift/v1/AUTH_%(tenant_id)s> if rgw swift account in url is enabled).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlPrefix")]
    pub url_prefix: Option<String>,
    /// Enables the Object Versioning of OpenStack Object Storage API. This allows clients to put the X-Versions-Location attribute on containers that should be versioned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "versioningEnabled")]
    pub versioning_enabled: Option<bool>,
}

/// Security represents security settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreSecurity {
    /// KeyRotation defines options for Key Rotation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyRotation")]
    pub key_rotation: Option<CephObjectStoreSecurityKeyRotation>,
    /// KeyManagementService is the main Key Management option
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kms: Option<CephObjectStoreSecurityKms>,
    /// The settings for supporting AWS-SSE:S3 with RGW
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<CephObjectStoreSecurityS3>,
}

/// KeyRotation defines options for Key Rotation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreSecurityKeyRotation {
    /// Enabled represents whether the key rotation is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Schedule represents the cron schedule for key rotation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schedule: Option<String>,
}

/// KeyManagementService is the main Key Management option
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreSecurityKms {
    /// ConnectionDetails contains the KMS connection details (address, port etc)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionDetails")]
    pub connection_details: Option<BTreeMap<String, String>>,
    /// TokenSecretName is the kubernetes secret containing the KMS token
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenSecretName")]
    pub token_secret_name: Option<String>,
}

/// The settings for supporting AWS-SSE:S3 with RGW
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreSecurityS3 {
    /// ConnectionDetails contains the KMS connection details (address, port etc)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionDetails")]
    pub connection_details: Option<BTreeMap<String, String>>,
    /// TokenSecretName is the kubernetes secret containing the KMS token
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenSecretName")]
    pub token_secret_name: Option<String>,
}

/// The pool information when configuring RADOS namespaces in existing pools.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreSharedPools {
    /// The data pool used for creating RADOS namespaces in the object store
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataPoolName")]
    pub data_pool_name: Option<String>,
    /// The metadata pool used for creating RADOS namespaces in the object store
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataPoolName")]
    pub metadata_pool_name: Option<String>,
    /// PoolPlacements control which Pools are associated with a particular RGW bucket.
    /// Once PoolPlacements are defined, RGW client will be able to associate pool
    /// with ObjectStore bucket by providing "<LocationConstraint>" during s3 bucket creation
    /// or "X-Storage-Policy" header during swift container creation.
    /// See: <https://docs.ceph.com/en/latest/radosgw/placement/#placement-targets>
    /// PoolPlacement with name: "default" will be used as a default pool if no option
    /// is provided during bucket creation.
    /// If default placement is not provided, spec.sharedPools.dataPoolName and spec.sharedPools.MetadataPoolName will be used as default pools.
    /// If spec.sharedPools are also empty, then RGW pools (spec.dataPool and spec.metadataPool) will be used as defaults.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "poolPlacements")]
    pub pool_placements: Option<Vec<CephObjectStoreSharedPoolsPoolPlacements>>,
    /// Whether the RADOS namespaces should be preserved on deletion of the object store
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preserveRadosNamespaceDataOnDelete")]
    pub preserve_rados_namespace_data_on_delete: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreSharedPoolsPoolPlacements {
    /// The data pool used to store ObjectStore data that cannot use erasure coding (ex: multi-part uploads).
    /// If dataPoolName is not erasure coded, then there is no need for dataNonECPoolName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataNonECPoolName")]
    pub data_non_ec_pool_name: Option<String>,
    /// The data pool used to store ObjectStore objects data.
    #[serde(rename = "dataPoolName")]
    pub data_pool_name: String,
    /// Sets given placement as default. Only one placement in the list can be marked as default.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<bool>,
    /// The metadata pool used to store ObjectStore bucket index.
    #[serde(rename = "metadataPoolName")]
    pub metadata_pool_name: String,
    /// Pool placement name. Name can be arbitrary. Placement with name "default" will be used as default.
    pub name: String,
    /// StorageClasses can be selected by user to override dataPoolName during object creation.
    /// Each placement has default STANDARD StorageClass pointing to dataPoolName.
    /// This list allows defining additional StorageClasses on top of default STANDARD storage class.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClasses")]
    pub storage_classes: Option<Vec<CephObjectStoreSharedPoolsPoolPlacementsStorageClasses>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreSharedPoolsPoolPlacementsStorageClasses {
    /// DataPoolName is the data pool used to store ObjectStore objects data.
    #[serde(rename = "dataPoolName")]
    pub data_pool_name: String,
    /// Name is the StorageClass name. Ceph allows arbitrary name for StorageClasses,
    /// however most clients/libs insist on AWS names so it is recommended to use
    /// one of the valid x-amz-storage-class values for better compatibility:
    /// REDUCED_REDUNDANCY | STANDARD_IA | ONEZONE_IA | INTELLIGENT_TIERING | GLACIER | DEEP_ARCHIVE | OUTPOSTS | GLACIER_IR | SNOW | EXPRESS_ONEZONE
    /// See AWS docs: <https://aws.amazon.com/de/s3/storage-classes/>
    pub name: String,
}

/// The multisite info
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreZone {
    /// CephObjectStoreZone name this CephObjectStore is part of
    pub name: String,
}

/// ObjectStoreStatus represents the status of a Ceph Object Store resource
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cephx: Option<CephObjectStoreStatusCephx>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoints: Option<CephObjectStoreStatusEndpoints>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub info: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// ObservedGeneration is the latest generation observed by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// ConditionType represent a resource's status
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreStatusCephx {
    /// Daemon shows the CephX key status for local Ceph daemons associated with this resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub daemon: Option<CephObjectStoreStatusCephxDaemon>,
}

/// Daemon shows the CephX key status for local Ceph daemons associated with this resources.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreStatusCephxDaemon {
    /// KeyCephVersion reports the Ceph version that created the current generation's keys. This is
    /// same string format as reported by `CephCluster.status.version.version` to allow them to be
    /// compared. E.g., `20.2.0-0`.
    /// For all newly-created resources, this field set to the version of Ceph that created the key.
    /// The special value "Uninitialized" indicates that keys are being created for the first time.
    /// An empty string indicates that the version is unknown, as expected in brownfield deployments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyCephVersion")]
    pub key_ceph_version: Option<String>,
    /// KeyGeneration represents the CephX key generation for the last successful reconcile.
    /// For all newly-created resources, this field is set to `1`.
    /// When keys are rotated due to any rotation policy, the generation is incremented or updated to
    /// the configured policy generation.
    /// Generation `0` indicates that keys existed prior to the implementation of key tracking.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyGeneration")]
    pub key_generation: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreStatusEndpoints {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secure: Option<Vec<String>>,
}

