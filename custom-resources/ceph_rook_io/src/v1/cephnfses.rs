// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/rook/rook/ceph.rook.io/v1/cephnfses.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// NFSGaneshaSpec represents the spec of an nfs ganesha server
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "ceph.rook.io", version = "v1", kind = "CephNFS", plural = "cephnfses")]
#[kube(namespaced)]
#[kube(status = "CephNfsStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct CephNfsSpec {
    /// RADOS is the Ganesha RADOS specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rados: Option<CephNfsRados>,
    /// Security allows specifying security configurations for the NFS cluster
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<CephNfsSecurity>,
    /// Server is the Ganesha Server specification
    pub server: CephNfsServer,
}

/// RADOS is the Ganesha RADOS specification
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsRados {
    /// The namespace inside the Ceph pool (set by 'pool') where shared NFS-Ganesha config is stored.
    /// This setting is deprecated as it is internally set to the name of the CephNFS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// The Ceph pool used store the shared configuration for NFS-Ganesha daemons.
    /// This setting is deprecated, as it is internally required to be ".nfs".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pool: Option<String>,
}

/// Security allows specifying security configurations for the NFS cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurity {
    /// Kerberos configures NFS-Ganesha to secure NFS client connections with Kerberos.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kerberos: Option<CephNfsSecurityKerberos>,
    /// SSSD enables integration with System Security Services Daemon (SSSD). SSSD can be used to
    /// provide user ID mapping from a number of sources. See <https://sssd.io> for more information
    /// about the SSSD project.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sssd: Option<CephNfsSecuritySssd>,
}

/// Kerberos configures NFS-Ganesha to secure NFS client connections with Kerberos.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberos {
    /// ConfigFiles defines where the Kerberos configuration should be sourced from. Config files
    /// will be placed into the `/etc/krb5.conf.rook/` directory.
    /// 
    /// If this is left empty, Rook will not add any files. This allows you to manage the files
    /// yourself however you wish. For example, you may build them into your custom Ceph container
    /// image or use the Vault agent injector to securely add the files via annotations on the
    /// CephNFS spec (passed to the NFS server pods).
    /// 
    /// Rook configures Kerberos to log to stderr. We suggest removing logging sections from config
    /// files to avoid consuming unnecessary disk space from logging to files.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configFiles")]
    pub config_files: Option<CephNfsSecurityKerberosConfigFiles>,
    /// DomainName should be set to the Kerberos Realm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainName")]
    pub domain_name: Option<String>,
    /// KeytabFile defines where the Kerberos keytab should be sourced from. The keytab file will be
    /// placed into `/etc/krb5.keytab`. If this is left empty, Rook will not add the file.
    /// This allows you to manage the `krb5.keytab` file yourself however you wish. For example, you
    /// may build it into your custom Ceph container image or use the Vault agent injector to
    /// securely add the file via annotations on the CephNFS spec (passed to the NFS server pods).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keytabFile")]
    pub keytab_file: Option<CephNfsSecurityKerberosKeytabFile>,
    /// PrincipalName corresponds directly to NFS-Ganesha's NFS_KRB5:PrincipalName config. In
    /// practice, this is the service prefix of the principal name. The default is "nfs".
    /// This value is combined with (a) the namespace and name of the CephNFS (with a hyphen between)
    /// and (b) the Realm configured in the user-provided krb5.conf to determine the full principal
    /// name: <principalName>/<namespace>-<name>@<realm>. e.g., nfs/rook-ceph-my-nfs@example.net.
    /// See <https://github.com/nfs-ganesha/nfs-ganesha/wiki/RPCSEC_GSS> for more detail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "principalName")]
    pub principal_name: Option<String>,
}

/// ConfigFiles defines where the Kerberos configuration should be sourced from. Config files
/// will be placed into the `/etc/krb5.conf.rook/` directory.
/// 
/// If this is left empty, Rook will not add any files. This allows you to manage the files
/// yourself however you wish. For example, you may build them into your custom Ceph container
/// image or use the Vault agent injector to securely add the files via annotations on the
/// CephNFS spec (passed to the NFS server pods).
/// 
/// Rook configures Kerberos to log to stderr. We suggest removing logging sections from config
/// files to avoid consuming unnecessary disk space from logging to files.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFiles {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeSource")]
    pub volume_source: Option<CephNfsSecurityKerberosConfigFilesVolumeSource>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSource {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephNfsSecurityKerberosConfigFilesVolumeSourceConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<CephNfsSecurityKerberosConfigFilesVolumeSourceEmptyDir>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<CephNfsSecurityKerberosConfigFilesVolumeSourceHostPath>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<CephNfsSecurityKerberosConfigFilesVolumeSourcePersistentVolumeClaim>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<CephNfsSecurityKerberosConfigFilesVolumeSourceProjected>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephNfsSecurityKerberosConfigFilesVolumeSourceSecret>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecurityKerberosConfigFilesVolumeSourceConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceEmptyDir {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceHostPath {
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourcePersistentVolumeClaim {
    #[serde(rename = "claimName")]
    pub claim_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceProjected {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSources {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTrustBundle")]
    pub cluster_trust_bundle: Option<CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesClusterTrustBundle>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesDownwardApi>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podCertificate")]
    pub pod_certificate: Option<CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesPodCertificate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesServiceAccountToken>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesClusterTrustBundle {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signerName")]
    pub signer_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesDownwardApi {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesDownwardApiItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesDownwardApiItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesDownwardApiItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesDownwardApiItemsFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesPodCertificate {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateChainPath")]
    pub certificate_chain_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialBundlePath")]
    pub credential_bundle_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPath")]
    pub key_path: Option<String>,
    #[serde(rename = "keyType")]
    pub key_type: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxExpirationSeconds")]
    pub max_expiration_seconds: Option<i32>,
    #[serde(rename = "signerName")]
    pub signer_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userAnnotations")]
    pub user_annotations: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceProjectedSourcesServiceAccountToken {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceSecret {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecurityKerberosConfigFilesVolumeSourceSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosConfigFilesVolumeSourceSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

/// KeytabFile defines where the Kerberos keytab should be sourced from. The keytab file will be
/// placed into `/etc/krb5.keytab`. If this is left empty, Rook will not add the file.
/// This allows you to manage the `krb5.keytab` file yourself however you wish. For example, you
/// may build it into your custom Ceph container image or use the Vault agent injector to
/// securely add the file via annotations on the CephNFS spec (passed to the NFS server pods).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFile {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeSource")]
    pub volume_source: Option<CephNfsSecurityKerberosKeytabFileVolumeSource>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSource {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephNfsSecurityKerberosKeytabFileVolumeSourceConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<CephNfsSecurityKerberosKeytabFileVolumeSourceEmptyDir>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<CephNfsSecurityKerberosKeytabFileVolumeSourceHostPath>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<CephNfsSecurityKerberosKeytabFileVolumeSourcePersistentVolumeClaim>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<CephNfsSecurityKerberosKeytabFileVolumeSourceProjected>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephNfsSecurityKerberosKeytabFileVolumeSourceSecret>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecurityKerberosKeytabFileVolumeSourceConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceEmptyDir {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceHostPath {
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourcePersistentVolumeClaim {
    #[serde(rename = "claimName")]
    pub claim_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceProjected {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSources {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTrustBundle")]
    pub cluster_trust_bundle: Option<CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesClusterTrustBundle>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesDownwardApi>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podCertificate")]
    pub pod_certificate: Option<CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesPodCertificate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesServiceAccountToken>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesClusterTrustBundle {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signerName")]
    pub signer_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesDownwardApi {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesDownwardApiItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesDownwardApiItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesDownwardApiItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesDownwardApiItemsFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesPodCertificate {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateChainPath")]
    pub certificate_chain_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialBundlePath")]
    pub credential_bundle_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPath")]
    pub key_path: Option<String>,
    #[serde(rename = "keyType")]
    pub key_type: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxExpirationSeconds")]
    pub max_expiration_seconds: Option<i32>,
    #[serde(rename = "signerName")]
    pub signer_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userAnnotations")]
    pub user_annotations: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceProjectedSourcesServiceAccountToken {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceSecret {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecurityKerberosKeytabFileVolumeSourceSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecurityKerberosKeytabFileVolumeSourceSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

/// SSSD enables integration with System Security Services Daemon (SSSD). SSSD can be used to
/// provide user ID mapping from a number of sources. See <https://sssd.io> for more information
/// about the SSSD project.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssd {
    /// Sidecar tells Rook to run SSSD in a sidecar alongside the NFS-Ganesha server in each NFS pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sidecar: Option<CephNfsSecuritySssdSidecar>,
}

/// Sidecar tells Rook to run SSSD in a sidecar alongside the NFS-Ganesha server in each NFS pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecar {
    /// AdditionalFiles defines any number of additional files that should be mounted into the SSSD
    /// sidecar with a directory root of `/etc/sssd/rook-additional/`.
    /// These files may be referenced by the sssd.conf config file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalFiles")]
    pub additional_files: Option<Vec<CephNfsSecuritySssdSidecarAdditionalFiles>>,
    /// DebugLevel sets the debug level for SSSD. If unset or set to 0, Rook does nothing. Otherwise,
    /// this may be a value between 1 and 10. See SSSD docs for more info:
    /// <https://sssd.io/troubleshooting/basics.html#sssd-debug-logs>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "debugLevel")]
    pub debug_level: Option<i64>,
    /// Image defines the container image that should be used for the SSSD sidecar.
    pub image: String,
    /// Resources allow specifying resource requests/limits on the SSSD sidecar container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CephNfsSecuritySssdSidecarResources>,
    /// SSSDConfigFile defines where the SSSD configuration should be sourced from. The config file
    /// will be placed into `/etc/sssd/sssd.conf`. If this is left empty, Rook will not add the file.
    /// This allows you to manage the `sssd.conf` file yourself however you wish. For example, you
    /// may build it into your custom Ceph container image or use the Vault agent injector to
    /// securely add the file via annotations on the CephNFS spec (passed to the NFS server pods).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sssdConfigFile")]
    pub sssd_config_file: Option<CephNfsSecuritySssdSidecarSssdConfigFile>,
}

/// AdditionalVolumeMount represents the source from where additional files in pod containers
/// should come from and what subdirectory they are made available in.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFiles {
    /// SubPath defines the sub-path (subdirectory) of the directory root where the volumeSource will
    /// be mounted. All files/keys in the volume source's volume will be mounted to the subdirectory.
    /// This is not the same as the Kubernetes `subPath` volume mount option.
    /// Each subPath definition must be unique and must not contain ':'.
    #[serde(rename = "subPath")]
    pub sub_path: String,
    #[serde(rename = "volumeSource")]
    pub volume_source: CephNfsSecuritySssdSidecarAdditionalFilesVolumeSource,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSource {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceEmptyDir>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceHostPath>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourcePersistentVolumeClaim>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjected>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceSecret>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceEmptyDir {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceHostPath {
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourcePersistentVolumeClaim {
    #[serde(rename = "claimName")]
    pub claim_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjected {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSources {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTrustBundle")]
    pub cluster_trust_bundle: Option<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesClusterTrustBundle>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesDownwardApi>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podCertificate")]
    pub pod_certificate: Option<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesPodCertificate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesServiceAccountToken>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesClusterTrustBundle {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signerName")]
    pub signer_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesDownwardApi {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesDownwardApiItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesDownwardApiItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesDownwardApiItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesDownwardApiItemsFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesPodCertificate {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateChainPath")]
    pub certificate_chain_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialBundlePath")]
    pub credential_bundle_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPath")]
    pub key_path: Option<String>,
    #[serde(rename = "keyType")]
    pub key_type: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxExpirationSeconds")]
    pub max_expiration_seconds: Option<i32>,
    #[serde(rename = "signerName")]
    pub signer_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userAnnotations")]
    pub user_annotations: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesServiceAccountToken {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceSecret {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarAdditionalFilesVolumeSourceSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

/// Resources allow specifying resource requests/limits on the SSSD sidecar container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This field depends on the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<CephNfsSecuritySssdSidecarResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// SSSDConfigFile defines where the SSSD configuration should be sourced from. The config file
/// will be placed into `/etc/sssd/sssd.conf`. If this is left empty, Rook will not add the file.
/// This allows you to manage the `sssd.conf` file yourself however you wish. For example, you
/// may build it into your custom Ceph container image or use the Vault agent injector to
/// securely add the file via annotations on the CephNFS spec (passed to the NFS server pods).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFile {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeSource")]
    pub volume_source: Option<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSource>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSource {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceEmptyDir>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceHostPath>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourcePersistentVolumeClaim>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjected>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceSecret>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceEmptyDir {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceHostPath {
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourcePersistentVolumeClaim {
    #[serde(rename = "claimName")]
    pub claim_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjected {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSources {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTrustBundle")]
    pub cluster_trust_bundle: Option<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesClusterTrustBundle>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesDownwardApi>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podCertificate")]
    pub pod_certificate: Option<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesPodCertificate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesServiceAccountToken>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesClusterTrustBundle {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signerName")]
    pub signer_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesDownwardApi {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesDownwardApiItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesDownwardApiItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesDownwardApiItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesDownwardApiItemsFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesPodCertificate {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateChainPath")]
    pub certificate_chain_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialBundlePath")]
    pub credential_bundle_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPath")]
    pub key_path: Option<String>,
    #[serde(rename = "keyType")]
    pub key_type: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxExpirationSeconds")]
    pub max_expiration_seconds: Option<i32>,
    #[serde(rename = "signerName")]
    pub signer_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userAnnotations")]
    pub user_annotations: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesServiceAccountToken {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceSecret {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsSecuritySssdSidecarSssdConfigFileVolumeSourceSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

/// Server is the Ganesha Server specification
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServer {
    /// The number of active Ganesha servers
    pub active: i64,
    /// The annotations-related configuration to add/set on each Pod related object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Whether host networking is enabled for the Ganesha server. If not set, the network settings from the cluster CR will be applied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetwork")]
    pub host_network: Option<bool>,
    /// Image is the container image used to launch the Ceph NFS (Ganesha) daemon(s).
    /// The image must include the NFS Ganesha binaries, such as are included with the official Ceph releases. E.g.: quay.io/ceph/ceph:<tag>
    /// If not specified, the Ceph image defined in the CephCluster is used.
    /// Overriding the CephCluster defined image is not normally necessary when using the official Ceph images.
    /// The image must contain the NFS Ganesha and dbus packages.
    /// If the SSSD sidecar is enabled, the image must also contain the sssd-client package.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// ImagePullPolicy describes a policy for if/when to pull a container image
    /// One of Always, Never, IfNotPresent.
    /// This field only has effect if an image is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<CephNfsServerImagePullPolicy>,
    /// The labels-related configuration to add/set on each Pod related object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// A liveness-probe to verify that Ganesha server has valid run-time state.
    /// If LivenessProbe.Disabled is false and LivenessProbe.Probe is nil uses default probe.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<CephNfsServerLivenessProbe>,
    /// LogLevel set logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub placement: Option<CephNfsServerPlacement>,
    /// PriorityClassName sets the priority class on the pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityClassName")]
    pub priority_class_name: Option<String>,
    /// Resources set resource requests and limits
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CephNfsServerResources>,
}

/// Server is the Ganesha Server specification
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephNfsServerImagePullPolicy {
    IfNotPresent,
    Always,
    Never,
    #[serde(rename = "")]
    KopiumEmpty,
}

/// A liveness-probe to verify that Ganesha server has valid run-time state.
/// If LivenessProbe.Disabled is false and LivenessProbe.Probe is nil uses default probe.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerLivenessProbe {
    /// Disabled determines whether probe is disable or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Probe describes a health check to be performed against a container to determine whether it is
    /// alive or ready to receive traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probe: Option<CephNfsServerLivenessProbeProbe>,
}

/// Probe describes a health check to be performed against a container to determine whether it is
/// alive or ready to receive traffic.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerLivenessProbeProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<CephNfsServerLivenessProbeProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<CephNfsServerLivenessProbeProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<CephNfsServerLivenessProbeProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<CephNfsServerLivenessProbeProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerLivenessProbeProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerLivenessProbeProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerLivenessProbeProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<CephNfsServerLivenessProbeProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerLivenessProbeProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerLivenessProbeProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacement {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<CephNfsServerPlacementNodeAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<CephNfsServerPlacementPodAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<CephNfsServerPlacementPodAntiAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<CephNfsServerPlacementTolerations>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topologySpreadConstraints")]
    pub topology_spread_constraints: Option<Vec<CephNfsServerPlacementTopologySpreadConstraints>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephNfsServerPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<CephNfsServerPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: CephNfsServerPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNfsServerPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<CephNfsServerPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<CephNfsServerPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNfsServerPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<CephNfsServerPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephNfsServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<CephNfsServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: CephNfsServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNfsServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephNfsServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNfsServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNfsServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNfsServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephNfsServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNfsServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNfsServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephNfsServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<CephNfsServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: CephNfsServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNfsServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephNfsServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNfsServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNfsServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNfsServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephNfsServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNfsServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNfsServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementTopologySpreadConstraints {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNfsServerPlacementTopologySpreadConstraintsLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(rename = "maxSkew")]
    pub max_skew: i32,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minDomains")]
    pub min_domains: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinityPolicy")]
    pub node_affinity_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeTaintsPolicy")]
    pub node_taints_policy: Option<String>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
    #[serde(rename = "whenUnsatisfiable")]
    pub when_unsatisfiable: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementTopologySpreadConstraintsLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNfsServerPlacementTopologySpreadConstraintsLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerPlacementTopologySpreadConstraintsLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Resources set resource requests and limits
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This field depends on the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<CephNfsServerResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsServerResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// NFSStatus represents the status of Ceph NFS
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cephx: Option<CephNfsStatusCephx>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest generation observed by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsStatusCephx {
    /// Daemon shows the CephX key status for local Ceph daemons associated with this resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub daemon: Option<CephNfsStatusCephxDaemon>,
}

/// Daemon shows the CephX key status for local Ceph daemons associated with this resources.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNfsStatusCephxDaemon {
    /// KeyCephVersion reports the Ceph version that created the current generation's keys. This is
    /// same string format as reported by `CephCluster.status.version.version` to allow them to be
    /// compared. E.g., `20.2.0-0`.
    /// For all newly-created resources, this field set to the version of Ceph that created the key.
    /// The special value "Uninitialized" indicates that keys are being created for the first time.
    /// An empty string indicates that the version is unknown, as expected in brownfield deployments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyCephVersion")]
    pub key_ceph_version: Option<String>,
    /// KeyGeneration represents the CephX key generation for the last successful reconcile.
    /// For all newly-created resources, this field is set to `1`.
    /// When keys are rotated due to any rotation policy, the generation is incremented or updated to
    /// the configured policy generation.
    /// Generation `0` indicates that keys existed prior to the implementation of key tracking.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyGeneration")]
    pub key_generation: Option<i32>,
}

