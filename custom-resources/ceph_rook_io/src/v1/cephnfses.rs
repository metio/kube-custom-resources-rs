// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/rook/rook/ceph.rook.io/v1/cephnfses.yaml
// kopium version: 0.21.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// NFSGaneshaSpec represents the spec of an nfs ganesha server
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "ceph.rook.io", version = "v1", kind = "CephNFS", plural = "cephnfses")]
#[kube(namespaced)]
#[kube(status = "CephNFSStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct CephNFSSpec {
    /// RADOS is the Ganesha RADOS specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rados: Option<CephNFSRados>,
    /// Security allows specifying security configurations for the NFS cluster
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<CephNFSSecurity>,
    /// Server is the Ganesha Server specification
    pub server: CephNFSServer,
}

/// RADOS is the Ganesha RADOS specification
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSRados {
    /// The namespace inside the Ceph pool (set by 'pool') where shared NFS-Ganesha config is stored.
    /// This setting is deprecated as it is internally set to the name of the CephNFS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// The Ceph pool used store the shared configuration for NFS-Ganesha daemons.
    /// This setting is deprecated, as it is internally required to be ".nfs".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pool: Option<String>,
}

/// Security allows specifying security configurations for the NFS cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurity {
    /// Kerberos configures NFS-Ganesha to secure NFS client connections with Kerberos.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kerberos: Option<CephNFSSecurityKerberos>,
    /// SSSD enables integration with System Security Services Daemon (SSSD). SSSD can be used to
    /// provide user ID mapping from a number of sources. See https://sssd.io for more information
    /// about the SSSD project.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sssd: Option<CephNFSSecuritySssd>,
}

/// Kerberos configures NFS-Ganesha to secure NFS client connections with Kerberos.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberos {
    /// ConfigFiles defines where the Kerberos configuration should be sourced from. Config files
    /// will be placed into the `/etc/krb5.conf.rook/` directory.
    /// 
    /// If this is left empty, Rook will not add any files. This allows you to manage the files
    /// yourself however you wish. For example, you may build them into your custom Ceph container
    /// image or use the Vault agent injector to securely add the files via annotations on the
    /// CephNFS spec (passed to the NFS server pods).
    /// 
    /// Rook configures Kerberos to log to stderr. We suggest removing logging sections from config
    /// files to avoid consuming unnecessary disk space from logging to files.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configFiles")]
    pub config_files: Option<CephNFSSecurityKerberosConfigFiles>,
    /// DomainName should be set to the Kerberos Realm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainName")]
    pub domain_name: Option<String>,
    /// KeytabFile defines where the Kerberos keytab should be sourced from. The keytab file will be
    /// placed into `/etc/krb5.keytab`. If this is left empty, Rook will not add the file.
    /// This allows you to manage the `krb5.keytab` file yourself however you wish. For example, you
    /// may build it into your custom Ceph container image or use the Vault agent injector to
    /// securely add the file via annotations on the CephNFS spec (passed to the NFS server pods).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keytabFile")]
    pub keytab_file: Option<CephNFSSecurityKerberosKeytabFile>,
    /// PrincipalName corresponds directly to NFS-Ganesha's NFS_KRB5:PrincipalName config. In
    /// practice, this is the service prefix of the principal name. The default is "nfs".
    /// This value is combined with (a) the namespace and name of the CephNFS (with a hyphen between)
    /// and (b) the Realm configured in the user-provided krb5.conf to determine the full principal
    /// name: <principalName>/<namespace>-<name>@<realm>. e.g., nfs/rook-ceph-my-nfs@example.net.
    /// See https://github.com/nfs-ganesha/nfs-ganesha/wiki/RPCSEC_GSS for more detail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "principalName")]
    pub principal_name: Option<String>,
}

/// ConfigFiles defines where the Kerberos configuration should be sourced from. Config files
/// will be placed into the `/etc/krb5.conf.rook/` directory.
/// 
/// If this is left empty, Rook will not add any files. This allows you to manage the files
/// yourself however you wish. For example, you may build them into your custom Ceph container
/// image or use the Vault agent injector to securely add the files via annotations on the
/// CephNFS spec (passed to the NFS server pods).
/// 
/// Rook configures Kerberos to log to stderr. We suggest removing logging sections from config
/// files to avoid consuming unnecessary disk space from logging to files.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFiles {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeSource")]
    pub volume_source: Option<CephNFSSecurityKerberosConfigFilesVolumeSource>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSource {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephNFSSecurityKerberosConfigFilesVolumeSourceConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<CephNFSSecurityKerberosConfigFilesVolumeSourceEmptyDir>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<CephNFSSecurityKerberosConfigFilesVolumeSourceHostPath>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<CephNFSSecurityKerberosConfigFilesVolumeSourcePersistentVolumeClaim>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<CephNFSSecurityKerberosConfigFilesVolumeSourceProjected>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephNFSSecurityKerberosConfigFilesVolumeSourceSecret>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecurityKerberosConfigFilesVolumeSourceConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceEmptyDir {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceHostPath {
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourcePersistentVolumeClaim {
    #[serde(rename = "claimName")]
    pub claim_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceProjected {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSources {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTrustBundle")]
    pub cluster_trust_bundle: Option<CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesClusterTrustBundle>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesDownwardApi>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesServiceAccountToken>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesClusterTrustBundle {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signerName")]
    pub signer_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesDownwardApi {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesDownwardApiItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesDownwardApiItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesDownwardApiItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesDownwardApiItemsFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceProjectedSourcesServiceAccountToken {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceSecret {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecurityKerberosConfigFilesVolumeSourceSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosConfigFilesVolumeSourceSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

/// KeytabFile defines where the Kerberos keytab should be sourced from. The keytab file will be
/// placed into `/etc/krb5.keytab`. If this is left empty, Rook will not add the file.
/// This allows you to manage the `krb5.keytab` file yourself however you wish. For example, you
/// may build it into your custom Ceph container image or use the Vault agent injector to
/// securely add the file via annotations on the CephNFS spec (passed to the NFS server pods).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFile {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeSource")]
    pub volume_source: Option<CephNFSSecurityKerberosKeytabFileVolumeSource>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSource {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephNFSSecurityKerberosKeytabFileVolumeSourceConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<CephNFSSecurityKerberosKeytabFileVolumeSourceEmptyDir>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<CephNFSSecurityKerberosKeytabFileVolumeSourceHostPath>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<CephNFSSecurityKerberosKeytabFileVolumeSourcePersistentVolumeClaim>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<CephNFSSecurityKerberosKeytabFileVolumeSourceProjected>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephNFSSecurityKerberosKeytabFileVolumeSourceSecret>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecurityKerberosKeytabFileVolumeSourceConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceEmptyDir {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceHostPath {
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourcePersistentVolumeClaim {
    #[serde(rename = "claimName")]
    pub claim_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceProjected {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSources {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTrustBundle")]
    pub cluster_trust_bundle: Option<CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesClusterTrustBundle>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesDownwardApi>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesServiceAccountToken>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesClusterTrustBundle {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signerName")]
    pub signer_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesDownwardApi {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesDownwardApiItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesDownwardApiItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesDownwardApiItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesDownwardApiItemsFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceProjectedSourcesServiceAccountToken {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceSecret {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecurityKerberosKeytabFileVolumeSourceSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecurityKerberosKeytabFileVolumeSourceSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

/// SSSD enables integration with System Security Services Daemon (SSSD). SSSD can be used to
/// provide user ID mapping from a number of sources. See https://sssd.io for more information
/// about the SSSD project.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssd {
    /// Sidecar tells Rook to run SSSD in a sidecar alongside the NFS-Ganesha server in each NFS pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sidecar: Option<CephNFSSecuritySssdSidecar>,
}

/// Sidecar tells Rook to run SSSD in a sidecar alongside the NFS-Ganesha server in each NFS pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecar {
    /// AdditionalFiles defines any number of additional files that should be mounted into the SSSD
    /// sidecar with a directory root of `/etc/sssd/rook-additional/`.
    /// These files may be referenced by the sssd.conf config file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalFiles")]
    pub additional_files: Option<Vec<CephNFSSecuritySssdSidecarAdditionalFiles>>,
    /// DebugLevel sets the debug level for SSSD. If unset or set to 0, Rook does nothing. Otherwise,
    /// this may be a value between 1 and 10. See SSSD docs for more info:
    /// https://sssd.io/troubleshooting/basics.html#sssd-debug-logs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "debugLevel")]
    pub debug_level: Option<i64>,
    /// Image defines the container image that should be used for the SSSD sidecar.
    pub image: String,
    /// Resources allow specifying resource requests/limits on the SSSD sidecar container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CephNFSSecuritySssdSidecarResources>,
    /// SSSDConfigFile defines where the SSSD configuration should be sourced from. The config file
    /// will be placed into `/etc/sssd/sssd.conf`. If this is left empty, Rook will not add the file.
    /// This allows you to manage the `sssd.conf` file yourself however you wish. For example, you
    /// may build it into your custom Ceph container image or use the Vault agent injector to
    /// securely add the file via annotations on the CephNFS spec (passed to the NFS server pods).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sssdConfigFile")]
    pub sssd_config_file: Option<CephNFSSecuritySssdSidecarSssdConfigFile>,
}

/// AdditionalVolumeMount represents the source from where additional files in pod containers
/// should come from and what subdirectory they are made available in.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFiles {
    /// SubPath defines the sub-path (subdirectory) of the directory root where the volumeSource will
    /// be mounted. All files/keys in the volume source's volume will be mounted to the subdirectory.
    /// This is not the same as the Kubernetes `subPath` volume mount option.
    /// Each subPath definition must be unique and must not contain ':'.
    #[serde(rename = "subPath")]
    pub sub_path: String,
    #[serde(rename = "volumeSource")]
    pub volume_source: CephNFSSecuritySssdSidecarAdditionalFilesVolumeSource,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSource {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceEmptyDir>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceHostPath>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourcePersistentVolumeClaim>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjected>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceSecret>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceEmptyDir {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceHostPath {
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourcePersistentVolumeClaim {
    #[serde(rename = "claimName")]
    pub claim_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjected {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSources {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTrustBundle")]
    pub cluster_trust_bundle: Option<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesClusterTrustBundle>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesDownwardApi>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesServiceAccountToken>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesClusterTrustBundle {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signerName")]
    pub signer_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesDownwardApi {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesDownwardApiItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesDownwardApiItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesDownwardApiItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesDownwardApiItemsFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceProjectedSourcesServiceAccountToken {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceSecret {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarAdditionalFilesVolumeSourceSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

/// Resources allow specifying resource requests/limits on the SSSD sidecar container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<CephNFSSecuritySssdSidecarResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// SSSDConfigFile defines where the SSSD configuration should be sourced from. The config file
/// will be placed into `/etc/sssd/sssd.conf`. If this is left empty, Rook will not add the file.
/// This allows you to manage the `sssd.conf` file yourself however you wish. For example, you
/// may build it into your custom Ceph container image or use the Vault agent injector to
/// securely add the file via annotations on the CephNFS spec (passed to the NFS server pods).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFile {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeSource")]
    pub volume_source: Option<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSource>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSource {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceEmptyDir>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceHostPath>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourcePersistentVolumeClaim>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjected>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceSecret>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceEmptyDir {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceHostPath {
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourcePersistentVolumeClaim {
    #[serde(rename = "claimName")]
    pub claim_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjected {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSources>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSources {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTrustBundle")]
    pub cluster_trust_bundle: Option<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesClusterTrustBundle>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesDownwardApi>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesServiceAccountToken>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesClusterTrustBundle {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signerName")]
    pub signer_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesClusterTrustBundleLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesDownwardApi {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesDownwardApiItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesDownwardApiItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesDownwardApiItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesDownwardApiItemsFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesDownwardApiItemsResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceProjectedSourcesServiceAccountToken {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceSecret {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSSecuritySssdSidecarSssdConfigFileVolumeSourceSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

/// Server is the Ganesha Server specification
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServer {
    /// The number of active Ganesha servers
    pub active: i64,
    /// The annotations-related configuration to add/set on each Pod related object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Whether host networking is enabled for the Ganesha server. If not set, the network settings from the cluster CR will be applied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetwork")]
    pub host_network: Option<bool>,
    /// The labels-related configuration to add/set on each Pod related object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// A liveness-probe to verify that Ganesha server has valid run-time state.
    /// If LivenessProbe.Disabled is false and LivenessProbe.Probe is nil uses default probe.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<CephNFSServerLivenessProbe>,
    /// LogLevel set logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub placement: Option<CephNFSServerPlacement>,
    /// PriorityClassName sets the priority class on the pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityClassName")]
    pub priority_class_name: Option<String>,
    /// Resources set resource requests and limits
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CephNFSServerResources>,
}

/// A liveness-probe to verify that Ganesha server has valid run-time state.
/// If LivenessProbe.Disabled is false and LivenessProbe.Probe is nil uses default probe.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerLivenessProbe {
    /// Disabled determines whether probe is disable or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Probe describes a health check to be performed against a container to determine whether it is
    /// alive or ready to receive traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probe: Option<CephNFSServerLivenessProbeProbe>,
}

/// Probe describes a health check to be performed against a container to determine whether it is
/// alive or ready to receive traffic.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerLivenessProbeProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<CephNFSServerLivenessProbeProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<CephNFSServerLivenessProbeProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<CephNFSServerLivenessProbeProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<CephNFSServerLivenessProbeProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerLivenessProbeProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerLivenessProbeProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerLivenessProbeProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<CephNFSServerLivenessProbeProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerLivenessProbeProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerLivenessProbeProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacement {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<CephNFSServerPlacementNodeAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<CephNFSServerPlacementPodAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<CephNFSServerPlacementPodAntiAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<CephNFSServerPlacementTolerations>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topologySpreadConstraints")]
    pub topology_spread_constraints: Option<Vec<CephNFSServerPlacementTopologySpreadConstraints>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephNFSServerPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<CephNFSServerPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: CephNFSServerPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNFSServerPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<CephNFSServerPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<CephNFSServerPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNFSServerPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<CephNFSServerPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephNFSServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<CephNFSServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: CephNFSServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNFSServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephNFSServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNFSServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNFSServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNFSServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephNFSServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNFSServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNFSServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephNFSServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<CephNFSServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: CephNFSServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNFSServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephNFSServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNFSServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNFSServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNFSServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephNFSServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNFSServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNFSServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementTopologySpreadConstraints {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephNFSServerPlacementTopologySpreadConstraintsLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    #[serde(rename = "maxSkew")]
    pub max_skew: i32,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minDomains")]
    pub min_domains: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinityPolicy")]
    pub node_affinity_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeTaintsPolicy")]
    pub node_taints_policy: Option<String>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
    #[serde(rename = "whenUnsatisfiable")]
    pub when_unsatisfiable: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementTopologySpreadConstraintsLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephNFSServerPlacementTopologySpreadConstraintsLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerPlacementTopologySpreadConstraintsLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Resources set resource requests and limits
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<CephNFSServerResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSServerResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// Status represents the status of an object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephNFSStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration is the latest generation observed by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<String>,
}

