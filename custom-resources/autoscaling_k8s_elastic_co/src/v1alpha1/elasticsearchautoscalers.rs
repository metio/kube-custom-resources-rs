// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/elastic/cloud-on-k8s/autoscaling.k8s.elastic.co/v1alpha1/elasticsearchautoscalers.yaml
// kopium version: 0.22.3

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
}
use self::prelude::*;

/// ElasticsearchAutoscalerSpec holds the specification of an Elasticsearch autoscaler resource.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "autoscaling.k8s.elastic.co", version = "v1alpha1", kind = "ElasticsearchAutoscaler", plural = "elasticsearchautoscalers")]
#[kube(namespaced)]
#[kube(status = "ElasticsearchAutoscalerStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ElasticsearchAutoscalerSpec {
    /// ElasticsearchRef is a reference to an Elasticsearch cluster that exists in the same namespace.
    #[serde(rename = "elasticsearchRef")]
    pub elasticsearch_ref: ElasticsearchAutoscalerElasticsearchRef,
    pub policies: Vec<ElasticsearchAutoscalerPolicies>,
    /// PollingPeriod is the period at which to synchronize with the Elasticsearch autoscaling API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pollingPeriod")]
    pub polling_period: Option<String>,
}

/// ElasticsearchRef is a reference to an Elasticsearch cluster that exists in the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ElasticsearchAutoscalerElasticsearchRef {
    /// Name is the name of the Elasticsearch resource to scale automatically.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// AutoscalingPolicySpec holds a named autoscaling policy and the associated resources limits (cpu, memory, storage).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ElasticsearchAutoscalerPolicies {
    /// Deciders allow the user to override default settings for autoscaling deciders.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deciders: Option<BTreeMap<String, BTreeMap<String, String>>>,
    /// Name identifies the autoscaling policy in the autoscaling specification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// AutoscalingResources model the limits, submitted by the user, for the supported resources in an autoscaling policy.
    /// Only the node count range is mandatory. For other resources, a limit range is required only
    /// if the Elasticsearch autoscaling capacity API returns a requirement for a given resource.
    /// For example, the memory limit range is only required if the autoscaling API response contains a memory requirement.
    /// If there is no limit range for a resource, and if that resource is not mandatory, then the resources in the NodeSets
    /// managed by the autoscaling policy are left untouched.
    pub resources: ElasticsearchAutoscalerPoliciesResources,
    /// An autoscaling policy must target a unique set of roles.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub roles: Option<Vec<String>>,
}

/// AutoscalingResources model the limits, submitted by the user, for the supported resources in an autoscaling policy.
/// Only the node count range is mandatory. For other resources, a limit range is required only
/// if the Elasticsearch autoscaling capacity API returns a requirement for a given resource.
/// For example, the memory limit range is only required if the autoscaling API response contains a memory requirement.
/// If there is no limit range for a resource, and if that resource is not mandatory, then the resources in the NodeSets
/// managed by the autoscaling policy are left untouched.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ElasticsearchAutoscalerPoliciesResources {
    /// QuantityRange models a resource limit range for resources which can be expressed with resource.Quantity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<ElasticsearchAutoscalerPoliciesResourcesCpu>,
    /// QuantityRange models a resource limit range for resources which can be expressed with resource.Quantity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<ElasticsearchAutoscalerPoliciesResourcesMemory>,
    /// NodeCountRange is used to model the minimum and the maximum number of nodes over all the NodeSets managed by the same autoscaling policy.
    #[serde(rename = "nodeCount")]
    pub node_count: ElasticsearchAutoscalerPoliciesResourcesNodeCount,
    /// QuantityRange models a resource limit range for resources which can be expressed with resource.Quantity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<ElasticsearchAutoscalerPoliciesResourcesStorage>,
}

/// QuantityRange models a resource limit range for resources which can be expressed with resource.Quantity.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ElasticsearchAutoscalerPoliciesResourcesCpu {
    /// Max represents the upper limit for the resources managed by the autoscaler.
    pub max: IntOrString,
    /// Min represents the lower limit for the resources managed by the autoscaler.
    pub min: IntOrString,
    /// RequestsToLimitsRatio allows to customize Kubernetes resource Limit based on the Request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestsToLimitsRatio")]
    pub requests_to_limits_ratio: Option<IntOrString>,
}

/// QuantityRange models a resource limit range for resources which can be expressed with resource.Quantity.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ElasticsearchAutoscalerPoliciesResourcesMemory {
    /// Max represents the upper limit for the resources managed by the autoscaler.
    pub max: IntOrString,
    /// Min represents the lower limit for the resources managed by the autoscaler.
    pub min: IntOrString,
    /// RequestsToLimitsRatio allows to customize Kubernetes resource Limit based on the Request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestsToLimitsRatio")]
    pub requests_to_limits_ratio: Option<IntOrString>,
}

/// NodeCountRange is used to model the minimum and the maximum number of nodes over all the NodeSets managed by the same autoscaling policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ElasticsearchAutoscalerPoliciesResourcesNodeCount {
    /// Max represents the maximum number of nodes in a tier.
    pub max: i32,
    /// Min represents the minimum number of nodes in a tier.
    pub min: i32,
}

/// QuantityRange models a resource limit range for resources which can be expressed with resource.Quantity.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ElasticsearchAutoscalerPoliciesResourcesStorage {
    /// Max represents the upper limit for the resources managed by the autoscaler.
    pub max: IntOrString,
    /// Min represents the lower limit for the resources managed by the autoscaler.
    pub min: IntOrString,
    /// RequestsToLimitsRatio allows to customize Kubernetes resource Limit based on the Request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestsToLimitsRatio")]
    pub requests_to_limits_ratio: Option<IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ElasticsearchAutoscalerStatus {
    /// Conditions holds the current service state of the autoscaling controller.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<ElasticsearchAutoscalerStatusConditions>>,
    /// ObservedGeneration is the last observed generation by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// AutoscalingPolicyStatuses is used to expose state messages to user or external system.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policies: Option<Vec<ElasticsearchAutoscalerStatusPolicies>>,
}

/// Condition represents Elasticsearch resource's condition.
/// **This API is in technical preview and may be changed or removed in a future release.**
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ElasticsearchAutoscalerStatusConditions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastTransitionTime")]
    pub last_transition_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    pub status: String,
    /// ConditionType defines the condition of an Elasticsearch resource.
    #[serde(rename = "type")]
    pub r#type: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ElasticsearchAutoscalerStatusPolicies {
    /// LastModificationTime is the last time the resources have been updated, used by the cooldown algorithm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastModificationTime")]
    pub last_modification_time: Option<String>,
    /// Name is the name of the autoscaling policy
    pub name: String,
    /// NodeSetNodeCount holds the number of nodes for each nodeSet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSets")]
    pub node_sets: Option<Vec<ElasticsearchAutoscalerStatusPoliciesNodeSets>>,
    /// ResourcesSpecification holds the resource values common to all the nodeSets managed by a same autoscaling policy.
    /// Only the resources managed by the autoscaling controller are saved in the Status.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ElasticsearchAutoscalerStatusPoliciesResources>,
    /// PolicyStates may contain various messages regarding the current state of this autoscaling policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<Vec<ElasticsearchAutoscalerStatusPoliciesState>>,
}

/// NodeSetNodeCount models the number of nodes expected in a given NodeSet.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ElasticsearchAutoscalerStatusPoliciesNodeSets {
    /// Name of the Nodeset.
    pub name: String,
    /// NodeCount is the number of nodes, as computed by the autoscaler, expected in this NodeSet.
    #[serde(rename = "nodeCount")]
    pub node_count: i32,
}

/// ResourcesSpecification holds the resource values common to all the nodeSets managed by a same autoscaling policy.
/// Only the resources managed by the autoscaling controller are saved in the Status.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ElasticsearchAutoscalerStatusPoliciesResources {
    /// ResourceList is a set of (resource name, quantity) pairs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// ResourceList is a set of (resource name, quantity) pairs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ElasticsearchAutoscalerStatusPoliciesState {
    pub messages: Vec<String>,
    #[serde(rename = "type")]
    pub r#type: String,
}

