// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/ROCm/gpu-operator/amd.com/v1alpha1/deviceconfigs.yaml
// kopium version: 0.21.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// DeviceConfigSpec describes how the AMD GPU operator should enable AMD GPU device for customer's use.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "amd.com", version = "v1alpha1", kind = "DeviceConfig", plural = "deviceconfigs")]
#[kube(namespaced)]
#[kube(status = "DeviceConfigStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct DeviceConfigSpec {
    /// common config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commonConfig")]
    pub common_config: Option<DeviceConfigCommonConfig>,
    /// config manager
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configManager")]
    pub config_manager: Option<DeviceConfigConfigManager>,
    /// device plugin
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "devicePlugin")]
    pub device_plugin: Option<DeviceConfigDevicePlugin>,
    /// driver
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub driver: Option<DeviceConfigDriver>,
    /// metrics exporter
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricsExporter")]
    pub metrics_exporter: Option<DeviceConfigMetricsExporter>,
    /// Selector describes on which nodes the GPU Operator should enable the GPU device.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<BTreeMap<String, String>>,
    /// test runner
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testRunner")]
    pub test_runner: Option<DeviceConfigTestRunner>,
}

/// common config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigCommonConfig {
    /// InitContainerImage is being used for the operands pods, i.e. metrics exporter, test runner, device plugin and node labeller
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainerImage")]
    pub init_container_image: Option<String>,
    /// UtilsContainer contains parameters to configure operator's utils container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "utilsContainer")]
    pub utils_container: Option<DeviceConfigCommonConfigUtilsContainer>,
}

/// UtilsContainer contains parameters to configure operator's utils container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigCommonConfigUtilsContainer {
    /// Image is the image of utils container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// image pull policy for utils container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<DeviceConfigCommonConfigUtilsContainerImagePullPolicy>,
    /// secret used for pull utils container image
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistrySecret")]
    pub image_registry_secret: Option<DeviceConfigCommonConfigUtilsContainerImageRegistrySecret>,
}

/// UtilsContainer contains parameters to configure operator's utils container
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigCommonConfigUtilsContainerImagePullPolicy {
    Always,
    IfNotPresent,
    Never,
}

/// secret used for pull utils container image
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigCommonConfigUtilsContainerImageRegistrySecret {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// config manager
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigConfigManager {
    /// config map to customize the config for config manager, if not specified default config will be applied
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<DeviceConfigConfigManagerConfig>,
    /// tolerations for the device config manager DaemonSet
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configManagerTolerations")]
    pub config_manager_tolerations: Option<Vec<DeviceConfigConfigManagerConfigManagerTolerations>>,
    /// enable config manager, disabled by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// config manager image
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// image pull policy for config manager
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<DeviceConfigConfigManagerImagePullPolicy>,
    /// config manager image registry secret used to pull/push images
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistrySecret")]
    pub image_registry_secret: Option<DeviceConfigConfigManagerImageRegistrySecret>,
    /// Selector describes on which nodes to enable config manager
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<BTreeMap<String, String>>,
    /// upgrade policy for config manager daemonset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradePolicy")]
    pub upgrade_policy: Option<DeviceConfigConfigManagerUpgradePolicy>,
}

/// config map to customize the config for config manager, if not specified default config will be applied
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigConfigManagerConfig {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigConfigManagerConfigManagerTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// config manager
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigConfigManagerImagePullPolicy {
    Always,
    IfNotPresent,
    Never,
}

/// config manager image registry secret used to pull/push images
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigConfigManagerImageRegistrySecret {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// upgrade policy for config manager daemonset
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigConfigManagerUpgradePolicy {
    /// MaxUnavailable specifies the maximum number of Pods that can be unavailable during the update process. Applicable for RollingUpdate only. Default value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<i32>,
    /// UpgradeStrategy specifies the type of the DaemonSet update. Valid values are "RollingUpdate" (default) or "OnDelete".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeStrategy")]
    pub upgrade_strategy: Option<DeviceConfigConfigManagerUpgradePolicyUpgradeStrategy>,
}

/// upgrade policy for config manager daemonset
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigConfigManagerUpgradePolicyUpgradeStrategy {
    RollingUpdate,
    OnDelete,
}

/// device plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDevicePlugin {
    /// device plugin arguments is used to pass supported flags and their values while starting device plugin daemonset
    /// supported flag values: {"resource_naming_strategy": {"single", "mixed"}}
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "devicePluginArguments")]
    pub device_plugin_arguments: Option<BTreeMap<String, String>>,
    /// device plugin image
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "devicePluginImage")]
    pub device_plugin_image: Option<String>,
    /// image pull policy for device plugin
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "devicePluginImagePullPolicy")]
    pub device_plugin_image_pull_policy: Option<DeviceConfigDevicePluginDevicePluginImagePullPolicy>,
    /// tolerations for the device plugin DaemonSet
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "devicePluginTolerations")]
    pub device_plugin_tolerations: Option<Vec<DeviceConfigDevicePluginDevicePluginTolerations>>,
    /// enable or disable the node labeller
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNodeLabeller")]
    pub enable_node_labeller: Option<bool>,
    /// node labeller image registry secret used to pull/push images
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistrySecret")]
    pub image_registry_secret: Option<DeviceConfigDevicePluginImageRegistrySecret>,
    /// node labeller image
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeLabellerImage")]
    pub node_labeller_image: Option<String>,
    /// image pull policy for node labeller
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeLabellerImagePullPolicy")]
    pub node_labeller_image_pull_policy: Option<DeviceConfigDevicePluginNodeLabellerImagePullPolicy>,
    /// tolerations for the node labeller DaemonSet
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeLabellerTolerations")]
    pub node_labeller_tolerations: Option<Vec<DeviceConfigDevicePluginNodeLabellerTolerations>>,
    /// upgrade policy for device plugin and node labeller daemons
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradePolicy")]
    pub upgrade_policy: Option<DeviceConfigDevicePluginUpgradePolicy>,
}

/// device plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigDevicePluginDevicePluginImagePullPolicy {
    Always,
    IfNotPresent,
    Never,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDevicePluginDevicePluginTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// node labeller image registry secret used to pull/push images
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDevicePluginImageRegistrySecret {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// device plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigDevicePluginNodeLabellerImagePullPolicy {
    Always,
    IfNotPresent,
    Never,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDevicePluginNodeLabellerTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// upgrade policy for device plugin and node labeller daemons
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDevicePluginUpgradePolicy {
    /// MaxUnavailable specifies the maximum number of Pods that can be unavailable during the update process. Applicable for RollingUpdate only. Default value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<i32>,
    /// UpgradeStrategy specifies the type of the DaemonSet update. Valid values are "RollingUpdate" (default) or "OnDelete".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeStrategy")]
    pub upgrade_strategy: Option<DeviceConfigDevicePluginUpgradePolicyUpgradeStrategy>,
}

/// upgrade policy for device plugin and node labeller daemons
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigDevicePluginUpgradePolicyUpgradeStrategy {
    RollingUpdate,
    OnDelete,
}

/// driver
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriver {
    /// radeon repo URL for fetching amdgpu installer if building driver image on the fly
    /// installer URL is https://repo.radeon.com/amdgpu-install by default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "amdgpuInstallerRepoURL")]
    pub amdgpu_installer_repo_url: Option<String>,
    /// blacklist amdgpu drivers on the host. Node reboot is required to apply the baclklist on the worker nodes.
    /// Not working for OpenShift cluster. OpenShift users please use the Machine Config Operator (MCO) resource to configure amdgpu blacklist.
    /// Example MCO resource is available at https://instinct.docs.amd.com/projects/gpu-operator/en/latest/installation/openshift-olm.html#create-blacklist-for-installing-out-of-tree-kernel-module
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blacklist: Option<bool>,
    /// enable driver install. default value is true.
    /// disable is for skipping driver install/uninstall for dryrun or using in-tree amdgpu kernel module
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// defines image that includes drivers and firmware blobs, don't include tag since it will be fully managed by operator
    /// for vanilla k8s the default value is image-registry:5000/$MOD_NAMESPACE/amdgpu_kmod
    /// for OpenShift the default value is image-registry.openshift-image-registry.svc:5000/$MOD_NAMESPACE/amdgpu_kmod
    /// image tag will be in the format of <linux distro>-<release version>-<kernel version>-<driver version>
    /// example tag is coreos-416.94-5.14.0-427.28.1.el9_4.x86_64-6.2.2 and ubuntu-22.04-5.15.0-94-generic-6.1.3
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// secrets used for pull/push images from/to private registry specified in driversImage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistrySecret")]
    pub image_registry_secret: Option<DeviceConfigDriverImageRegistrySecret>,
    /// driver image registry TLS setting for the container image
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistryTLS")]
    pub image_registry_tls: Option<DeviceConfigDriverImageRegistryTls>,
    /// image signing config to sign the driver image when building driver image on the fly
    /// image signing is required for installing driver on secure boot enabled system
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageSign")]
    pub image_sign: Option<DeviceConfigDriverImageSign>,
    /// policy to upgrade the drivers
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradePolicy")]
    pub upgrade_policy: Option<DeviceConfigDriverUpgradePolicy>,
    /// version of the drivers source code, can be used as part of image of dockerfile source image
    /// default value for different OS is: ubuntu: 6.1.3, coreOS: 6.2.2
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// secrets used for pull/push images from/to private registry specified in driversImage
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverImageRegistrySecret {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// driver image registry TLS setting for the container image
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverImageRegistryTls {
    /// If true, check if the container image already exists using plain HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<bool>,
    /// If true, skip any TLS server certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipTLSVerify")]
    pub insecure_skip_tls_verify: Option<bool>,
}

/// image signing config to sign the driver image when building driver image on the fly
/// image signing is required for installing driver on secure boot enabled system
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverImageSign {
    /// ImageSignCertSecret the public key used to sign kernel modules within image
    /// necessary for secure boot enabled system
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certSecret")]
    pub cert_secret: Option<DeviceConfigDriverImageSignCertSecret>,
    /// ImageSignKeySecret the private key used to sign kernel modules within image
    /// necessary for secure boot enabled system
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<DeviceConfigDriverImageSignKeySecret>,
}

/// ImageSignCertSecret the public key used to sign kernel modules within image
/// necessary for secure boot enabled system
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverImageSignCertSecret {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// ImageSignKeySecret the private key used to sign kernel modules within image
/// necessary for secure boot enabled system
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverImageSignKeySecret {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// policy to upgrade the drivers
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverUpgradePolicy {
    /// enable upgrade policy, disabled by default
    /// If disabled, user has to manually upgrade all the nodes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// MaxParallelUpgrades indicates how many nodes can be upgraded in parallel
    /// 0 means no limit, all nodes will be upgraded in parallel
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxParallelUpgrades")]
    pub max_parallel_upgrades: Option<i64>,
    /// MaxUnavailableNodes indicates maximum number of nodes that can be in a failed upgrade state beyond which upgrades will stop to keep cluster at a minimal healthy state
    /// Value can be an integer (ex: 2) which would mean atmost 2 nodes can be in failed state after which new upgrades will not start. Or it can be a percentage string(ex: "50%") from which absolute number will be calculated and round up
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailableNodes")]
    pub max_unavailable_nodes: Option<IntOrString>,
    /// Node draining policy
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDrainPolicy")]
    pub node_drain_policy: Option<DeviceConfigDriverUpgradePolicyNodeDrainPolicy>,
    /// Pod Deletion policy. If both NodeDrainPolicy and PodDeletionPolicy config is available, NodeDrainPolicy(if enabled) will take precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podDeletionPolicy")]
    pub pod_deletion_policy: Option<DeviceConfigDriverUpgradePolicyPodDeletionPolicy>,
    /// reboot between driver upgrades, enabled by default, if enabled spec.commonConfig.utilsContainer will be used to perform reboot on worker nodes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rebootRequired")]
    pub reboot_required: Option<bool>,
}

/// Node draining policy
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverUpgradePolicyNodeDrainPolicy {
    /// Force indicates if force draining is allowed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub force: Option<bool>,
    /// TimeoutSecond specifies the length of time in seconds to wait before giving up drain, zero means infinite
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i64>,
}

/// Pod Deletion policy. If both NodeDrainPolicy and PodDeletionPolicy config is available, NodeDrainPolicy(if enabled) will take precedence.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverUpgradePolicyPodDeletionPolicy {
    /// Force indicates if force deletion is allowed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub force: Option<bool>,
    /// TimeoutSecond specifies the length of time in seconds to wait before giving up on pod deletion, zero means infinite
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i64>,
}

/// metrics exporter
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporter {
    /// optional configuration for metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<DeviceConfigMetricsExporterConfig>,
    /// enable metrics exporter, disabled by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// metrics exporter image
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// image pull policy for metrics exporter
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<DeviceConfigMetricsExporterImagePullPolicy>,
    /// metrics exporter image registry secret used to pull/push images
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistrySecret")]
    pub image_registry_secret: Option<DeviceConfigMetricsExporterImageRegistrySecret>,
    /// NodePort is the external port for pulling metrics from outside the cluster, in the range 30000-32767 (assigned automatically by default)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePort")]
    pub node_port: Option<i32>,
    /// Port is the internal port used for in-cluster and node access to pull metrics from the metrics-exporter (default 5000).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// optional kube-rbac-proxy config to provide rbac services
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rbacConfig")]
    pub rbac_config: Option<DeviceConfigMetricsExporterRbacConfig>,
    /// Selector describes on which nodes to enable metrics exporter
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<BTreeMap<String, String>>,
    /// ServiceType service type for metrics, clusterIP/NodePort, clusterIP by default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceType")]
    pub service_type: Option<DeviceConfigMetricsExporterServiceType>,
    /// tolerations for metrics exporter
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<DeviceConfigMetricsExporterTolerations>>,
    /// upgrade policy for metrics exporter daemons
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradePolicy")]
    pub upgrade_policy: Option<DeviceConfigMetricsExporterUpgradePolicy>,
}

/// optional configuration for metrics
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterConfig {
    /// Name of the configMap that defines the list of metrics
    /// default list:[]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// metrics exporter
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigMetricsExporterImagePullPolicy {
    Always,
    IfNotPresent,
    Never,
}

/// metrics exporter image registry secret used to pull/push images
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterImageRegistrySecret {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// optional kube-rbac-proxy config to provide rbac services
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterRbacConfig {
    /// disable https protecting the proxy endpoint
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableHttps")]
    pub disable_https: Option<bool>,
    /// enable kube-rbac-proxy, disabled by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// kube-rbac-proxy image
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// certificate secret to mount in kube-rbac container for TLS, self signed certificates will be generated by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<DeviceConfigMetricsExporterRbacConfigSecret>,
}

/// certificate secret to mount in kube-rbac container for TLS, self signed certificates will be generated by default
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterRbacConfigSecret {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// metrics exporter
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigMetricsExporterServiceType {
    #[serde(rename = "ClusterIP")]
    ClusterIp,
    NodePort,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// upgrade policy for metrics exporter daemons
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterUpgradePolicy {
    /// MaxUnavailable specifies the maximum number of Pods that can be unavailable during the update process. Applicable for RollingUpdate only. Default value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<i32>,
    /// UpgradeStrategy specifies the type of the DaemonSet update. Valid values are "RollingUpdate" (default) or "OnDelete".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeStrategy")]
    pub upgrade_strategy: Option<DeviceConfigMetricsExporterUpgradePolicyUpgradeStrategy>,
}

/// upgrade policy for metrics exporter daemons
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigMetricsExporterUpgradePolicyUpgradeStrategy {
    RollingUpdate,
    OnDelete,
}

/// test runner
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigTestRunner {
    /// config map to customize the config for test runner, if not specified default test config will be aplied
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<DeviceConfigTestRunnerConfig>,
    /// enable test runner, disabled by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// test runner image
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// image pull policy for test runner
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<DeviceConfigTestRunnerImagePullPolicy>,
    /// test runner image registry secret used to pull/push images
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistrySecret")]
    pub image_registry_secret: Option<DeviceConfigTestRunnerImageRegistrySecret>,
    /// captures logs location and export config for test runner logs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logsLocation")]
    pub logs_location: Option<DeviceConfigTestRunnerLogsLocation>,
    /// Selector describes on which nodes to enable test runner
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<BTreeMap<String, String>>,
    /// tolerations for test runner
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<DeviceConfigTestRunnerTolerations>>,
    /// upgrade policy for test runner daemonset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradePolicy")]
    pub upgrade_policy: Option<DeviceConfigTestRunnerUpgradePolicy>,
}

/// config map to customize the config for test runner, if not specified default test config will be aplied
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigTestRunnerConfig {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// test runner
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigTestRunnerImagePullPolicy {
    Always,
    IfNotPresent,
    Never,
}

/// test runner image registry secret used to pull/push images
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigTestRunnerImageRegistrySecret {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// captures logs location and export config for test runner logs
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigTestRunnerLogsLocation {
    /// host path to store test runner internal status db in order to persist test running status
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<String>,
    /// LogsExportSecrets is a list of secrets that contain connectivity info to multiple cloud providers
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logsExportSecrets")]
    pub logs_export_secrets: Option<Vec<DeviceConfigTestRunnerLogsLocationLogsExportSecrets>>,
    /// volume mount destination within test runner container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPath")]
    pub mount_path: Option<String>,
}

/// LocalObjectReference contains enough information to let you locate the
/// referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigTestRunnerLogsLocationLogsExportSecrets {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigTestRunnerTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// upgrade policy for test runner daemonset
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigTestRunnerUpgradePolicy {
    /// MaxUnavailable specifies the maximum number of Pods that can be unavailable during the update process. Applicable for RollingUpdate only. Default value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<i32>,
    /// UpgradeStrategy specifies the type of the DaemonSet update. Valid values are "RollingUpdate" (default) or "OnDelete".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeStrategy")]
    pub upgrade_strategy: Option<DeviceConfigTestRunnerUpgradePolicyUpgradeStrategy>,
}

/// upgrade policy for test runner daemonset
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigTestRunnerUpgradePolicyUpgradeStrategy {
    RollingUpdate,
    OnDelete,
}

/// DeviceConfigStatus defines the observed state of Module.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigStatus {
    /// Conditions list the current status of the DeviceConfig object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ConfigManager contains the status of the ConfigManager deployment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configManager")]
    pub config_manager: Option<DeviceConfigStatusConfigManager>,
    /// DevicePlugin contains the status of the Device Plugin deployment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "devicePlugin")]
    pub device_plugin: Option<DeviceConfigStatusDevicePlugin>,
    /// Driver contains the status of the Drivers deployment
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub driver: Option<DeviceConfigStatusDriver>,
    /// MetricsExporter contains the status of the MetricsExporter deployment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricsExporter")]
    pub metrics_exporter: Option<DeviceConfigStatusMetricsExporter>,
    /// NodeModuleStatus contains per node status of driver module installation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeModuleStatus")]
    pub node_module_status: Option<BTreeMap<String, DeviceConfigStatusNodeModuleStatus>>,
    /// ObservedGeneration is the latest spec generation successfully processed by the controller
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

/// ConfigManager contains the status of the ConfigManager deployment
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigStatusConfigManager {
    /// number of the actually deployed and running pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableNumber")]
    pub available_number: Option<i32>,
    /// number of the pods that should be deployed for daemonset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredNumber")]
    pub desired_number: Option<i32>,
    /// number of nodes that are targeted by the DeviceConfig selector
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodesMatchingSelectorNumber")]
    pub nodes_matching_selector_number: Option<i32>,
}

/// DevicePlugin contains the status of the Device Plugin deployment
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigStatusDevicePlugin {
    /// number of the actually deployed and running pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableNumber")]
    pub available_number: Option<i32>,
    /// number of the pods that should be deployed for daemonset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredNumber")]
    pub desired_number: Option<i32>,
    /// number of nodes that are targeted by the DeviceConfig selector
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodesMatchingSelectorNumber")]
    pub nodes_matching_selector_number: Option<i32>,
}

/// Driver contains the status of the Drivers deployment
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigStatusDriver {
    /// number of the actually deployed and running pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableNumber")]
    pub available_number: Option<i32>,
    /// number of the pods that should be deployed for daemonset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredNumber")]
    pub desired_number: Option<i32>,
    /// number of nodes that are targeted by the DeviceConfig selector
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodesMatchingSelectorNumber")]
    pub nodes_matching_selector_number: Option<i32>,
}

/// MetricsExporter contains the status of the MetricsExporter deployment
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigStatusMetricsExporter {
    /// number of the actually deployed and running pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableNumber")]
    pub available_number: Option<i32>,
    /// number of the pods that should be deployed for daemonset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredNumber")]
    pub desired_number: Option<i32>,
    /// number of nodes that are targeted by the DeviceConfig selector
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodesMatchingSelectorNumber")]
    pub nodes_matching_selector_number: Option<i32>,
}

/// NodeModuleStatus contains per node status of driver module installation
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigStatusNodeModuleStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootId")]
    pub boot_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerImage")]
    pub container_image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kernelVersion")]
    pub kernel_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastTransitionTime")]
    pub last_transition_time: Option<String>,
    /// UpgradeState captures the state of the upgrade process on a node
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeStartTime")]
    pub upgrade_start_time: Option<String>,
}

