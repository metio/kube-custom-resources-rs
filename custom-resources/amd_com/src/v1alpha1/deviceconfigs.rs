// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/ROCm/gpu-operator/amd.com/v1alpha1/deviceconfigs.yaml
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// DeviceConfigSpec describes how the AMD GPU operator should enable AMD GPU device for customer's use.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "amd.com", version = "v1alpha1", kind = "DeviceConfig", plural = "deviceconfigs")]
#[kube(namespaced)]
#[kube(status = "DeviceConfigStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct DeviceConfigSpec {
    /// common config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "commonConfig")]
    pub common_config: Option<DeviceConfigCommonConfig>,
    /// config manager
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configManager")]
    pub config_manager: Option<DeviceConfigConfigManager>,
    /// device plugin
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "devicePlugin")]
    pub device_plugin: Option<DeviceConfigDevicePlugin>,
    /// driver
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub driver: Option<DeviceConfigDriver>,
    /// metrics exporter
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricsExporter")]
    pub metrics_exporter: Option<DeviceConfigMetricsExporter>,
    /// remediation workflow
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remediationWorkflow")]
    pub remediation_workflow: Option<DeviceConfigRemediationWorkflow>,
    /// Selector describes on which nodes the GPU Operator should enable the GPU device.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<BTreeMap<String, String>>,
    /// test runner
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testRunner")]
    pub test_runner: Option<DeviceConfigTestRunner>,
}

/// common config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigCommonConfig {
    /// InitContainerImage is being used for the operands pods, i.e. metrics exporter, test runner, device plugin, device config manager and node labeller
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainerImage")]
    pub init_container_image: Option<String>,
    /// UtilsContainer contains parameters to configure operator's utils container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "utilsContainer")]
    pub utils_container: Option<DeviceConfigCommonConfigUtilsContainer>,
}

/// UtilsContainer contains parameters to configure operator's utils container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigCommonConfigUtilsContainer {
    /// Image is the image of utils container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// image pull policy for utils container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<DeviceConfigCommonConfigUtilsContainerImagePullPolicy>,
    /// secret used for pull utils container image
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistrySecret")]
    pub image_registry_secret: Option<DeviceConfigCommonConfigUtilsContainerImageRegistrySecret>,
}

/// UtilsContainer contains parameters to configure operator's utils container
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigCommonConfigUtilsContainerImagePullPolicy {
    Always,
    IfNotPresent,
    Never,
}

/// secret used for pull utils container image
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigCommonConfigUtilsContainerImageRegistrySecret {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// config manager
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigConfigManager {
    /// config map to customize the config for config manager, if not specified default config will be applied
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<DeviceConfigConfigManagerConfig>,
    /// tolerations for the device config manager DaemonSet
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configManagerTolerations")]
    pub config_manager_tolerations: Option<Vec<DeviceConfigConfigManagerConfigManagerTolerations>>,
    /// enable config manager, disabled by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// config manager image
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// image pull policy for config manager
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<DeviceConfigConfigManagerImagePullPolicy>,
    /// config manager image registry secret used to pull/push images
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistrySecret")]
    pub image_registry_secret: Option<DeviceConfigConfigManagerImageRegistrySecret>,
    /// Selector describes on which nodes to enable config manager
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<BTreeMap<String, String>>,
    /// upgrade policy for config manager daemonset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradePolicy")]
    pub upgrade_policy: Option<DeviceConfigConfigManagerUpgradePolicy>,
}

/// config map to customize the config for config manager, if not specified default config will be applied
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigConfigManagerConfig {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigConfigManagerConfigManagerTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// config manager
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigConfigManagerImagePullPolicy {
    Always,
    IfNotPresent,
    Never,
}

/// config manager image registry secret used to pull/push images
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigConfigManagerImageRegistrySecret {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// upgrade policy for config manager daemonset
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigConfigManagerUpgradePolicy {
    /// MaxUnavailable specifies the maximum number of Pods that can be unavailable during the update process. Applicable for RollingUpdate only. Default value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<i32>,
    /// UpgradeStrategy specifies the type of the DaemonSet update. Valid values are "RollingUpdate" (default) or "OnDelete".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeStrategy")]
    pub upgrade_strategy: Option<DeviceConfigConfigManagerUpgradePolicyUpgradeStrategy>,
}

/// upgrade policy for config manager daemonset
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigConfigManagerUpgradePolicyUpgradeStrategy {
    RollingUpdate,
    OnDelete,
}

/// device plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDevicePlugin {
    /// device plugin arguments is used to pass supported flags and their values while starting device plugin daemonset
    /// supported flag values: {"resource_naming_strategy": {"single", "mixed"}}
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "devicePluginArguments")]
    pub device_plugin_arguments: Option<BTreeMap<String, String>>,
    /// device plugin image
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "devicePluginImage")]
    pub device_plugin_image: Option<String>,
    /// image pull policy for device plugin
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "devicePluginImagePullPolicy")]
    pub device_plugin_image_pull_policy: Option<DeviceConfigDevicePluginDevicePluginImagePullPolicy>,
    /// tolerations for the device plugin DaemonSet
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "devicePluginTolerations")]
    pub device_plugin_tolerations: Option<Vec<DeviceConfigDevicePluginDevicePluginTolerations>>,
    /// enable or disable the node labeller
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNodeLabeller")]
    pub enable_node_labeller: Option<bool>,
    /// node labeller image registry secret used to pull/push images
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistrySecret")]
    pub image_registry_secret: Option<DeviceConfigDevicePluginImageRegistrySecret>,
    /// node labeller arguments is used to pass supported labels while starting node labeller daemonset
    /// some flags are enabled by default as they are applicable and bare minimum for all setups and are supported in all versions of node labeller
    /// default flags: {"vram", "cu-count", "simd-count", "device-id", "family", "product-name", "driver-version"}
    /// supported flags: {"compute-memory-partition", "compute-partitioning-supported", "memory-partitioning-supported"}
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeLabellerArguments")]
    pub node_labeller_arguments: Option<Vec<String>>,
    /// node labeller image
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeLabellerImage")]
    pub node_labeller_image: Option<String>,
    /// image pull policy for node labeller
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeLabellerImagePullPolicy")]
    pub node_labeller_image_pull_policy: Option<DeviceConfigDevicePluginNodeLabellerImagePullPolicy>,
    /// tolerations for the node labeller DaemonSet
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeLabellerTolerations")]
    pub node_labeller_tolerations: Option<Vec<DeviceConfigDevicePluginNodeLabellerTolerations>>,
    /// upgrade policy for device plugin and node labeller daemons
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradePolicy")]
    pub upgrade_policy: Option<DeviceConfigDevicePluginUpgradePolicy>,
}

/// device plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigDevicePluginDevicePluginImagePullPolicy {
    Always,
    IfNotPresent,
    Never,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDevicePluginDevicePluginTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// node labeller image registry secret used to pull/push images
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDevicePluginImageRegistrySecret {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// device plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigDevicePluginNodeLabellerImagePullPolicy {
    Always,
    IfNotPresent,
    Never,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDevicePluginNodeLabellerTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// upgrade policy for device plugin and node labeller daemons
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDevicePluginUpgradePolicy {
    /// MaxUnavailable specifies the maximum number of Pods that can be unavailable during the update process. Applicable for RollingUpdate only. Default value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<i32>,
    /// UpgradeStrategy specifies the type of the DaemonSet update. Valid values are "RollingUpdate" (default) or "OnDelete".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeStrategy")]
    pub upgrade_strategy: Option<DeviceConfigDevicePluginUpgradePolicyUpgradeStrategy>,
}

/// upgrade policy for device plugin and node labeller daemons
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigDevicePluginUpgradePolicyUpgradeStrategy {
    RollingUpdate,
    OnDelete,
}

/// driver
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriver {
    /// radeon repo URL for fetching amdgpu installer if building driver image on the fly
    /// installer URL is <https://repo.radeon.com/amdgpu-install> by default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "amdgpuInstallerRepoURL")]
    pub amdgpu_installer_repo_url: Option<String>,
    /// blacklist amdgpu drivers on the host. Node reboot is required to apply the baclklist on the worker nodes.
    /// Not working for OpenShift cluster. OpenShift users please use the Machine Config Operator (MCO) resource to configure amdgpu blacklist.
    /// Example MCO resource is available at <https://instinct.docs.amd.com/projects/gpu-operator/en/latest/installation/openshift-olm.html#create-blacklist-for-installing-out-of-tree-kernel-module>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blacklist: Option<bool>,
    /// specify the type of driver (container/vf-passthrough/pf-passthrough) to install on the worker node. default value is container.
    /// container: normal amdgpu-dkms driver for Bare Metal GPU nodes or guest VM.
    /// vf-passthrough: MxGPU GIM driver on the host machine to generate VF, then mount VF to vfio-pci
    /// pf-passthrough: directly mount PF device to vfio-pci
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "driverType")]
    pub driver_type: Option<DeviceConfigDriverDriverType>,
    /// enable driver install. default value is true.
    /// disable is for skipping driver install/uninstall for dryrun or using in-tree amdgpu kernel module
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// defines image that includes drivers and firmware blobs, don't include tag since it will be fully managed by operator
    /// for vanilla k8s the default value is image-registry:5000/$MOD_NAMESPACE/amdgpu_kmod
    /// for OpenShift the default value is image-registry.openshift-image-registry.svc:5000/$MOD_NAMESPACE/amdgpu_kmod
    /// image tag will be in the format of <linux distro>-<release version>-<kernel version>-<driver version>
    /// example tag is coreos-416.94-5.14.0-427.28.1.el9_4.x86_64-6.2.2 and ubuntu-22.04-5.15.0-94-generic-6.1.3
    /// NOTE: Updating the driver image repository is not supported. Please delete the existing DeviceConfig and create a new one with the updated image repository
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// image build configs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageBuild")]
    pub image_build: Option<DeviceConfigDriverImageBuild>,
    /// secrets used for pull/push images from/to private registry specified in driversImage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistrySecret")]
    pub image_registry_secret: Option<DeviceConfigDriverImageRegistrySecret>,
    /// driver image registry TLS setting for the container image
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistryTLS")]
    pub image_registry_tls: Option<DeviceConfigDriverImageRegistryTls>,
    /// image signing config to sign the driver image when building driver image on the fly
    /// image signing is required for installing driver on secure boot enabled system
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageSign")]
    pub image_sign: Option<DeviceConfigDriverImageSign>,
    /// advanced arguments, parameters and more configs to manage tne driver
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kernelModuleConfig")]
    pub kernel_module_config: Option<DeviceConfigDriverKernelModuleConfig>,
    /// tolerations for kmm module object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<DeviceConfigDriverTolerations>>,
    /// policy to upgrade the drivers
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradePolicy")]
    pub upgrade_policy: Option<DeviceConfigDriverUpgradePolicy>,
    /// version of the drivers source code, can be used as part of image of dockerfile source image
    /// default value for different OS is: ubuntu: 6.1.3, coreOS: 6.2.2
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
    /// vfio config
    /// specify the specific configs for binding PCI devices to vfio-pci kernel module, applies for driver type vf-passthrough and pf-passthrough
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vfioConfig")]
    pub vfio_config: Option<DeviceConfigDriverVfioConfig>,
}

/// driver
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigDriverDriverType {
    #[serde(rename = "container")]
    Container,
    #[serde(rename = "vf-passthrough")]
    VfPassthrough,
    #[serde(rename = "pf-passthrough")]
    PfPassthrough,
}

/// image build configs
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverImageBuild {
    /// image registry to fetch base image for building driver image, default value is docker.io, the builder will search for corresponding OS base image from given registry
    /// e.g. if your worker node is using Ubuntu 22.04, by default the base image would be docker.io/ubuntu:22.04
    /// NOTE: this field won't apply for OpenShift since OpenShift is using its own DriverToolKit image to build driver image
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseImageRegistry")]
    pub base_image_registry: Option<String>,
    /// TLS settings for fetching base image
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseImageRegistryTLS")]
    pub base_image_registry_tls: Option<DeviceConfigDriverImageBuildBaseImageRegistryTls>,
}

/// TLS settings for fetching base image
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverImageBuildBaseImageRegistryTls {
    /// If true, check if the container image already exists using plain HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<bool>,
    /// If true, skip any TLS server certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipTLSVerify")]
    pub insecure_skip_tls_verify: Option<bool>,
}

/// secrets used for pull/push images from/to private registry specified in driversImage
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverImageRegistrySecret {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// driver image registry TLS setting for the container image
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverImageRegistryTls {
    /// If true, check if the container image already exists using plain HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<bool>,
    /// If true, skip any TLS server certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipTLSVerify")]
    pub insecure_skip_tls_verify: Option<bool>,
}

/// image signing config to sign the driver image when building driver image on the fly
/// image signing is required for installing driver on secure boot enabled system
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverImageSign {
    /// ImageSignCertSecret the public key used to sign kernel modules within image
    /// necessary for secure boot enabled system
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certSecret")]
    pub cert_secret: Option<DeviceConfigDriverImageSignCertSecret>,
    /// ImageSignKeySecret the private key used to sign kernel modules within image
    /// necessary for secure boot enabled system
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<DeviceConfigDriverImageSignKeySecret>,
}

/// ImageSignCertSecret the public key used to sign kernel modules within image
/// necessary for secure boot enabled system
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverImageSignCertSecret {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// ImageSignKeySecret the private key used to sign kernel modules within image
/// necessary for secure boot enabled system
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverImageSignKeySecret {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// advanced arguments, parameters and more configs to manage tne driver
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverKernelModuleConfig {
    /// LoadArg are the arguments when modprobe is executed to load the kernel module. The command will be `modprobe ${Args} module_name`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadArgs")]
    pub load_args: Option<Vec<String>>,
    /// Parameters is being used for modprobe commands. The command will be `modprobe ${Args} module_name ${Parameters}`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<Vec<String>>,
    /// UnloadArg are the arguments when modprobe is executed to unload the kernel module. The command will be `modprobe -r ${Args} module_name`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unloadArgs")]
    pub unload_args: Option<Vec<String>>,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// policy to upgrade the drivers
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverUpgradePolicy {
    /// enable upgrade policy, disabled by default
    /// If disabled, user has to manually upgrade all the nodes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// MaxParallelUpgrades indicates how many nodes can be upgraded in parallel
    /// 0 means no limit, all nodes will be upgraded in parallel
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxParallelUpgrades")]
    pub max_parallel_upgrades: Option<i64>,
    /// MaxUnavailableNodes indicates maximum number of nodes that can be in a failed upgrade state beyond which upgrades will stop to keep cluster at a minimal healthy state
    /// Value can be an integer (ex: 2) which would mean atmost 2 nodes can be in failed state after which new upgrades will not start. Or it can be a percentage string(ex: "50%") from which absolute number will be calculated and round up
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailableNodes")]
    pub max_unavailable_nodes: Option<IntOrString>,
    /// Node draining policy
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDrainPolicy")]
    pub node_drain_policy: Option<DeviceConfigDriverUpgradePolicyNodeDrainPolicy>,
    /// Pod Deletion policy. If both NodeDrainPolicy and PodDeletionPolicy config is available, NodeDrainPolicy(if enabled) will take precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podDeletionPolicy")]
    pub pod_deletion_policy: Option<DeviceConfigDriverUpgradePolicyPodDeletionPolicy>,
    /// reboot between driver upgrades, enabled by default, if enabled spec.commonConfig.utilsContainer will be used to perform reboot on worker nodes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rebootRequired")]
    pub reboot_required: Option<bool>,
}

/// Node draining policy
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverUpgradePolicyNodeDrainPolicy {
    /// Force indicates if force draining is allowed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub force: Option<bool>,
    /// GracePeriodSeconds indicates the time kubernetes waits for a pod to shut down gracefully after receiving a termination signal
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gracePeriodSeconds")]
    pub grace_period_seconds: Option<i64>,
    /// TimeoutSecond specifies the length of time in seconds to wait before giving up drain, zero means infinite
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i64>,
}

/// Pod Deletion policy. If both NodeDrainPolicy and PodDeletionPolicy config is available, NodeDrainPolicy(if enabled) will take precedence.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverUpgradePolicyPodDeletionPolicy {
    /// Force indicates if force deletion is allowed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub force: Option<bool>,
    /// GracePeriodSeconds indicates the time kubernetes waits for a pod to shut down gracefully after receiving a termination signal
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gracePeriodSeconds")]
    pub grace_period_seconds: Option<i64>,
    /// TimeoutSecond specifies the length of time in seconds to wait before giving up on pod deletion, zero means infinite
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i64>,
}

/// vfio config
/// specify the specific configs for binding PCI devices to vfio-pci kernel module, applies for driver type vf-passthrough and pf-passthrough
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigDriverVfioConfig {
    /// list of PCI device IDs to load into vfio-pci driver. default is the list of AMD GPU PF/VF PCI device IDs based on driver type vf-passthrough/pf-passthrough.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceIDs")]
    pub device_i_ds: Option<Vec<String>>,
}

/// metrics exporter
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporter {
    /// optional configuration for metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<DeviceConfigMetricsExporterConfig>,
    /// enable metrics exporter, disabled by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// metrics exporter image
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// image pull policy for metrics exporter
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<DeviceConfigMetricsExporterImagePullPolicy>,
    /// metrics exporter image registry secret used to pull/push images
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistrySecret")]
    pub image_registry_secret: Option<DeviceConfigMetricsExporterImageRegistrySecret>,
    /// NodePort is the external port for pulling metrics from outside the cluster, in the range 30000-32767 (assigned automatically by default)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePort")]
    pub node_port: Option<i32>,
    /// Set the host path for pod-resource kubelet.socket,
    /// vanila kubernetes path is /var/lib/kubelet/pod-resources
    /// microk8s path is /var/snap/microk8s/common/var/lib/kubelet/pod-resources/
    /// path is an absolute unix path that allows a trailing slash
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podResourceAPISocketPath")]
    pub pod_resource_api_socket_path: Option<String>,
    /// Port is the internal port used for in-cluster and node access to pull metrics from the metrics-exporter (default 5000).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Prometheus configuration for metrics exporter
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prometheus: Option<DeviceConfigMetricsExporterPrometheus>,
    /// optional kube-rbac-proxy config to provide rbac services
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rbacConfig")]
    pub rbac_config: Option<DeviceConfigMetricsExporterRbacConfig>,
    /// Selector describes on which nodes to enable metrics exporter
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<BTreeMap<String, String>>,
    /// ServiceType service type for metrics, clusterIP/NodePort, clusterIP by default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceType")]
    pub service_type: Option<DeviceConfigMetricsExporterServiceType>,
    /// tolerations for metrics exporter
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<DeviceConfigMetricsExporterTolerations>>,
    /// upgrade policy for metrics exporter daemons
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradePolicy")]
    pub upgrade_policy: Option<DeviceConfigMetricsExporterUpgradePolicy>,
}

/// optional configuration for metrics
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterConfig {
    /// Name of the configMap that defines the list of metrics
    /// default list:[]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// metrics exporter
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigMetricsExporterImagePullPolicy {
    Always,
    IfNotPresent,
    Never,
}

/// metrics exporter image registry secret used to pull/push images
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterImageRegistrySecret {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Prometheus configuration for metrics exporter
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterPrometheus {
    /// ServiceMonitor configuration for Prometheus integration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceMonitor")]
    pub service_monitor: Option<DeviceConfigMetricsExporterPrometheusServiceMonitor>,
}

/// ServiceMonitor configuration for Prometheus integration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterPrometheusServiceMonitor {
    /// AttachMetadata defines if Prometheus should attach node metadata to the target
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "attachMetadata")]
    pub attach_metadata: Option<DeviceConfigMetricsExporterPrometheusServiceMonitorAttachMetadata>,
    /// Optional Prometheus authorization configuration for accessing the endpoint
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<DeviceConfigMetricsExporterPrometheusServiceMonitorAuthorization>,
    /// Path to bearer token file to be used by Prometheus (e.g., service account token path)
    /// Deprecated: Use Authorization instead. This field is kept for backward compatibility.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenFile")]
    pub bearer_token_file: Option<String>,
    /// Enable or disable ServiceMonitor creation (default false)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// HonorLabels chooses the metric's labels on collisions with target labels (default true)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorLabels")]
    pub honor_labels: Option<bool>,
    /// HonorTimestamps controls whether the scrape endpoints honor timestamps (default false)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorTimestamps")]
    pub honor_timestamps: Option<bool>,
    /// How frequently to scrape metrics. Accepts values with time unit suffix: "30s", "1m", "2h", "500ms"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Additional labels to add to the ServiceMonitor (default release: prometheus)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Relabeling rules applied to individual scraped metrics
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricRelabelings")]
    pub metric_relabelings: Option<Vec<DeviceConfigMetricsExporterPrometheusServiceMonitorMetricRelabelings>>,
    /// RelabelConfigs to apply to samples before ingestion
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub relabelings: Option<Vec<DeviceConfigMetricsExporterPrometheusServiceMonitorRelabelings>>,
    /// TLS settings used by Prometheus to connect to the metrics endpoint
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfig>,
}

/// AttachMetadata defines if Prometheus should attach node metadata to the target
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterPrometheusServiceMonitorAttachMetadata {
    /// When set to true, Prometheus attaches node metadata to the discovered
    /// targets.
    /// 
    /// The Prometheus service account must have the `list` and `watch`
    /// permissions on the `Nodes` objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node: Option<bool>,
}

/// Optional Prometheus authorization configuration for accessing the endpoint
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterPrometheusServiceMonitorAuthorization {
    /// Selects a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<DeviceConfigMetricsExporterPrometheusServiceMonitorAuthorizationCredentials>,
    /// Defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Selects a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterPrometheusServiceMonitorAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterPrometheusServiceMonitorMetricRelabelings {
    /// Action to perform based on the regex matching.
    /// 
    /// `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    /// `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
    /// 
    /// Default: "Replace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<DeviceConfigMetricsExporterPrometheusServiceMonitorMetricRelabelingsAction>,
    /// Modulus to take of the hash of the source label values.
    /// 
    /// Only applicable when the action is `HashMod`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// Replacement value against which a Replace action is performed if the
    /// regular expression matches.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator is the string between concatenated SourceLabels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is
    /// concatenated using the configured Separator and matched against the
    /// configured regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// Label to which the resulting string is written in a replacement.
    /// 
    /// It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    /// `KeepEqual` and `DropEqual` actions.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigMetricsExporterPrometheusServiceMonitorMetricRelabelingsAction {
    #[serde(rename = "replace")]
    Replace,
    #[serde(rename = "Replace")]
    ReplaceX,
    #[serde(rename = "keep")]
    Keep,
    #[serde(rename = "Keep")]
    KeepX,
    #[serde(rename = "drop")]
    Drop,
    #[serde(rename = "Drop")]
    DropX,
    #[serde(rename = "hashmod")]
    Hashmod,
    HashMod,
    #[serde(rename = "labelmap")]
    Labelmap,
    LabelMap,
    #[serde(rename = "labeldrop")]
    Labeldrop,
    LabelDrop,
    #[serde(rename = "labelkeep")]
    Labelkeep,
    LabelKeep,
    #[serde(rename = "lowercase")]
    Lowercase,
    #[serde(rename = "Lowercase")]
    LowercaseX,
    #[serde(rename = "uppercase")]
    Uppercase,
    #[serde(rename = "Uppercase")]
    UppercaseX,
    #[serde(rename = "keepequal")]
    Keepequal,
    KeepEqual,
    #[serde(rename = "dropequal")]
    Dropequal,
    DropEqual,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterPrometheusServiceMonitorRelabelings {
    /// Action to perform based on the regex matching.
    /// 
    /// `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    /// `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
    /// 
    /// Default: "Replace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<DeviceConfigMetricsExporterPrometheusServiceMonitorRelabelingsAction>,
    /// Modulus to take of the hash of the source label values.
    /// 
    /// Only applicable when the action is `HashMod`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// Replacement value against which a Replace action is performed if the
    /// regular expression matches.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator is the string between concatenated SourceLabels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is
    /// concatenated using the configured Separator and matched against the
    /// configured regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// Label to which the resulting string is written in a replacement.
    /// 
    /// It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    /// `KeepEqual` and `DropEqual` actions.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigMetricsExporterPrometheusServiceMonitorRelabelingsAction {
    #[serde(rename = "replace")]
    Replace,
    #[serde(rename = "Replace")]
    ReplaceX,
    #[serde(rename = "keep")]
    Keep,
    #[serde(rename = "Keep")]
    KeepX,
    #[serde(rename = "drop")]
    Drop,
    #[serde(rename = "Drop")]
    DropX,
    #[serde(rename = "hashmod")]
    Hashmod,
    HashMod,
    #[serde(rename = "labelmap")]
    Labelmap,
    LabelMap,
    #[serde(rename = "labeldrop")]
    Labeldrop,
    LabelDrop,
    #[serde(rename = "labelkeep")]
    Labelkeep,
    LabelKeep,
    #[serde(rename = "lowercase")]
    Lowercase,
    #[serde(rename = "Lowercase")]
    LowercaseX,
    #[serde(rename = "uppercase")]
    Uppercase,
    #[serde(rename = "Uppercase")]
    UppercaseX,
    #[serde(rename = "keepequal")]
    Keepequal,
    KeepEqual,
    #[serde(rename = "dropequal")]
    Dropequal,
    DropEqual,
}

/// TLS settings used by Prometheus to connect to the metrics endpoint
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfig {
    /// Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigCa>,
    /// Path to the CA cert in the Prometheus container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigCert>,
    /// Path to the client cert file in the Prometheus container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the Prometheus container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigKeySecret>,
    /// Maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigMaxVersion>,
    /// Minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigMinVersion>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS settings used by Prometheus to connect to the metrics endpoint
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// TLS settings used by Prometheus to connect to the metrics endpoint
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigMetricsExporterPrometheusServiceMonitorTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// optional kube-rbac-proxy config to provide rbac services
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterRbacConfig {
    /// Reference to a configmap containing the client CA (key: ca.crt) for mTLS client validation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCAConfigMap")]
    pub client_ca_config_map: Option<DeviceConfigMetricsExporterRbacConfigClientCaConfigMap>,
    /// disable https protecting the proxy endpoint
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableHttps")]
    pub disable_https: Option<bool>,
    /// enable kube-rbac-proxy, disabled by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// kube-rbac-proxy image
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// certificate secret to mount in kube-rbac container for TLS, self signed certificates will be generated by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<DeviceConfigMetricsExporterRbacConfigSecret>,
    /// Optional static RBAC rules based on client certificate Common Name (CN)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "staticAuthorization")]
    pub static_authorization: Option<DeviceConfigMetricsExporterRbacConfigStaticAuthorization>,
}

/// Reference to a configmap containing the client CA (key: ca.crt) for mTLS client validation
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterRbacConfigClientCaConfigMap {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// certificate secret to mount in kube-rbac container for TLS, self signed certificates will be generated by default
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterRbacConfigSecret {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Optional static RBAC rules based on client certificate Common Name (CN)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterRbacConfigStaticAuthorization {
    /// Expected CN (Common Name) from client cert (e.g., Prometheus SA identity)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientName")]
    pub client_name: Option<String>,
    /// Enables static authorization using client certificate CN
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
}

/// metrics exporter
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigMetricsExporterServiceType {
    #[serde(rename = "ClusterIP")]
    ClusterIp,
    NodePort,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// upgrade policy for metrics exporter daemons
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigMetricsExporterUpgradePolicy {
    /// MaxUnavailable specifies the maximum number of Pods that can be unavailable during the update process. Applicable for RollingUpdate only. Default value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<i32>,
    /// UpgradeStrategy specifies the type of the DaemonSet update. Valid values are "RollingUpdate" (default) or "OnDelete".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeStrategy")]
    pub upgrade_strategy: Option<DeviceConfigMetricsExporterUpgradePolicyUpgradeStrategy>,
}

/// upgrade policy for metrics exporter daemons
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigMetricsExporterUpgradePolicyUpgradeStrategy {
    RollingUpdate,
    OnDelete,
}

/// remediation workflow
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigRemediationWorkflow {
    /// Name of the ConfigMap that holds condition-to-workflow mappings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionalWorkflows")]
    pub conditional_workflows: Option<DeviceConfigRemediationWorkflowConditionalWorkflows>,
    /// enable remediation workflows. disabled by default
    /// enable if operator should automatically handle remediation of node incase of gpu issues
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// Time to live for argo workflow object and its pods for a failed workflow in hours. By default, it is set to 24 hours
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ttlForFailedWorkflows")]
    pub ttl_for_failed_workflows: Option<i64>,
}

/// Name of the ConfigMap that holds condition-to-workflow mappings.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigRemediationWorkflowConditionalWorkflows {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// test runner
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigTestRunner {
    /// config map to customize the config for test runner, if not specified default test config will be aplied
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<DeviceConfigTestRunnerConfig>,
    /// enable test runner, disabled by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// test runner image
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// image pull policy for test runner
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<DeviceConfigTestRunnerImagePullPolicy>,
    /// test runner image registry secret used to pull/push images
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistrySecret")]
    pub image_registry_secret: Option<DeviceConfigTestRunnerImageRegistrySecret>,
    /// captures logs location and export config for test runner logs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logsLocation")]
    pub logs_location: Option<DeviceConfigTestRunnerLogsLocation>,
    /// Selector describes on which nodes to enable test runner
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<BTreeMap<String, String>>,
    /// tolerations for test runner
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<DeviceConfigTestRunnerTolerations>>,
    /// upgrade policy for test runner daemonset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradePolicy")]
    pub upgrade_policy: Option<DeviceConfigTestRunnerUpgradePolicy>,
}

/// config map to customize the config for test runner, if not specified default test config will be aplied
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigTestRunnerConfig {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// test runner
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigTestRunnerImagePullPolicy {
    Always,
    IfNotPresent,
    Never,
}

/// test runner image registry secret used to pull/push images
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigTestRunnerImageRegistrySecret {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// captures logs location and export config for test runner logs
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigTestRunnerLogsLocation {
    /// host path to store test runner internal status db in order to persist test running status
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<String>,
    /// LogsExportSecrets is a list of secrets that contain connectivity info to multiple cloud providers
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logsExportSecrets")]
    pub logs_export_secrets: Option<Vec<DeviceConfigTestRunnerLogsLocationLogsExportSecrets>>,
    /// volume mount destination within test runner container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPath")]
    pub mount_path: Option<String>,
}

/// LocalObjectReference contains enough information to let you locate the
/// referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigTestRunnerLogsLocationLogsExportSecrets {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigTestRunnerTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// upgrade policy for test runner daemonset
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigTestRunnerUpgradePolicy {
    /// MaxUnavailable specifies the maximum number of Pods that can be unavailable during the update process. Applicable for RollingUpdate only. Default value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<i32>,
    /// UpgradeStrategy specifies the type of the DaemonSet update. Valid values are "RollingUpdate" (default) or "OnDelete".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeStrategy")]
    pub upgrade_strategy: Option<DeviceConfigTestRunnerUpgradePolicyUpgradeStrategy>,
}

/// upgrade policy for test runner daemonset
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DeviceConfigTestRunnerUpgradePolicyUpgradeStrategy {
    RollingUpdate,
    OnDelete,
}

/// DeviceConfigStatus defines the observed state of Module.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigStatus {
    /// Conditions list the current status of the DeviceConfig object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ConfigManager contains the status of the ConfigManager deployment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configManager")]
    pub config_manager: Option<DeviceConfigStatusConfigManager>,
    /// DevicePlugin contains the status of the Device Plugin deployment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "devicePlugin")]
    pub device_plugin: Option<DeviceConfigStatusDevicePlugin>,
    /// Driver contains the status of the Drivers deployment
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub driver: Option<DeviceConfigStatusDriver>,
    /// MetricsExporter contains the status of the MetricsExporter deployment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricsExporter")]
    pub metrics_exporter: Option<DeviceConfigStatusMetricsExporter>,
    /// NodeModuleStatus contains per node status of driver module installation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeModuleStatus")]
    pub node_module_status: Option<BTreeMap<String, DeviceConfigStatusNodeModuleStatus>>,
    /// ObservedGeneration is the latest spec generation successfully processed by the controller
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

/// ConfigManager contains the status of the ConfigManager deployment
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigStatusConfigManager {
    /// number of the actually deployed and running pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableNumber")]
    pub available_number: Option<i32>,
    /// number of the pods that should be deployed for daemonset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredNumber")]
    pub desired_number: Option<i32>,
    /// number of nodes that are targeted by the DeviceConfig selector
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodesMatchingSelectorNumber")]
    pub nodes_matching_selector_number: Option<i32>,
}

/// DevicePlugin contains the status of the Device Plugin deployment
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigStatusDevicePlugin {
    /// number of the actually deployed and running pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableNumber")]
    pub available_number: Option<i32>,
    /// number of the pods that should be deployed for daemonset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredNumber")]
    pub desired_number: Option<i32>,
    /// number of nodes that are targeted by the DeviceConfig selector
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodesMatchingSelectorNumber")]
    pub nodes_matching_selector_number: Option<i32>,
}

/// Driver contains the status of the Drivers deployment
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigStatusDriver {
    /// number of the actually deployed and running pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableNumber")]
    pub available_number: Option<i32>,
    /// number of the pods that should be deployed for daemonset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredNumber")]
    pub desired_number: Option<i32>,
    /// number of nodes that are targeted by the DeviceConfig selector
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodesMatchingSelectorNumber")]
    pub nodes_matching_selector_number: Option<i32>,
}

/// MetricsExporter contains the status of the MetricsExporter deployment
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigStatusMetricsExporter {
    /// number of the actually deployed and running pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableNumber")]
    pub available_number: Option<i32>,
    /// number of the pods that should be deployed for daemonset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredNumber")]
    pub desired_number: Option<i32>,
    /// number of nodes that are targeted by the DeviceConfig selector
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodesMatchingSelectorNumber")]
    pub nodes_matching_selector_number: Option<i32>,
}

/// NodeModuleStatus contains per node status of driver module installation
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DeviceConfigStatusNodeModuleStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootId")]
    pub boot_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerImage")]
    pub container_image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kernelVersion")]
    pub kernel_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastTransitionTime")]
    pub last_transition_time: Option<String>,
    /// UpgradeState captures the state of the upgrade process on a node
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradeStartTime")]
    pub upgrade_start_time: Option<String>,
}

