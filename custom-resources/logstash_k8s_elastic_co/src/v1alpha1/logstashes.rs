// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/elastic/cloud-on-k8s/logstash.k8s.elastic.co/v1alpha1/logstashes.yaml
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// LogstashSpec defines the desired state of Logstash
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "logstash.k8s.elastic.co", version = "v1alpha1", kind = "Logstash", plural = "logstashes")]
#[kube(namespaced)]
#[kube(status = "LogstashStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct LogstashSpec {
    /// Config holds the Logstash configuration. At most one of [`Config`, `ConfigRef`] can be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<BTreeMap<String, serde_json::Value>>,
    /// ConfigRef contains a reference to an existing Kubernetes Secret holding the Logstash configuration.
    /// Logstash settings must be specified as yaml, under a single "logstash.yml" entry. At most one of [`Config`, `ConfigRef`]
    /// can be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configRef")]
    pub config_ref: Option<LogstashConfigRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
    /// ElasticsearchRefs are references to Elasticsearch clusters running in the same Kubernetes cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "elasticsearchRefs")]
    pub elasticsearch_refs: Option<Vec<LogstashElasticsearchRefs>>,
    /// Image is the Logstash Docker image to deploy. Version and Type have to match the Logstash in the image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Monitoring enables you to collect and ship log and monitoring data of this Logstash.
    /// Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different
    /// Elasticsearch monitoring clusters running in the same Kubernetes cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub monitoring: Option<LogstashMonitoring>,
    /// Pipelines holds the Logstash Pipelines. At most one of [`Pipelines`, `PipelinesRef`] can be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pipelines: Option<Vec<LogstashPipelines>>,
    /// PipelinesRef contains a reference to an existing Kubernetes Secret holding the Logstash Pipelines.
    /// Logstash pipelines must be specified as yaml, under a single "pipelines.yml" entry. At most one of [`Pipelines`, `PipelinesRef`]
    /// can be specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pipelinesRef")]
    pub pipelines_ref: Option<LogstashPipelinesRef>,
    /// PodTemplate provides customisation options for the Logstash pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<BTreeMap<String, serde_json::Value>>,
    /// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying StatefulSet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "revisionHistoryLimit")]
    pub revision_history_limit: Option<i32>,
    /// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Logstash.
    /// Secrets data can be then referenced in the Logstash config using the Secret's keys or as specified in `Entries` field of
    /// each SecureSetting.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secureSettings")]
    pub secure_settings: Option<Vec<LogstashSecureSettings>>,
    /// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
    /// Can only be used if ECK is enforcing RBAC on references.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountName")]
    pub service_account_name: Option<String>,
    /// Services contains details of services that Logstash should expose - similar to the HTTP layer configuration for the
    /// rest of the stack, but also applicable for more use cases than the metrics API, as logstash may need to
    /// be opened up for other services: Beats, TCP, UDP, etc, inputs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<LogstashServices>>,
    /// UpdateStrategy is a StatefulSetUpdateStrategy. The default type is "RollingUpdate".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateStrategy")]
    pub update_strategy: Option<LogstashUpdateStrategy>,
    /// Version of the Logstash.
    pub version: String,
    /// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod.
    /// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
    /// Items defined here take precedence over any default claims added by the operator with the same name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplates")]
    pub volume_claim_templates: Option<Vec<LogstashVolumeClaimTemplates>>,
}

/// ConfigRef contains a reference to an existing Kubernetes Secret holding the Logstash configuration.
/// Logstash settings must be specified as yaml, under a single "logstash.yml" entry. At most one of [`Config`, `ConfigRef`]
/// can be specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashConfigRef {
    /// SecretName is the name of the secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// ElasticsearchCluster is a named reference to an Elasticsearch cluster which can be used in a Logstash pipeline.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashElasticsearchRefs {
    /// ClusterName is an alias for the cluster to be used to refer to the Elasticsearch cluster in Logstash
    /// configuration files, and will be used to identify "named clusters" in Logstash
    #[serde(rename = "clusterName")]
    pub cluster_name: String,
    /// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
    /// Elastic resource not managed by the operator.
    /// The referenced secret must contain the following:
    /// - `url`: the URL to reach the Elastic resource
    /// - `username`: the username of the user to be authenticated to the Elastic resource
    /// - `password`: the password of the user to be authenticated to the Elastic resource
    /// - `ca.crt`: the CA certificate in PEM format (optional)
    /// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
    /// This field cannot be used in combination with the other fields name, namespace or serviceName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
    /// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
    /// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
    /// the referenced resource is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

/// Monitoring enables you to collect and ship log and monitoring data of this Logstash.
/// Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different
/// Elasticsearch monitoring clusters running in the same Kubernetes cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashMonitoring {
    /// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub logs: Option<LogstashMonitoringLogs>,
    /// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<LogstashMonitoringMetrics>,
}

/// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashMonitoringLogs {
    /// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
    /// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "elasticsearchRefs")]
    pub elasticsearch_refs: Option<Vec<LogstashMonitoringLogsElasticsearchRefs>>,
}

/// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
/// or a Secret describing an external Elastic resource not managed by the operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashMonitoringLogsElasticsearchRefs {
    /// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
    /// Elastic resource not managed by the operator.
    /// The referenced secret must contain the following:
    /// - `url`: the URL to reach the Elastic resource
    /// - `username`: the username of the user to be authenticated to the Elastic resource
    /// - `password`: the password of the user to be authenticated to the Elastic resource
    /// - `ca.crt`: the CA certificate in PEM format (optional)
    /// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
    /// This field cannot be used in combination with the other fields name, namespace or serviceName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
    /// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
    /// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
    /// the referenced resource is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

/// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashMonitoringMetrics {
    /// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
    /// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "elasticsearchRefs")]
    pub elasticsearch_refs: Option<Vec<LogstashMonitoringMetricsElasticsearchRefs>>,
}

/// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
/// or a Secret describing an external Elastic resource not managed by the operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashMonitoringMetricsElasticsearchRefs {
    /// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
    /// Elastic resource not managed by the operator.
    /// The referenced secret must contain the following:
    /// - `url`: the URL to reach the Elastic resource
    /// - `username`: the username of the user to be authenticated to the Elastic resource
    /// - `password`: the password of the user to be authenticated to the Elastic resource
    /// - `ca.crt`: the CA certificate in PEM format (optional)
    /// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
    /// This field cannot be used in combination with the other fields name, namespace or serviceName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
    /// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
    /// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
    /// the referenced resource is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashPipelines {
}

/// PipelinesRef contains a reference to an existing Kubernetes Secret holding the Logstash Pipelines.
/// Logstash pipelines must be specified as yaml, under a single "pipelines.yml" entry. At most one of [`Pipelines`, `PipelinesRef`]
/// can be specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashPipelinesRef {
    /// SecretName is the name of the secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// SecretSource defines a data source based on a Kubernetes Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashSecureSettings {
    /// Entries define how to project each key-value pair in the secret to filesystem paths.
    /// If not defined, all keys will be projected to similarly named paths in the filesystem.
    /// If defined, only the specified keys will be projected to the corresponding paths.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entries: Option<Vec<LogstashSecureSettingsEntries>>,
    /// SecretName is the name of the secret.
    #[serde(rename = "secretName")]
    pub secret_name: String,
}

/// KeyToPath defines how to map a key in a Secret object to a filesystem path.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashSecureSettingsEntries {
    /// Key is the key contained in the secret.
    pub key: String,
    /// Path is the relative file path to map the key to.
    /// Path must not be an absolute file path and must not contain any ".." components.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashServices {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Service defines the template for the associated Kubernetes Service object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<LogstashServicesService>,
    /// TLS defines options for configuring TLS for HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<LogstashServicesTls>,
}

/// Service defines the template for the associated Kubernetes Service object.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashServicesService {
    /// ObjectMeta is the metadata of the service.
    /// The name and namespace provided here are managed by ECK and will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<LogstashServicesServiceMetadata>,
    /// Spec is the specification of the service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<LogstashServicesServiceSpec>,
}

/// ObjectMeta is the metadata of the service.
/// The name and namespace provided here are managed by ECK and will be ignored.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashServicesServiceMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub finalizers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Spec is the specification of the service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashServicesServiceSpec {
    /// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
    /// allocated for services with type LoadBalancer.  Default is "true". It
    /// may be set to "false" if the cluster load-balancer does not rely on
    /// NodePorts.  If the caller requests specific NodePorts (by specifying a
    /// value), those requests will be respected, regardless of this field.
    /// This field may only be set for services with type LoadBalancer and will
    /// be cleared if the type is changed to any other type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allocateLoadBalancerNodePorts")]
    pub allocate_load_balancer_node_ports: Option<bool>,
    /// clusterIP is the IP address of the service and is usually assigned
    /// randomly. If an address is specified manually, is in-range (as per
    /// system configuration), and is not in use, it will be allocated to the
    /// service; otherwise creation of the service will fail. This field may not
    /// be changed through updates unless the type field is also being changed
    /// to ExternalName (which requires this field to be blank) or the type
    /// field is being changed from ExternalName (in which case this field may
    /// optionally be specified, as describe above).  Valid values are "None",
    /// empty string (""), or a valid IP address. Setting this to "None" makes a
    /// "headless service" (no virtual IP), which is useful when direct endpoint
    /// connections are preferred and proxying is not required.  Only applies to
    /// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
    /// when creating a Service of type ExternalName, creation will fail. This
    /// field will be wiped when updating a Service to type ExternalName.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterIP")]
    pub cluster_ip: Option<String>,
    /// ClusterIPs is a list of IP addresses assigned to this service, and are
    /// usually assigned randomly.  If an address is specified manually, is
    /// in-range (as per system configuration), and is not in use, it will be
    /// allocated to the service; otherwise creation of the service will fail.
    /// This field may not be changed through updates unless the type field is
    /// also being changed to ExternalName (which requires this field to be
    /// empty) or the type field is being changed from ExternalName (in which
    /// case this field may optionally be specified, as describe above).  Valid
    /// values are "None", empty string (""), or a valid IP address.  Setting
    /// this to "None" makes a "headless service" (no virtual IP), which is
    /// useful when direct endpoint connections are preferred and proxying is
    /// not required.  Only applies to types ClusterIP, NodePort, and
    /// LoadBalancer. If this field is specified when creating a Service of type
    /// ExternalName, creation will fail. This field will be wiped when updating
    /// a Service to type ExternalName.  If this field is not specified, it will
    /// be initialized from the clusterIP field.  If this field is specified,
    /// clients must ensure that clusterIPs[0] and clusterIP have the same
    /// value.
    /// 
    /// This field may hold a maximum of two entries (dual-stack IPs, in either order).
    /// These IPs must correspond to the values of the ipFamilies field. Both
    /// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterIPs")]
    pub cluster_i_ps: Option<Vec<String>>,
    /// externalIPs is a list of IP addresses for which nodes in the cluster
    /// will also accept traffic for this service.  These IPs are not managed by
    /// Kubernetes.  The user is responsible for ensuring that traffic arrives
    /// at a node with this IP.  A common example is external load-balancers
    /// that are not part of the Kubernetes system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIPs")]
    pub external_i_ps: Option<Vec<String>>,
    /// externalName is the external reference that discovery mechanisms will
    /// return as an alias for this service (e.g. a DNS CNAME record). No
    /// proxying will be involved.  Must be a lowercase RFC-1123 hostname
    /// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalName")]
    pub external_name: Option<String>,
    /// externalTrafficPolicy describes how nodes distribute service traffic they
    /// receive on one of the Service's "externally-facing" addresses (NodePorts,
    /// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
    /// the service in a way that assumes that external load balancers will take care
    /// of balancing the service traffic between nodes, and so each node will deliver
    /// traffic only to the node-local endpoints of the service, without masquerading
    /// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
    /// be dropped.) The default value, "Cluster", uses the standard behavior of
    /// routing to all endpoints evenly (possibly modified by topology and other
    /// features). Note that traffic sent to an External IP or LoadBalancer IP from
    /// within the cluster will always get "Cluster" semantics, but clients sending to
    /// a NodePort from within the cluster may need to take traffic policy into account
    /// when picking a node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalTrafficPolicy")]
    pub external_traffic_policy: Option<String>,
    /// healthCheckNodePort specifies the healthcheck nodePort for the service.
    /// This only applies when type is set to LoadBalancer and
    /// externalTrafficPolicy is set to Local. If a value is specified, is
    /// in-range, and is not in use, it will be used.  If not specified, a value
    /// will be automatically allocated.  External systems (e.g. load-balancers)
    /// can use this port to determine if a given node holds endpoints for this
    /// service or not.  If this field is specified when creating a Service
    /// which does not need it, creation will fail. This field will be wiped
    /// when updating a Service to no longer need it (e.g. changing type).
    /// This field cannot be updated once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckNodePort")]
    pub health_check_node_port: Option<i32>,
    /// InternalTrafficPolicy describes how nodes distribute service traffic they
    /// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
    /// only want to talk to endpoints of the service on the same node as the pod,
    /// dropping the traffic if there are no local endpoints. The default value,
    /// "Cluster", uses the standard behavior of routing to all endpoints evenly
    /// (possibly modified by topology and other features).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalTrafficPolicy")]
    pub internal_traffic_policy: Option<String>,
    /// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
    /// service. This field is usually assigned automatically based on cluster
    /// configuration and the ipFamilyPolicy field. If this field is specified
    /// manually, the requested family is available in the cluster,
    /// and ipFamilyPolicy allows it, it will be used; otherwise creation of
    /// the service will fail. This field is conditionally mutable: it allows
    /// for adding or removing a secondary IP family, but it does not allow
    /// changing the primary IP family of the Service. Valid values are "IPv4"
    /// and "IPv6".  This field only applies to Services of types ClusterIP,
    /// NodePort, and LoadBalancer, and does apply to "headless" services.
    /// This field will be wiped when updating a Service to type ExternalName.
    /// 
    /// This field may hold a maximum of two entries (dual-stack families, in
    /// either order).  These families must correspond to the values of the
    /// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
    /// governed by the ipFamilyPolicy field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipFamilies")]
    pub ip_families: Option<Vec<String>>,
    /// IPFamilyPolicy represents the dual-stack-ness requested or required by
    /// this Service. If there is no value provided, then this field will be set
    /// to SingleStack. Services can be "SingleStack" (a single IP family),
    /// "PreferDualStack" (two IP families on dual-stack configured clusters or
    /// a single IP family on single-stack clusters), or "RequireDualStack"
    /// (two IP families on dual-stack configured clusters, otherwise fail). The
    /// ipFamilies and clusterIPs fields depend on the value of this field. This
    /// field will be wiped when updating a service to type ExternalName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipFamilyPolicy")]
    pub ip_family_policy: Option<String>,
    /// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
    /// If specified, the value of this field must be a label-style identifier, with an optional prefix,
    /// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
    /// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
    /// balancer implementation is used, today this is typically done through the cloud provider integration,
    /// but should apply for any default implementation. If set, it is assumed that a load balancer
    /// implementation is watching for Services with a matching class. Any default load balancer
    /// implementation (e.g. cloud providers) should ignore Services that set this field.
    /// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
    /// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerClass")]
    pub load_balancer_class: Option<String>,
    /// Only applies to Service Type: LoadBalancer.
    /// This feature depends on whether the underlying cloud-provider supports specifying
    /// the loadBalancerIP when a load balancer is created.
    /// This field will be ignored if the cloud-provider does not support the feature.
    /// Deprecated: This field was under-specified and its meaning varies across implementations.
    /// Using it is non-portable and it may not support dual-stack.
    /// Users are encouraged to use implementation-specific annotations when available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerIP")]
    pub load_balancer_ip: Option<String>,
    /// If specified and supported by the platform, this will restrict traffic through the cloud-provider
    /// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
    /// cloud-provider does not support the feature."
    /// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerSourceRanges")]
    pub load_balancer_source_ranges: Option<Vec<String>>,
    /// The list of ports that are exposed by this service.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<LogstashServicesServiceSpecPorts>>,
    /// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
    /// Service should disregard any indications of ready/not-ready.
    /// The primary use case for setting this field is for a StatefulSet's Headless Service to
    /// propagate SRV DNS records for its Pods for the purpose of peer discovery.
    /// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
    /// Services interpret this to mean that all endpoints are considered "ready" even if the
    /// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
    /// through the Endpoints or EndpointSlice resources can safely assume this behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishNotReadyAddresses")]
    pub publish_not_ready_addresses: Option<bool>,
    /// Route service traffic to pods with label keys and values matching this
    /// selector. If empty or not present, the service is assumed to have an
    /// external process managing its endpoints, which Kubernetes will not
    /// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
    /// Ignored if type is ExternalName.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<BTreeMap<String, String>>,
    /// Supports "ClientIP" and "None". Used to maintain session affinity.
    /// Enable client IP based session affinity.
    /// Must be ClientIP or None.
    /// Defaults to None.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionAffinity")]
    pub session_affinity: Option<String>,
    /// sessionAffinityConfig contains the configurations of session affinity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionAffinityConfig")]
    pub session_affinity_config: Option<LogstashServicesServiceSpecSessionAffinityConfig>,
    /// TrafficDistribution offers a way to express preferences for how traffic
    /// is distributed to Service endpoints. Implementations can use this field
    /// as a hint, but are not required to guarantee strict adherence. If the
    /// field is not set, the implementation will apply its default routing
    /// strategy. If set to "PreferClose", implementations should prioritize
    /// endpoints that are in the same zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trafficDistribution")]
    pub traffic_distribution: Option<String>,
    /// type determines how the Service is exposed. Defaults to ClusterIP. Valid
    /// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
    /// "ClusterIP" allocates a cluster-internal IP address for load-balancing
    /// to endpoints. Endpoints are determined by the selector or if that is not
    /// specified, by manual construction of an Endpoints object or
    /// EndpointSlice objects. If clusterIP is "None", no virtual IP is
    /// allocated and the endpoints are published as a set of endpoints rather
    /// than a virtual IP.
    /// "NodePort" builds on ClusterIP and allocates a port on every node which
    /// routes to the same endpoints as the clusterIP.
    /// "LoadBalancer" builds on NodePort and creates an external load-balancer
    /// (if supported in the current cloud) which routes to the same endpoints
    /// as the clusterIP.
    /// "ExternalName" aliases this service to the specified externalName.
    /// Several other fields do not apply to ExternalName services.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// ServicePort contains information on service's port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashServicesServiceSpecPorts {
    /// The application protocol for this port.
    /// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
    /// This field follows standard Kubernetes label syntax.
    /// Valid values are either:
    /// 
    /// * Un-prefixed protocol names - reserved for IANA standard service names (as per
    /// RFC-6335 and https://www.iana.org/assignments/service-names).
    /// 
    /// * Kubernetes-defined prefixed names:
    ///   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
    ///   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
    ///   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
    /// 
    /// * Other protocols should use implementation-defined prefixed names such as
    /// mycompany.com/my-custom-protocol.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appProtocol")]
    pub app_protocol: Option<String>,
    /// The name of this port within the service. This must be a DNS_LABEL.
    /// All ports within a ServiceSpec must have unique names. When considering
    /// the endpoints for a Service, this must match the 'name' field in the
    /// EndpointPort.
    /// Optional if only one ServicePort is defined on this service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The port on each node on which this service is exposed when type is
    /// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
    /// specified, in-range, and not in use it will be used, otherwise the
    /// operation will fail.  If not specified, a port will be allocated if this
    /// Service requires one.  If this field is specified when creating a
    /// Service which does not need it, creation will fail. This field will be
    /// wiped when updating a Service to no longer need it (e.g. changing type
    /// from NodePort to ClusterIP).
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePort")]
    pub node_port: Option<i32>,
    /// The port that will be exposed by this service.
    pub port: i32,
    /// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
    /// Default is TCP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
    /// Number or name of the port to access on the pods targeted by the service.
    /// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
    /// If this is a string, it will be looked up as a named port in the
    /// target Pod's container ports. If this is not specified, the value
    /// of the 'port' field is used (an identity map).
    /// This field is ignored for services with clusterIP=None, and should be
    /// omitted or set equal to the 'port' field.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPort")]
    pub target_port: Option<IntOrString>,
}

/// sessionAffinityConfig contains the configurations of session affinity.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashServicesServiceSpecSessionAffinityConfig {
    /// clientIP contains the configurations of Client IP based session affinity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientIP")]
    pub client_ip: Option<LogstashServicesServiceSpecSessionAffinityConfigClientIp>,
}

/// clientIP contains the configurations of Client IP based session affinity.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashServicesServiceSpecSessionAffinityConfigClientIp {
    /// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
    /// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
    /// Default value is 10800(for 3 hours).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// TLS defines options for configuring TLS for HTTP.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashServicesTls {
    /// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
    /// The referenced secret should contain the following:
    /// 
    /// - `ca.crt`: The certificate authority (optional).
    /// - `tls.crt`: The certificate (or a chain).
    /// - `tls.key`: The private key to the first certificate in the certificate chain.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<LogstashServicesTlsCertificate>,
    /// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfSignedCertificate")]
    pub self_signed_certificate: Option<LogstashServicesTlsSelfSignedCertificate>,
}

/// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
/// The referenced secret should contain the following:
/// 
/// - `ca.crt`: The certificate authority (optional).
/// - `tls.crt`: The certificate (or a chain).
/// - `tls.key`: The private key to the first certificate in the certificate chain.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashServicesTlsCertificate {
    /// SecretName is the name of the secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashServicesTlsSelfSignedCertificate {
    /// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectAltNames")]
    pub subject_alt_names: Option<Vec<LogstashServicesTlsSelfSignedCertificateSubjectAltNames>>,
}

/// SubjectAlternativeName represents a SAN entry in a x509 certificate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashServicesTlsSelfSignedCertificateSubjectAltNames {
    /// DNS is the DNS name of the subject.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dns: Option<String>,
    /// IP is the IP address of the subject.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<String>,
}

/// UpdateStrategy is a StatefulSetUpdateStrategy. The default type is "RollingUpdate".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashUpdateStrategy {
    /// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rollingUpdate")]
    pub rolling_update: Option<LogstashUpdateStrategyRollingUpdate>,
    /// Type indicates the type of the StatefulSetUpdateStrategy.
    /// Default is RollingUpdate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashUpdateStrategyRollingUpdate {
    /// The maximum number of pods that can be unavailable during the update.
    /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
    /// Absolute number is calculated from percentage by rounding up. This can not be 0.
    /// Defaults to 1. This field is alpha-level and is only honored by servers that enable the
    /// MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
    /// Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
    /// will be counted towards MaxUnavailable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
    /// Partition indicates the ordinal at which the StatefulSet should be partitioned
    /// for updates. During a rolling update, all pods from ordinal Replicas-1 to
    /// Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
    /// This is helpful in being able to do a canary based deployment. The default value is 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
}

/// PersistentVolumeClaim is a user's request for and claim to a persistent volume
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashVolumeClaimTemplates {
    /// APIVersion defines the versioned schema of this representation of an object.
    /// Servers should convert recognized schemas to the latest internal value, and
    /// may reject unrecognized values.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Kind is a string value representing the REST resource this object represents.
    /// Servers may infer this from the endpoint the client submits requests to.
    /// Cannot be updated.
    /// In CamelCase.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<LogstashVolumeClaimTemplatesMetadata>,
    /// spec defines the desired characteristics of a volume requested by a pod author.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<LogstashVolumeClaimTemplatesSpec>,
    /// status represents the current information/status of a persistent volume claim.
    /// Read-only.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<LogstashVolumeClaimTemplatesStatus>,
}

/// Standard object's metadata.
/// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashVolumeClaimTemplatesMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub finalizers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// spec defines the desired characteristics of a volume requested by a pod author.
/// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashVolumeClaimTemplatesSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<LogstashVolumeClaimTemplatesSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<LogstashVolumeClaimTemplatesSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<LogstashVolumeClaimTemplatesSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<LogstashVolumeClaimTemplatesSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
    /// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
    /// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
    /// will be set by the persistentvolume controller if it exists.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
    /// (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashVolumeClaimTemplatesSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashVolumeClaimTemplatesSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashVolumeClaimTemplatesSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashVolumeClaimTemplatesSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<LogstashVolumeClaimTemplatesSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashVolumeClaimTemplatesSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// status represents the current information/status of a persistent volume claim.
/// Read-only.
/// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashVolumeClaimTemplatesStatus {
    /// accessModes contains the actual access modes the volume backing the PVC has.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// allocatedResourceStatuses stores status of resource being resized for the given PVC.
    /// Key names follow standard Kubernetes label syntax. Valid values are either:
    /// 	* Un-prefixed keys:
    /// 		- storage - the capacity of the volume.
    /// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
    /// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
    /// reserved and hence may not be used.
    /// 
    /// ClaimResourceStatus can be in any of following states:
    /// 	- ControllerResizeInProgress:
    /// 		State set when resize controller starts resizing the volume in control-plane.
    /// 	- ControllerResizeFailed:
    /// 		State set when resize has failed in resize controller with a terminal error.
    /// 	- NodeResizePending:
    /// 		State set when resize controller has finished resizing the volume but further resizing of
    /// 		volume is needed on the node.
    /// 	- NodeResizeInProgress:
    /// 		State set when kubelet starts resizing the volume.
    /// 	- NodeResizeFailed:
    /// 		State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
    /// 		NodeResizeFailed.
    /// For example: if expanding a PVC for more capacity - this field can be one of the following states:
    /// 	- pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
    ///      - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
    ///      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
    ///      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
    ///      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
    /// When this field is not set, it means that no resize operation is in progress for the given PVC.
    /// 
    /// A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
    /// should ignore the update for the purpose it was designed. For example - a controller that
    /// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
    /// resources associated with PVC.
    /// 
    /// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allocatedResourceStatuses")]
    pub allocated_resource_statuses: Option<BTreeMap<String, String>>,
    /// allocatedResources tracks the resources allocated to a PVC including its capacity.
    /// Key names follow standard Kubernetes label syntax. Valid values are either:
    /// 	* Un-prefixed keys:
    /// 		- storage - the capacity of the volume.
    /// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
    /// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
    /// reserved and hence may not be used.
    /// 
    /// Capacity reported here may be larger than the actual capacity when a volume expansion operation
    /// is requested.
    /// For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
    /// If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
    /// If a volume expansion capacity request is lowered, allocatedResources is only
    /// lowered if there are no expansion operations in progress and if the actual volume capacity
    /// is equal or lower than the requested capacity.
    /// 
    /// A controller that receives PVC update with previously unknown resourceName
    /// should ignore the update for the purpose it was designed. For example - a controller that
    /// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
    /// resources associated with PVC.
    /// 
    /// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allocatedResources")]
    pub allocated_resources: Option<BTreeMap<String, IntOrString>>,
    /// capacity represents the actual resources of the underlying volume.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capacity: Option<BTreeMap<String, IntOrString>>,
    /// conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
    /// resized then the Condition will be set to 'Resizing'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
    /// When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
    /// This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "currentVolumeAttributesClassName")]
    pub current_volume_attributes_class_name: Option<String>,
    /// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
    /// When this is unset, there is no ModifyVolume operation being attempted.
    /// This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modifyVolumeStatus")]
    pub modify_volume_status: Option<LogstashVolumeClaimTemplatesStatusModifyVolumeStatus>,
    /// phase represents the current phase of PersistentVolumeClaim.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<String>,
}

/// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
/// When this is unset, there is no ModifyVolume operation being attempted.
/// This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashVolumeClaimTemplatesStatusModifyVolumeStatus {
    /// status is the status of the ControllerModifyVolume operation. It can be in any of following states:
    ///  - Pending
    ///    Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
    ///    the specified VolumeAttributesClass not existing.
    ///  - InProgress
    ///    InProgress indicates that the volume is being modified.
    ///  - Infeasible
    ///   Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
    /// 	  resolve the error, a valid VolumeAttributesClass needs to be specified.
    /// Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
    pub status: String,
    /// targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetVolumeAttributesClassName")]
    pub target_volume_attributes_class_name: Option<String>,
}

/// LogstashStatus defines the observed state of Logstash
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LogstashStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableNodes")]
    pub available_nodes: Option<i32>,
    /// ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "elasticsearchAssociationsStatus")]
    pub elasticsearch_associations_status: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expectedNodes")]
    pub expected_nodes: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub health: Option<String>,
    /// MonitoringAssociationStatus is the status of any auto-linking to monitoring Elasticsearch clusters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitoringAssociationStatus")]
    pub monitoring_association_status: Option<BTreeMap<String, String>>,
    /// ObservedGeneration is the most recent generation observed for this Logstash instance.
    /// It corresponds to the metadata generation, which is updated on mutation by the API Server.
    /// If the generation observed in status diverges from the generation in metadata, the Logstash
    /// controller has not yet processed the changes contained in the Logstash specification.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    pub selector: String,
    /// Version of the stack resource currently running. During version upgrades, multiple versions may run
    /// in parallel: this value specifies the lowest version currently running.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

