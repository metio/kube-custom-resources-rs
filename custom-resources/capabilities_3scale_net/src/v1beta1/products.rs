// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/3scale/3scale-operator/capabilities.3scale.net/v1beta1/products.yaml
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ProductSpec defines the desired state of Product
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "capabilities.3scale.net", version = "v1beta1", kind = "Product", plural = "products")]
#[kube(namespaced)]
#[kube(status = "ProductStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ProductSpec {
    /// Application Plans
    /// Map: system_name -> Application Plan Spec
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationPlans")]
    pub application_plans: Option<BTreeMap<String, ProductApplicationPlans>>,
    /// Backend usage will be a map of
    /// Map: system_name -> BackendUsageSpec
    /// Having system_name as the index, the structure ensures one backend is not used multiple times.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendUsages")]
    pub backend_usages: Option<BTreeMap<String, ProductBackendUsages>>,
    /// Deployment defined 3scale product deployment mode
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<ProductDeployment>,
    /// Description is a human readable text of the product
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Mapping Rules
    /// Array: MappingRule Spec
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mappingRules")]
    pub mapping_rules: Option<Vec<ProductMappingRules>>,
    /// Methods
    /// Map: system_name -> MethodSpec
    /// system_name attr is unique for all metrics AND methods
    /// In other words, if metric's system_name is A, there is no metric or method with system_name A.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub methods: Option<BTreeMap<String, ProductMethods>>,
    /// Metrics
    /// Map: system_name -> MetricSpec
    /// system_name attr is unique for all metrics AND methods
    /// In other words, if metric's system_name is A, there is no metric or method with system_name A.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<BTreeMap<String, ProductMetrics>>,
    /// Name is human readable name for the product
    pub name: String,
    /// Policies holds the product's policy chain
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policies: Option<Vec<ProductPolicies>>,
    /// ProviderAccountRef references account provider credentials
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerAccountRef")]
    pub provider_account_ref: Option<ProductProviderAccountRef>,
    /// SystemName identifies uniquely the product within the account provider
    /// Default value will be sanitized Name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "systemName")]
    pub system_name: Option<String>,
}

/// Application Plans
/// Map: system_name -> Application Plan Spec
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductApplicationPlans {
    /// Set whether or not applications can be created on demand
    /// or if approval is required from you before they are activated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appsRequireApproval")]
    pub apps_require_approval: Option<bool>,
    /// Cost per Month (USD)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "costMonth")]
    pub cost_month: Option<String>,
    /// Limits
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<Vec<ProductApplicationPlansLimits>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Pricing Rules
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pricingRules")]
    pub pricing_rules: Option<Vec<ProductApplicationPlansPricingRules>>,
    /// Controls whether the application plan is published. If not specified it is
    /// hidden by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub published: Option<bool>,
    /// Setup fee (USD)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "setupFee")]
    pub setup_fee: Option<String>,
    /// Trial Period (days)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trialPeriod")]
    pub trial_period: Option<i64>,
}

/// LimitSpec defines the maximum value a metric can take on a contract before the user is no longer authorized to use resources.
/// Once a limit has been passed in a given period, reject messages will be issued if the service is accessed under this contract.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ProductApplicationPlansLimits {
    /// Metric or Method Reference
    #[serde(rename = "metricMethodRef")]
    pub metric_method_ref: ProductApplicationPlansLimitsMetricMethodRef,
    /// Limit Period
    pub period: ProductApplicationPlansLimitsPeriod,
    /// Limit Value
    pub value: i64,
}

/// Metric or Method Reference
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductApplicationPlansLimitsMetricMethodRef {
    /// BackendSystemName identifies uniquely the backend
    /// Backend reference must be used by the product
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub backend: Option<String>,
    /// SystemName identifies uniquely the metric or methods
    #[serde(rename = "systemName")]
    pub system_name: String,
}

/// LimitSpec defines the maximum value a metric can take on a contract before the user is no longer authorized to use resources.
/// Once a limit has been passed in a given period, reject messages will be issued if the service is accessed under this contract.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ProductApplicationPlansLimitsPeriod {
    #[serde(rename = "eternity")]
    Eternity,
    #[serde(rename = "year")]
    Year,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "minute")]
    Minute,
}

/// PricingRuleSpec defines the cost of each operation performed on an API.
/// Multiple pricing rules on the same metric divide up the ranges of when a pricing rule applies.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductApplicationPlansPricingRules {
    /// Range From
    pub from: i64,
    /// Metric or Method Reference
    #[serde(rename = "metricMethodRef")]
    pub metric_method_ref: ProductApplicationPlansPricingRulesMetricMethodRef,
    /// Price per unit (USD)
    #[serde(rename = "pricePerUnit")]
    pub price_per_unit: String,
    /// Range To
    pub to: i64,
}

/// Metric or Method Reference
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductApplicationPlansPricingRulesMetricMethodRef {
    /// BackendSystemName identifies uniquely the backend
    /// Backend reference must be used by the product
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub backend: Option<String>,
    /// SystemName identifies uniquely the metric or methods
    #[serde(rename = "systemName")]
    pub system_name: String,
}

/// Backend usage will be a map of
/// Map: system_name -> BackendUsageSpec
/// Having system_name as the index, the structure ensures one backend is not used multiple times.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductBackendUsages {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// Deployment defined 3scale product deployment mode
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeployment {
    /// ApicastHostedSpec defines the desired state of Product Apicast Hosted
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apicastHosted")]
    pub apicast_hosted: Option<ProductDeploymentApicastHosted>,
    /// ApicastSelfManagedSpec defines the desired state of Product Apicast Self Managed
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apicastSelfManaged")]
    pub apicast_self_managed: Option<ProductDeploymentApicastSelfManaged>,
}

/// ApicastHostedSpec defines the desired state of Product Apicast Hosted
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastHosted {
    /// AuthenticationSpec defines the desired state of Product Authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<ProductDeploymentApicastHostedAuthentication>,
}

/// AuthenticationSpec defines the desired state of Product Authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastHostedAuthentication {
    /// AppKeyAppIDAuthenticationSpec defines the desired state of AppKey&AppId Authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appKeyAppID")]
    pub app_key_app_id: Option<ProductDeploymentApicastHostedAuthenticationAppKeyAppId>,
    /// OIDCSpec defines the desired configuration of OpenID Connect Authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oidc: Option<ProductDeploymentApicastHostedAuthenticationOidc>,
    /// UserKeyAuthenticationSpec defines the desired state of User Key Authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub userkey: Option<ProductDeploymentApicastHostedAuthenticationUserkey>,
}

/// AppKeyAppIDAuthenticationSpec defines the desired state of AppKey&AppId Authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastHostedAuthenticationAppKeyAppId {
    /// AppID is the name of the parameter that acts of behalf of app id
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appID")]
    pub app_id: Option<String>,
    /// AppKey is the name of the parameter that acts of behalf of app key
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appKey")]
    pub app_key: Option<String>,
    /// CredentialsLoc available options:
    /// headers: As HTTP Headers
    /// query: As query parameters (GET) or body parameters (POST/PUT/DELETE)
    /// authorization: As HTTP Basic Authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ProductDeploymentApicastHostedAuthenticationAppKeyAppIdCredentials>,
    /// GatewayResponseSpec defines the desired gateway response configuration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayResponse")]
    pub gateway_response: Option<ProductDeploymentApicastHostedAuthenticationAppKeyAppIdGatewayResponse>,
    /// SecuritySpec defines the desired state of Authentication Security
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<ProductDeploymentApicastHostedAuthenticationAppKeyAppIdSecurity>,
}

/// AppKeyAppIDAuthenticationSpec defines the desired state of AppKey&AppId Authentication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ProductDeploymentApicastHostedAuthenticationAppKeyAppIdCredentials {
    #[serde(rename = "headers")]
    Headers,
    #[serde(rename = "query")]
    Query,
    #[serde(rename = "authorization")]
    Authorization,
}

/// GatewayResponseSpec defines the desired gateway response configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastHostedAuthenticationAppKeyAppIdGatewayResponse {
    /// ErrorAuthFailed specifies the response body when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorAuthFailed")]
    pub error_auth_failed: Option<String>,
    /// ErrorAuthMissing specifies the response body when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorAuthMissing")]
    pub error_auth_missing: Option<String>,
    /// ErrorHeadersAuthFailed specifies the Content-Type header when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersAuthFailed")]
    pub error_headers_auth_failed: Option<String>,
    /// ErrorHeadersAuthMissing specifies the Content-Type header when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersAuthMissing")]
    pub error_headers_auth_missing: Option<String>,
    /// ErrorHeadersLimitsExceeded specifies the Content-Type header when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersLimitsExceeded")]
    pub error_headers_limits_exceeded: Option<String>,
    /// ErrorHeadersNoMatch specifies the Content-Type header when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersNoMatch")]
    pub error_headers_no_match: Option<String>,
    /// ErrorLimitsExceeded specifies the response body when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorLimitsExceeded")]
    pub error_limits_exceeded: Option<String>,
    /// ErrorNoMatch specifies the response body when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorNoMatch")]
    pub error_no_match: Option<String>,
    /// ErrorStatusAuthFailed specifies the response code when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusAuthFailed")]
    pub error_status_auth_failed: Option<i32>,
    /// ErrorStatusAuthMissing specifies the response code when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusAuthMissing")]
    pub error_status_auth_missing: Option<i32>,
    /// ErrorStatusLimitsExceeded specifies the response code when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusLimitsExceeded")]
    pub error_status_limits_exceeded: Option<i32>,
    /// ErrorStatusNoMatch specifies the response code when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusNoMatch")]
    pub error_status_no_match: Option<i32>,
}

/// SecuritySpec defines the desired state of Authentication Security
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastHostedAuthenticationAppKeyAppIdSecurity {
    /// HostHeader Lets you define a custom Host request header. This is needed if your API backend only accepts traffic from a specific host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostHeader")]
    pub host_header: Option<String>,
    /// SecretToken Enables you to block any direct developer requests to your API backend;
    /// each 3scale API gateway call to your API backend contains a request header called X-3scale-proxy-secret-token.
    /// The value of this header can be set by you here. It's up to you ensure your backend only allows calls with this secret header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretToken")]
    pub secret_token: Option<String>,
}

/// OIDCSpec defines the desired configuration of OpenID Connect Authentication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ProductDeploymentApicastHostedAuthenticationOidc {
    /// AuthenticationFlow specifies OAuth2.0 authorization grant type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authenticationFlow")]
    pub authentication_flow: Option<ProductDeploymentApicastHostedAuthenticationOidcAuthenticationFlow>,
    /// Credentials Location available options:
    /// headers: As HTTP Headers
    /// query: As query parameters (GET) or body parameters (POST/PUT/DELETE)
    /// authorization: As HTTP Basic Authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ProductDeploymentApicastHostedAuthenticationOidcCredentials>,
    /// GatewayResponseSpec defines the desired gateway response configuration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayResponse")]
    pub gateway_response: Option<ProductDeploymentApicastHostedAuthenticationOidcGatewayResponse>,
    /// Issuer is the OIDC issuer
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerEndpoint")]
    pub issuer_endpoint: Option<String>,
    /// IssuerEndpointRef  is the reference to OIDC issuer Secret that contains IssuerEndpoint
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerEndpointRef")]
    pub issuer_endpoint_ref: Option<ProductDeploymentApicastHostedAuthenticationOidcIssuerEndpointRef>,
    /// IssuerType is the type of the OIDC issuer
    #[serde(rename = "issuerType")]
    pub issuer_type: ProductDeploymentApicastHostedAuthenticationOidcIssuerType,
    /// JwtClaimWithClientID is the JSON Web Token (JWT) Claim with ClientID that contains the clientID. Defaults to 'azp'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jwtClaimWithClientID")]
    pub jwt_claim_with_client_id: Option<String>,
    /// JwtClaimWithClientIDType sets to process the ClientID Token Claim value as a string or as a liquid template.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jwtClaimWithClientIDType")]
    pub jwt_claim_with_client_id_type: Option<ProductDeploymentApicastHostedAuthenticationOidcJwtClaimWithClientIdType>,
    /// SecuritySpec defines the desired state of Authentication Security
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<ProductDeploymentApicastHostedAuthenticationOidcSecurity>,
}

/// AuthenticationFlow specifies OAuth2.0 authorization grant type
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastHostedAuthenticationOidcAuthenticationFlow {
    #[serde(rename = "directAccessGrantsEnabled")]
    pub direct_access_grants_enabled: bool,
    #[serde(rename = "implicitFlowEnabled")]
    pub implicit_flow_enabled: bool,
    #[serde(rename = "serviceAccountsEnabled")]
    pub service_accounts_enabled: bool,
    /// OIDCIssuer is the OIDC issuer
    #[serde(rename = "standardFlowEnabled")]
    pub standard_flow_enabled: bool,
}

/// OIDCSpec defines the desired configuration of OpenID Connect Authentication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ProductDeploymentApicastHostedAuthenticationOidcCredentials {
    #[serde(rename = "headers")]
    Headers,
    #[serde(rename = "query")]
    Query,
    #[serde(rename = "authorization")]
    Authorization,
}

/// GatewayResponseSpec defines the desired gateway response configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastHostedAuthenticationOidcGatewayResponse {
    /// ErrorAuthFailed specifies the response body when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorAuthFailed")]
    pub error_auth_failed: Option<String>,
    /// ErrorAuthMissing specifies the response body when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorAuthMissing")]
    pub error_auth_missing: Option<String>,
    /// ErrorHeadersAuthFailed specifies the Content-Type header when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersAuthFailed")]
    pub error_headers_auth_failed: Option<String>,
    /// ErrorHeadersAuthMissing specifies the Content-Type header when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersAuthMissing")]
    pub error_headers_auth_missing: Option<String>,
    /// ErrorHeadersLimitsExceeded specifies the Content-Type header when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersLimitsExceeded")]
    pub error_headers_limits_exceeded: Option<String>,
    /// ErrorHeadersNoMatch specifies the Content-Type header when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersNoMatch")]
    pub error_headers_no_match: Option<String>,
    /// ErrorLimitsExceeded specifies the response body when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorLimitsExceeded")]
    pub error_limits_exceeded: Option<String>,
    /// ErrorNoMatch specifies the response body when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorNoMatch")]
    pub error_no_match: Option<String>,
    /// ErrorStatusAuthFailed specifies the response code when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusAuthFailed")]
    pub error_status_auth_failed: Option<i32>,
    /// ErrorStatusAuthMissing specifies the response code when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusAuthMissing")]
    pub error_status_auth_missing: Option<i32>,
    /// ErrorStatusLimitsExceeded specifies the response code when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusLimitsExceeded")]
    pub error_status_limits_exceeded: Option<i32>,
    /// ErrorStatusNoMatch specifies the response code when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusNoMatch")]
    pub error_status_no_match: Option<i32>,
}

/// IssuerEndpointRef  is the reference to OIDC issuer Secret that contains IssuerEndpoint
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastHostedAuthenticationOidcIssuerEndpointRef {
    /// name is unique within a namespace to reference a secret resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// namespace defines the space within which the secret name must be unique.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// OIDCSpec defines the desired configuration of OpenID Connect Authentication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ProductDeploymentApicastHostedAuthenticationOidcIssuerType {
    #[serde(rename = "keycloak")]
    Keycloak,
    #[serde(rename = "rest")]
    Rest,
}

/// OIDCSpec defines the desired configuration of OpenID Connect Authentication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ProductDeploymentApicastHostedAuthenticationOidcJwtClaimWithClientIdType {
    #[serde(rename = "plain")]
    Plain,
    #[serde(rename = "liquid")]
    Liquid,
}

/// SecuritySpec defines the desired state of Authentication Security
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastHostedAuthenticationOidcSecurity {
    /// HostHeader Lets you define a custom Host request header. This is needed if your API backend only accepts traffic from a specific host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostHeader")]
    pub host_header: Option<String>,
    /// SecretToken Enables you to block any direct developer requests to your API backend;
    /// each 3scale API gateway call to your API backend contains a request header called X-3scale-proxy-secret-token.
    /// The value of this header can be set by you here. It's up to you ensure your backend only allows calls with this secret header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretToken")]
    pub secret_token: Option<String>,
}

/// UserKeyAuthenticationSpec defines the desired state of User Key Authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastHostedAuthenticationUserkey {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authUserKey")]
    pub auth_user_key: Option<String>,
    /// Credentials Location available options:
    /// headers: As HTTP Headers
    /// query: As query parameters (GET) or body parameters (POST/PUT/DELETE)
    /// authorization: As HTTP Basic Authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ProductDeploymentApicastHostedAuthenticationUserkeyCredentials>,
    /// GatewayResponseSpec defines the desired gateway response configuration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayResponse")]
    pub gateway_response: Option<ProductDeploymentApicastHostedAuthenticationUserkeyGatewayResponse>,
    /// SecuritySpec defines the desired state of Authentication Security
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<ProductDeploymentApicastHostedAuthenticationUserkeySecurity>,
}

/// UserKeyAuthenticationSpec defines the desired state of User Key Authentication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ProductDeploymentApicastHostedAuthenticationUserkeyCredentials {
    #[serde(rename = "headers")]
    Headers,
    #[serde(rename = "query")]
    Query,
    #[serde(rename = "authorization")]
    Authorization,
}

/// GatewayResponseSpec defines the desired gateway response configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastHostedAuthenticationUserkeyGatewayResponse {
    /// ErrorAuthFailed specifies the response body when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorAuthFailed")]
    pub error_auth_failed: Option<String>,
    /// ErrorAuthMissing specifies the response body when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorAuthMissing")]
    pub error_auth_missing: Option<String>,
    /// ErrorHeadersAuthFailed specifies the Content-Type header when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersAuthFailed")]
    pub error_headers_auth_failed: Option<String>,
    /// ErrorHeadersAuthMissing specifies the Content-Type header when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersAuthMissing")]
    pub error_headers_auth_missing: Option<String>,
    /// ErrorHeadersLimitsExceeded specifies the Content-Type header when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersLimitsExceeded")]
    pub error_headers_limits_exceeded: Option<String>,
    /// ErrorHeadersNoMatch specifies the Content-Type header when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersNoMatch")]
    pub error_headers_no_match: Option<String>,
    /// ErrorLimitsExceeded specifies the response body when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorLimitsExceeded")]
    pub error_limits_exceeded: Option<String>,
    /// ErrorNoMatch specifies the response body when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorNoMatch")]
    pub error_no_match: Option<String>,
    /// ErrorStatusAuthFailed specifies the response code when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusAuthFailed")]
    pub error_status_auth_failed: Option<i32>,
    /// ErrorStatusAuthMissing specifies the response code when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusAuthMissing")]
    pub error_status_auth_missing: Option<i32>,
    /// ErrorStatusLimitsExceeded specifies the response code when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusLimitsExceeded")]
    pub error_status_limits_exceeded: Option<i32>,
    /// ErrorStatusNoMatch specifies the response code when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusNoMatch")]
    pub error_status_no_match: Option<i32>,
}

/// SecuritySpec defines the desired state of Authentication Security
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastHostedAuthenticationUserkeySecurity {
    /// HostHeader Lets you define a custom Host request header. This is needed if your API backend only accepts traffic from a specific host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostHeader")]
    pub host_header: Option<String>,
    /// SecretToken Enables you to block any direct developer requests to your API backend;
    /// each 3scale API gateway call to your API backend contains a request header called X-3scale-proxy-secret-token.
    /// The value of this header can be set by you here. It's up to you ensure your backend only allows calls with this secret header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretToken")]
    pub secret_token: Option<String>,
}

/// ApicastSelfManagedSpec defines the desired state of Product Apicast Self Managed
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastSelfManaged {
    /// AuthenticationSpec defines the desired state of Product Authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<ProductDeploymentApicastSelfManagedAuthentication>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "productionPublicBaseURL")]
    pub production_public_base_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stagingPublicBaseURL")]
    pub staging_public_base_url: Option<String>,
}

/// AuthenticationSpec defines the desired state of Product Authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastSelfManagedAuthentication {
    /// AppKeyAppIDAuthenticationSpec defines the desired state of AppKey&AppId Authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appKeyAppID")]
    pub app_key_app_id: Option<ProductDeploymentApicastSelfManagedAuthenticationAppKeyAppId>,
    /// OIDCSpec defines the desired configuration of OpenID Connect Authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oidc: Option<ProductDeploymentApicastSelfManagedAuthenticationOidc>,
    /// UserKeyAuthenticationSpec defines the desired state of User Key Authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub userkey: Option<ProductDeploymentApicastSelfManagedAuthenticationUserkey>,
}

/// AppKeyAppIDAuthenticationSpec defines the desired state of AppKey&AppId Authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastSelfManagedAuthenticationAppKeyAppId {
    /// AppID is the name of the parameter that acts of behalf of app id
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appID")]
    pub app_id: Option<String>,
    /// AppKey is the name of the parameter that acts of behalf of app key
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appKey")]
    pub app_key: Option<String>,
    /// CredentialsLoc available options:
    /// headers: As HTTP Headers
    /// query: As query parameters (GET) or body parameters (POST/PUT/DELETE)
    /// authorization: As HTTP Basic Authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ProductDeploymentApicastSelfManagedAuthenticationAppKeyAppIdCredentials>,
    /// GatewayResponseSpec defines the desired gateway response configuration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayResponse")]
    pub gateway_response: Option<ProductDeploymentApicastSelfManagedAuthenticationAppKeyAppIdGatewayResponse>,
    /// SecuritySpec defines the desired state of Authentication Security
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<ProductDeploymentApicastSelfManagedAuthenticationAppKeyAppIdSecurity>,
}

/// AppKeyAppIDAuthenticationSpec defines the desired state of AppKey&AppId Authentication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ProductDeploymentApicastSelfManagedAuthenticationAppKeyAppIdCredentials {
    #[serde(rename = "headers")]
    Headers,
    #[serde(rename = "query")]
    Query,
    #[serde(rename = "authorization")]
    Authorization,
}

/// GatewayResponseSpec defines the desired gateway response configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastSelfManagedAuthenticationAppKeyAppIdGatewayResponse {
    /// ErrorAuthFailed specifies the response body when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorAuthFailed")]
    pub error_auth_failed: Option<String>,
    /// ErrorAuthMissing specifies the response body when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorAuthMissing")]
    pub error_auth_missing: Option<String>,
    /// ErrorHeadersAuthFailed specifies the Content-Type header when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersAuthFailed")]
    pub error_headers_auth_failed: Option<String>,
    /// ErrorHeadersAuthMissing specifies the Content-Type header when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersAuthMissing")]
    pub error_headers_auth_missing: Option<String>,
    /// ErrorHeadersLimitsExceeded specifies the Content-Type header when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersLimitsExceeded")]
    pub error_headers_limits_exceeded: Option<String>,
    /// ErrorHeadersNoMatch specifies the Content-Type header when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersNoMatch")]
    pub error_headers_no_match: Option<String>,
    /// ErrorLimitsExceeded specifies the response body when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorLimitsExceeded")]
    pub error_limits_exceeded: Option<String>,
    /// ErrorNoMatch specifies the response body when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorNoMatch")]
    pub error_no_match: Option<String>,
    /// ErrorStatusAuthFailed specifies the response code when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusAuthFailed")]
    pub error_status_auth_failed: Option<i32>,
    /// ErrorStatusAuthMissing specifies the response code when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusAuthMissing")]
    pub error_status_auth_missing: Option<i32>,
    /// ErrorStatusLimitsExceeded specifies the response code when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusLimitsExceeded")]
    pub error_status_limits_exceeded: Option<i32>,
    /// ErrorStatusNoMatch specifies the response code when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusNoMatch")]
    pub error_status_no_match: Option<i32>,
}

/// SecuritySpec defines the desired state of Authentication Security
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastSelfManagedAuthenticationAppKeyAppIdSecurity {
    /// HostHeader Lets you define a custom Host request header. This is needed if your API backend only accepts traffic from a specific host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostHeader")]
    pub host_header: Option<String>,
    /// SecretToken Enables you to block any direct developer requests to your API backend;
    /// each 3scale API gateway call to your API backend contains a request header called X-3scale-proxy-secret-token.
    /// The value of this header can be set by you here. It's up to you ensure your backend only allows calls with this secret header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretToken")]
    pub secret_token: Option<String>,
}

/// OIDCSpec defines the desired configuration of OpenID Connect Authentication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ProductDeploymentApicastSelfManagedAuthenticationOidc {
    /// AuthenticationFlow specifies OAuth2.0 authorization grant type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authenticationFlow")]
    pub authentication_flow: Option<ProductDeploymentApicastSelfManagedAuthenticationOidcAuthenticationFlow>,
    /// Credentials Location available options:
    /// headers: As HTTP Headers
    /// query: As query parameters (GET) or body parameters (POST/PUT/DELETE)
    /// authorization: As HTTP Basic Authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ProductDeploymentApicastSelfManagedAuthenticationOidcCredentials>,
    /// GatewayResponseSpec defines the desired gateway response configuration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayResponse")]
    pub gateway_response: Option<ProductDeploymentApicastSelfManagedAuthenticationOidcGatewayResponse>,
    /// Issuer is the OIDC issuer
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerEndpoint")]
    pub issuer_endpoint: Option<String>,
    /// IssuerEndpointRef  is the reference to OIDC issuer Secret that contains IssuerEndpoint
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerEndpointRef")]
    pub issuer_endpoint_ref: Option<ProductDeploymentApicastSelfManagedAuthenticationOidcIssuerEndpointRef>,
    /// IssuerType is the type of the OIDC issuer
    #[serde(rename = "issuerType")]
    pub issuer_type: ProductDeploymentApicastSelfManagedAuthenticationOidcIssuerType,
    /// JwtClaimWithClientID is the JSON Web Token (JWT) Claim with ClientID that contains the clientID. Defaults to 'azp'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jwtClaimWithClientID")]
    pub jwt_claim_with_client_id: Option<String>,
    /// JwtClaimWithClientIDType sets to process the ClientID Token Claim value as a string or as a liquid template.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jwtClaimWithClientIDType")]
    pub jwt_claim_with_client_id_type: Option<ProductDeploymentApicastSelfManagedAuthenticationOidcJwtClaimWithClientIdType>,
    /// SecuritySpec defines the desired state of Authentication Security
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<ProductDeploymentApicastSelfManagedAuthenticationOidcSecurity>,
}

/// AuthenticationFlow specifies OAuth2.0 authorization grant type
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastSelfManagedAuthenticationOidcAuthenticationFlow {
    #[serde(rename = "directAccessGrantsEnabled")]
    pub direct_access_grants_enabled: bool,
    #[serde(rename = "implicitFlowEnabled")]
    pub implicit_flow_enabled: bool,
    #[serde(rename = "serviceAccountsEnabled")]
    pub service_accounts_enabled: bool,
    /// OIDCIssuer is the OIDC issuer
    #[serde(rename = "standardFlowEnabled")]
    pub standard_flow_enabled: bool,
}

/// OIDCSpec defines the desired configuration of OpenID Connect Authentication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ProductDeploymentApicastSelfManagedAuthenticationOidcCredentials {
    #[serde(rename = "headers")]
    Headers,
    #[serde(rename = "query")]
    Query,
    #[serde(rename = "authorization")]
    Authorization,
}

/// GatewayResponseSpec defines the desired gateway response configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastSelfManagedAuthenticationOidcGatewayResponse {
    /// ErrorAuthFailed specifies the response body when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorAuthFailed")]
    pub error_auth_failed: Option<String>,
    /// ErrorAuthMissing specifies the response body when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorAuthMissing")]
    pub error_auth_missing: Option<String>,
    /// ErrorHeadersAuthFailed specifies the Content-Type header when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersAuthFailed")]
    pub error_headers_auth_failed: Option<String>,
    /// ErrorHeadersAuthMissing specifies the Content-Type header when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersAuthMissing")]
    pub error_headers_auth_missing: Option<String>,
    /// ErrorHeadersLimitsExceeded specifies the Content-Type header when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersLimitsExceeded")]
    pub error_headers_limits_exceeded: Option<String>,
    /// ErrorHeadersNoMatch specifies the Content-Type header when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersNoMatch")]
    pub error_headers_no_match: Option<String>,
    /// ErrorLimitsExceeded specifies the response body when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorLimitsExceeded")]
    pub error_limits_exceeded: Option<String>,
    /// ErrorNoMatch specifies the response body when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorNoMatch")]
    pub error_no_match: Option<String>,
    /// ErrorStatusAuthFailed specifies the response code when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusAuthFailed")]
    pub error_status_auth_failed: Option<i32>,
    /// ErrorStatusAuthMissing specifies the response code when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusAuthMissing")]
    pub error_status_auth_missing: Option<i32>,
    /// ErrorStatusLimitsExceeded specifies the response code when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusLimitsExceeded")]
    pub error_status_limits_exceeded: Option<i32>,
    /// ErrorStatusNoMatch specifies the response code when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusNoMatch")]
    pub error_status_no_match: Option<i32>,
}

/// IssuerEndpointRef  is the reference to OIDC issuer Secret that contains IssuerEndpoint
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastSelfManagedAuthenticationOidcIssuerEndpointRef {
    /// name is unique within a namespace to reference a secret resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// namespace defines the space within which the secret name must be unique.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// OIDCSpec defines the desired configuration of OpenID Connect Authentication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ProductDeploymentApicastSelfManagedAuthenticationOidcIssuerType {
    #[serde(rename = "keycloak")]
    Keycloak,
    #[serde(rename = "rest")]
    Rest,
}

/// OIDCSpec defines the desired configuration of OpenID Connect Authentication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ProductDeploymentApicastSelfManagedAuthenticationOidcJwtClaimWithClientIdType {
    #[serde(rename = "plain")]
    Plain,
    #[serde(rename = "liquid")]
    Liquid,
}

/// SecuritySpec defines the desired state of Authentication Security
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastSelfManagedAuthenticationOidcSecurity {
    /// HostHeader Lets you define a custom Host request header. This is needed if your API backend only accepts traffic from a specific host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostHeader")]
    pub host_header: Option<String>,
    /// SecretToken Enables you to block any direct developer requests to your API backend;
    /// each 3scale API gateway call to your API backend contains a request header called X-3scale-proxy-secret-token.
    /// The value of this header can be set by you here. It's up to you ensure your backend only allows calls with this secret header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretToken")]
    pub secret_token: Option<String>,
}

/// UserKeyAuthenticationSpec defines the desired state of User Key Authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastSelfManagedAuthenticationUserkey {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authUserKey")]
    pub auth_user_key: Option<String>,
    /// Credentials Location available options:
    /// headers: As HTTP Headers
    /// query: As query parameters (GET) or body parameters (POST/PUT/DELETE)
    /// authorization: As HTTP Basic Authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ProductDeploymentApicastSelfManagedAuthenticationUserkeyCredentials>,
    /// GatewayResponseSpec defines the desired gateway response configuration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayResponse")]
    pub gateway_response: Option<ProductDeploymentApicastSelfManagedAuthenticationUserkeyGatewayResponse>,
    /// SecuritySpec defines the desired state of Authentication Security
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<ProductDeploymentApicastSelfManagedAuthenticationUserkeySecurity>,
}

/// UserKeyAuthenticationSpec defines the desired state of User Key Authentication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ProductDeploymentApicastSelfManagedAuthenticationUserkeyCredentials {
    #[serde(rename = "headers")]
    Headers,
    #[serde(rename = "query")]
    Query,
    #[serde(rename = "authorization")]
    Authorization,
}

/// GatewayResponseSpec defines the desired gateway response configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastSelfManagedAuthenticationUserkeyGatewayResponse {
    /// ErrorAuthFailed specifies the response body when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorAuthFailed")]
    pub error_auth_failed: Option<String>,
    /// ErrorAuthMissing specifies the response body when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorAuthMissing")]
    pub error_auth_missing: Option<String>,
    /// ErrorHeadersAuthFailed specifies the Content-Type header when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersAuthFailed")]
    pub error_headers_auth_failed: Option<String>,
    /// ErrorHeadersAuthMissing specifies the Content-Type header when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersAuthMissing")]
    pub error_headers_auth_missing: Option<String>,
    /// ErrorHeadersLimitsExceeded specifies the Content-Type header when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersLimitsExceeded")]
    pub error_headers_limits_exceeded: Option<String>,
    /// ErrorHeadersNoMatch specifies the Content-Type header when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorHeadersNoMatch")]
    pub error_headers_no_match: Option<String>,
    /// ErrorLimitsExceeded specifies the response body when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorLimitsExceeded")]
    pub error_limits_exceeded: Option<String>,
    /// ErrorNoMatch specifies the response body when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorNoMatch")]
    pub error_no_match: Option<String>,
    /// ErrorStatusAuthFailed specifies the response code when authentication fails
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusAuthFailed")]
    pub error_status_auth_failed: Option<i32>,
    /// ErrorStatusAuthMissing specifies the response code when authentication is missing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusAuthMissing")]
    pub error_status_auth_missing: Option<i32>,
    /// ErrorStatusLimitsExceeded specifies the response code when usage limit exceeded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusLimitsExceeded")]
    pub error_status_limits_exceeded: Option<i32>,
    /// ErrorStatusNoMatch specifies the response code when no match error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorStatusNoMatch")]
    pub error_status_no_match: Option<i32>,
}

/// SecuritySpec defines the desired state of Authentication Security
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductDeploymentApicastSelfManagedAuthenticationUserkeySecurity {
    /// HostHeader Lets you define a custom Host request header. This is needed if your API backend only accepts traffic from a specific host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostHeader")]
    pub host_header: Option<String>,
    /// SecretToken Enables you to block any direct developer requests to your API backend;
    /// each 3scale API gateway call to your API backend contains a request header called X-3scale-proxy-secret-token.
    /// The value of this header can be set by you here. It's up to you ensure your backend only allows calls with this secret header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretToken")]
    pub secret_token: Option<String>,
}

/// MappingRuleSpec defines the desired state of Product's MappingRule
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ProductMappingRules {
    #[serde(rename = "httpMethod")]
    pub http_method: ProductMappingRulesHttpMethod,
    pub increment: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last: Option<bool>,
    #[serde(rename = "metricMethodRef")]
    pub metric_method_ref: String,
    pub pattern: String,
}

/// MappingRuleSpec defines the desired state of Product's MappingRule
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ProductMappingRulesHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "CONNECT")]
    Connect,
}

/// Methods
/// Map: system_name -> MethodSpec
/// system_name attr is unique for all metrics AND methods
/// In other words, if metric's system_name is A, there is no metric or method with system_name A.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductMethods {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "friendlyName")]
    pub friendly_name: Option<String>,
}

/// Metrics
/// Map: system_name -> MetricSpec
/// system_name attr is unique for all metrics AND methods
/// In other words, if metric's system_name is A, there is no metric or method with system_name A.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductMetrics {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "friendlyName")]
    pub friendly_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unit: Option<String>,
}

/// PolicyConfig defines policy definition
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductPolicies {
    /// Configuration defines the policy configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configuration: Option<BTreeMap<String, serde_json::Value>>,
    /// ConfigurationRef Secret reference containing policy configuration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configurationRef")]
    pub configuration_ref: Option<ProductPoliciesConfigurationRef>,
    /// Enabled defines activation state
    pub enabled: bool,
    /// Name defines the policy unique name
    pub name: String,
    /// Version defines the policy version
    pub version: String,
}

/// ConfigurationRef Secret reference containing policy configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductPoliciesConfigurationRef {
    /// name is unique within a namespace to reference a secret resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// namespace defines the space within which the secret name must be unique.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// ProviderAccountRef references account provider credentials
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductProviderAccountRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// ProductStatus defines the observed state of Product
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ProductStatus {
    /// Current state of the 3scale product.
    /// Conditions represent the latest available observations of an object's state
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration reflects the generation of the most recently observed Product Spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "productId")]
    pub product_id: Option<i64>,
    /// 3scale control plane host
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerAccountHost")]
    pub provider_account_host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
}

