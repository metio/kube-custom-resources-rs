// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/percona/percona-postgresql-operator/pgv2.percona.com/v2/perconapgbackups.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
}
use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "pgv2.percona.com", version = "v2", kind = "PerconaPGBackup", plural = "perconapgbackups")]
#[kube(namespaced)]
#[kube(status = "PerconaPgBackupStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct PerconaPgBackupSpec {
    /// Command line options to include when running the pgBackRest backup command.
    /// <https://pgbackrest.org/command.html#command-backup>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<String>>,
    #[serde(rename = "pgCluster")]
    pub pg_cluster: String,
    /// The name of the pgBackRest repo to run the backup command against.
    #[serde(rename = "repoName")]
    pub repo_name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PerconaPgBackupStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupName")]
    pub backup_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupType")]
    pub backup_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub completed: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crVersion")]
    pub cr_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub destination: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jobName")]
    pub job_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "latestRestorableTime")]
    pub latest_restorable_time: Option<String>,
    /// PGBackRestRepo represents a pgBackRest repository.  Only one of its members may be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repo: Option<PerconaPgBackupStatusRepo>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageType")]
    pub storage_type: Option<String>,
}

/// PGBackRestRepo represents a pgBackRest repository.  Only one of its members may be specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PerconaPgBackupStatusRepo {
    /// Represents a pgBackRest repository that is created using Azure storage
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub azure: Option<PerconaPgBackupStatusRepoAzure>,
    /// Represents a pgBackRest repository that is created using Google Cloud Storage
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gcs: Option<PerconaPgBackupStatusRepoGcs>,
    /// The name of the repository
    pub name: String,
    /// RepoS3 represents a pgBackRest repository that is created using AWS S3 (or S3-compatible)
    /// storage
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<PerconaPgBackupStatusRepoS3>,
    /// Defines the schedules for the pgBackRest backups
    /// Full, Differential and Incremental backup types are supported:
    /// <https://pgbackrest.org/user-guide.html#concept/backup>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schedules: Option<PerconaPgBackupStatusRepoSchedules>,
    /// Represents a pgBackRest repository that is created using a PersistentVolumeClaim
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volume: Option<PerconaPgBackupStatusRepoVolume>,
}

/// Represents a pgBackRest repository that is created using Azure storage
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PerconaPgBackupStatusRepoAzure {
    /// The Azure container utilized for the repository
    pub container: String,
}

/// Represents a pgBackRest repository that is created using Google Cloud Storage
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PerconaPgBackupStatusRepoGcs {
    /// The GCS bucket utilized for the repository
    pub bucket: String,
}

/// RepoS3 represents a pgBackRest repository that is created using AWS S3 (or S3-compatible)
/// storage
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PerconaPgBackupStatusRepoS3 {
    /// The S3 bucket utilized for the repository
    pub bucket: String,
    /// A valid endpoint corresponding to the specified region
    pub endpoint: String,
    /// The region corresponding to the S3 bucket
    pub region: String,
}

/// Defines the schedules for the pgBackRest backups
/// Full, Differential and Incremental backup types are supported:
/// <https://pgbackrest.org/user-guide.html#concept/backup>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PerconaPgBackupStatusRepoSchedules {
    /// Defines the Cron schedule for a differential pgBackRest backup.
    /// Follows the standard Cron schedule syntax:
    /// <https://k8s.io/docs/concepts/workloads/controllers/cron-jobs/#cron-schedule-syntax>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub differential: Option<String>,
    /// Defines the Cron schedule for a full pgBackRest backup.
    /// Follows the standard Cron schedule syntax:
    /// <https://k8s.io/docs/concepts/workloads/controllers/cron-jobs/#cron-schedule-syntax>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full: Option<String>,
    /// Defines the Cron schedule for an incremental pgBackRest backup.
    /// Follows the standard Cron schedule syntax:
    /// <https://k8s.io/docs/concepts/workloads/controllers/cron-jobs/#cron-schedule-syntax>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub incremental: Option<String>,
}

/// Represents a pgBackRest repository that is created using a PersistentVolumeClaim
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PerconaPgBackupStatusRepoVolume {
    /// Defines a PersistentVolumeClaim spec used to create and/or bind a volume
    #[serde(rename = "volumeClaimSpec")]
    pub volume_claim_spec: PerconaPgBackupStatusRepoVolumeVolumeClaimSpec,
}

/// Defines a PersistentVolumeClaim spec used to create and/or bind a volume
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PerconaPgBackupStatusRepoVolumeVolumeClaimSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<PerconaPgBackupStatusRepoVolumeVolumeClaimSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<PerconaPgBackupStatusRepoVolumeVolumeClaimSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// Users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PerconaPgBackupStatusRepoVolumeVolumeClaimSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<PerconaPgBackupStatusRepoVolumeVolumeClaimSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string or nil value indicates that no
    /// VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
    /// this field can be reset to its previous value (including nil) to cancel the modification.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PerconaPgBackupStatusRepoVolumeVolumeClaimSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PerconaPgBackupStatusRepoVolumeVolumeClaimSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// Users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PerconaPgBackupStatusRepoVolumeVolumeClaimSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PerconaPgBackupStatusRepoVolumeVolumeClaimSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PerconaPgBackupStatusRepoVolumeVolumeClaimSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PerconaPgBackupStatusRepoVolumeVolumeClaimSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

