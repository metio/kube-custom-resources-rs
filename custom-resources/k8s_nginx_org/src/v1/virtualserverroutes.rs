// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/nginxinc/kubernetes-ingress/k8s.nginx.org/v1/virtualserverroutes.yaml
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// VirtualServerRouteSpec is the spec of the VirtualServerRoute resource.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "k8s.nginx.org", version = "v1", kind = "VirtualServerRoute", plural = "virtualserverroutes")]
#[kube(namespaced)]
#[kube(status = "VirtualServerRouteStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct VirtualServerRouteSpec {
    /// The host (domain name) of the server. Must be a valid subdomain as defined in RFC 1123, such as my-app or hello.example.com. When using a wildcard domain like *.example.com the domain must be contained in double quotes. Must be the same as the host of the VirtualServer that references this resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Specifies which Ingress Controller must handle the VirtualServerRoute resource. Must be the same as the ingressClassName of the VirtualServer that references this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressClassName")]
    pub ingress_class_name: Option<String>,
    /// A list of subroutes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subroutes: Option<Vec<VirtualServerRouteSubroutes>>,
    /// A list of upstreams.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub upstreams: Option<Vec<VirtualServerRouteUpstreams>>,
}

/// Route defines a route.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutes {
    /// The default action to perform for a request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<VirtualServerRouteSubroutesAction>,
    /// A reference to a DosProtectedResource, setting this enables DOS protection of the VirtualServer route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dos: Option<String>,
    /// The custom responses for error codes. NGINX will use those responses instead of returning the error responses from the upstream servers or the default responses generated by NGINX. A custom response can be a redirect or a canned response. For example, a redirect to another URL if an upstream server responded with a 404 status code.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorPages")]
    pub error_pages: Option<Vec<VirtualServerRouteSubroutesErrorPages>>,
    /// Sets a custom snippet in the location context. Overrides the location-snippets ConfigMap key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "location-snippets")]
    pub location_snippets: Option<String>,
    /// The matching rules for advanced content-based routing. Requires the default Action or Splits. Unmatched requests will be handled by the default Action or Splits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<VirtualServerRouteSubroutesMatches>>,
    /// The path of the route. NGINX will match it against the URI of a request. Possible values are: a prefix ( / , /path ), an exact match ( =/exact/match ), a case insensitive regular expression ( ~*^/Bar.*\.jpg ) or a case sensitive regular expression ( ~^/foo.*\.jpg ). In the case of a prefix (must start with / ) or an exact match (must start with = ), the path must not include any whitespace characters, { , } or ;. In the case of the regex matches, all double quotes " must be escaped and the match can’t end in an unescaped backslash \. The path must be unique among the paths of all routes of the VirtualServer. Check the location directive for more information.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// A list of policies. The policies override the policies of the same type defined in the spec of the VirtualServer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policies: Option<Vec<VirtualServerRouteSubroutesPolicies>>,
    /// The name of a VirtualServerRoute resource that defines this route. If the VirtualServerRoute belongs to a different namespace than the VirtualServer, you need to include the namespace. For example, tea-namespace/tea.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route: Option<String>,
    /// The default splits configuration for traffic splitting. Must include at least 2 splits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub splits: Option<Vec<VirtualServerRouteSubroutesSplits>>,
}

/// The default action to perform for a request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesAction {
    /// Passes requests to an upstream. The upstream with that name must be defined in the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pass: Option<String>,
    /// Passes requests to an upstream with the ability to modify the request/response (for example, rewrite the URI or modify the headers).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy: Option<VirtualServerRouteSubroutesActionProxy>,
    /// Redirects requests to a provided URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redirect: Option<VirtualServerRouteSubroutesActionRedirect>,
    /// Returns a preconfigured response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "return")]
    pub r#return: Option<VirtualServerRouteSubroutesActionReturn>,
}

/// Passes requests to an upstream with the ability to modify the request/response (for example, rewrite the URI or modify the headers).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesActionProxy {
    /// The request headers modifications.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeaders")]
    pub request_headers: Option<VirtualServerRouteSubroutesActionProxyRequestHeaders>,
    /// The response headers modifications.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeaders")]
    pub response_headers: Option<VirtualServerRouteSubroutesActionProxyResponseHeaders>,
    /// The rewritten URI. If the route path is a regular expression – starts with ~ – the rewritePath can include capture groups with $1-9. For example $1 for the first group, and so on. For more information, check the rewrite example.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rewritePath")]
    pub rewrite_path: Option<String>,
    /// The name of the upstream which the requests will be proxied to. The upstream with that name must be defined in the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub upstream: Option<String>,
}

/// The request headers modifications.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesActionProxyRequestHeaders {
    /// Passes the original request headers to the proxied upstream server.  Default is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pass: Option<bool>,
    /// Allows redefining or appending fields to present request headers passed to the proxied upstream servers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set: Option<Vec<VirtualServerRouteSubroutesActionProxyRequestHeadersSet>>,
}

/// Header defines an HTTP Header.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesActionProxyRequestHeadersSet {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// The response headers modifications.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesActionProxyResponseHeaders {
    /// Adds headers to the response to the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<VirtualServerRouteSubroutesActionProxyResponseHeadersAdd>>,
    /// The headers that will not be passed* in the response to the client from a proxied upstream server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hide: Option<Vec<String>>,
    /// Disables processing of certain headers** to the client from a proxied upstream server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ignore: Option<Vec<String>>,
    /// Allows passing the hidden header fields* to the client from a proxied upstream server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pass: Option<Vec<String>>,
}

/// AddHeader defines an HTTP Header with an optional Always field to use with the add_header NGINX directive.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesActionProxyResponseHeadersAdd {
    /// If set to true, add the header regardless of the response status code**. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub always: Option<bool>,
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Redirects requests to a provided URL.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesActionRedirect {
    /// The status code of a redirect. The allowed values are: 301, 302, 307 or 308. The default is 301.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// The URL to redirect the request to. Supported NGINX variables: $scheme, $http_x_forwarded_proto, $request_uri or $host. Variables must be enclosed in curly braces. For example: ${host}${request_uri}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// Returns a preconfigured response.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesActionReturn {
    /// The body of the response. Supports NGINX variables*. Variables must be enclosed in curly brackets. For example: Request is ${request_uri}\n.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// The status code of the response. The allowed values are: 2XX, 4XX or 5XX. The default is 200.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// The custom headers of the response.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<VirtualServerRouteSubroutesActionReturnHeaders>>,
    /// The MIME type of the response. The default is text/plain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Header defines an HTTP Header.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesActionReturnHeaders {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// ErrorPage defines an ErrorPage in a Route.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesErrorPages {
    /// A list of error status codes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub codes: Option<Vec<i64>>,
    /// The canned response action for the given status codes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redirect: Option<VirtualServerRouteSubroutesErrorPagesRedirect>,
    /// The redirect action for the given status codes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "return")]
    pub r#return: Option<VirtualServerRouteSubroutesErrorPagesReturn>,
}

/// The canned response action for the given status codes.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesErrorPagesRedirect {
    /// The status code of a redirect. The allowed values are: 301, 302, 307 or 308. The default is 301.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// The URL to redirect the request to. Supported NGINX variables: $scheme, $http_x_forwarded_proto, $request_uri or $host. Variables must be enclosed in curly braces. For example: ${host}${request_uri}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// The redirect action for the given status codes.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesErrorPagesReturn {
    /// The body of the response. Supports NGINX variables*. Variables must be enclosed in curly brackets. For example: Request is ${request_uri}\n.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// The status code of the response. The allowed values are: 2XX, 4XX or 5XX. The default is 200.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// The custom headers of the response.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<VirtualServerRouteSubroutesErrorPagesReturnHeaders>>,
    /// The MIME type of the response. The default is text/plain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Header defines an HTTP Header.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesErrorPagesReturnHeaders {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Match defines a match.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatches {
    /// The action to perform for a request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<VirtualServerRouteSubroutesMatchesAction>,
    /// A list of conditions. Must include at least 1 condition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<VirtualServerRouteSubroutesMatchesConditions>>,
    /// The splits configuration for traffic splitting. Must include at least 2 splits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub splits: Option<Vec<VirtualServerRouteSubroutesMatchesSplits>>,
}

/// The action to perform for a request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesAction {
    /// Passes requests to an upstream. The upstream with that name must be defined in the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pass: Option<String>,
    /// Passes requests to an upstream with the ability to modify the request/response (for example, rewrite the URI or modify the headers).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy: Option<VirtualServerRouteSubroutesMatchesActionProxy>,
    /// Redirects requests to a provided URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redirect: Option<VirtualServerRouteSubroutesMatchesActionRedirect>,
    /// Returns a preconfigured response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "return")]
    pub r#return: Option<VirtualServerRouteSubroutesMatchesActionReturn>,
}

/// Passes requests to an upstream with the ability to modify the request/response (for example, rewrite the URI or modify the headers).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesActionProxy {
    /// The request headers modifications.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeaders")]
    pub request_headers: Option<VirtualServerRouteSubroutesMatchesActionProxyRequestHeaders>,
    /// The response headers modifications.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeaders")]
    pub response_headers: Option<VirtualServerRouteSubroutesMatchesActionProxyResponseHeaders>,
    /// The rewritten URI. If the route path is a regular expression – starts with ~ – the rewritePath can include capture groups with $1-9. For example $1 for the first group, and so on. For more information, check the rewrite example.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rewritePath")]
    pub rewrite_path: Option<String>,
    /// The name of the upstream which the requests will be proxied to. The upstream with that name must be defined in the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub upstream: Option<String>,
}

/// The request headers modifications.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesActionProxyRequestHeaders {
    /// Passes the original request headers to the proxied upstream server.  Default is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pass: Option<bool>,
    /// Allows redefining or appending fields to present request headers passed to the proxied upstream servers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set: Option<Vec<VirtualServerRouteSubroutesMatchesActionProxyRequestHeadersSet>>,
}

/// Header defines an HTTP Header.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesActionProxyRequestHeadersSet {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// The response headers modifications.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesActionProxyResponseHeaders {
    /// Adds headers to the response to the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<VirtualServerRouteSubroutesMatchesActionProxyResponseHeadersAdd>>,
    /// The headers that will not be passed* in the response to the client from a proxied upstream server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hide: Option<Vec<String>>,
    /// Disables processing of certain headers** to the client from a proxied upstream server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ignore: Option<Vec<String>>,
    /// Allows passing the hidden header fields* to the client from a proxied upstream server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pass: Option<Vec<String>>,
}

/// AddHeader defines an HTTP Header with an optional Always field to use with the add_header NGINX directive.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesActionProxyResponseHeadersAdd {
    /// If set to true, add the header regardless of the response status code**. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub always: Option<bool>,
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Redirects requests to a provided URL.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesActionRedirect {
    /// The status code of a redirect. The allowed values are: 301, 302, 307 or 308. The default is 301.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// The URL to redirect the request to. Supported NGINX variables: $scheme, $http_x_forwarded_proto, $request_uri or $host. Variables must be enclosed in curly braces. For example: ${host}${request_uri}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// Returns a preconfigured response.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesActionReturn {
    /// The body of the response. Supports NGINX variables*. Variables must be enclosed in curly brackets. For example: Request is ${request_uri}\n.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// The status code of the response. The allowed values are: 2XX, 4XX or 5XX. The default is 200.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// The custom headers of the response.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<VirtualServerRouteSubroutesMatchesActionReturnHeaders>>,
    /// The MIME type of the response. The default is text/plain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Header defines an HTTP Header.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesActionReturnHeaders {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Condition defines a condition in a MatchRule.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesConditions {
    /// The name of an argument. Must consist of alphanumeric characters or _.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub argument: Option<String>,
    /// The name of a cookie. Must consist of alphanumeric characters or _.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<String>,
    /// The name of a header. Must consist of alphanumeric characters or -.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub header: Option<String>,
    /// The value to match the condition against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// The name of an NGINX variable. Must start with $.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variable: Option<String>,
}

/// Split defines a split.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesSplits {
    /// The action to perform for a request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<VirtualServerRouteSubroutesMatchesSplitsAction>,
    /// The weight of an action. Must fall into the range 0..100. The sum of the weights of all splits must be equal to 100.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<i64>,
}

/// The action to perform for a request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesSplitsAction {
    /// Passes requests to an upstream. The upstream with that name must be defined in the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pass: Option<String>,
    /// Passes requests to an upstream with the ability to modify the request/response (for example, rewrite the URI or modify the headers).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy: Option<VirtualServerRouteSubroutesMatchesSplitsActionProxy>,
    /// Redirects requests to a provided URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redirect: Option<VirtualServerRouteSubroutesMatchesSplitsActionRedirect>,
    /// Returns a preconfigured response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "return")]
    pub r#return: Option<VirtualServerRouteSubroutesMatchesSplitsActionReturn>,
}

/// Passes requests to an upstream with the ability to modify the request/response (for example, rewrite the URI or modify the headers).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesSplitsActionProxy {
    /// The request headers modifications.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeaders")]
    pub request_headers: Option<VirtualServerRouteSubroutesMatchesSplitsActionProxyRequestHeaders>,
    /// The response headers modifications.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeaders")]
    pub response_headers: Option<VirtualServerRouteSubroutesMatchesSplitsActionProxyResponseHeaders>,
    /// The rewritten URI. If the route path is a regular expression – starts with ~ – the rewritePath can include capture groups with $1-9. For example $1 for the first group, and so on. For more information, check the rewrite example.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rewritePath")]
    pub rewrite_path: Option<String>,
    /// The name of the upstream which the requests will be proxied to. The upstream with that name must be defined in the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub upstream: Option<String>,
}

/// The request headers modifications.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesSplitsActionProxyRequestHeaders {
    /// Passes the original request headers to the proxied upstream server.  Default is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pass: Option<bool>,
    /// Allows redefining or appending fields to present request headers passed to the proxied upstream servers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set: Option<Vec<VirtualServerRouteSubroutesMatchesSplitsActionProxyRequestHeadersSet>>,
}

/// Header defines an HTTP Header.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesSplitsActionProxyRequestHeadersSet {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// The response headers modifications.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesSplitsActionProxyResponseHeaders {
    /// Adds headers to the response to the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<VirtualServerRouteSubroutesMatchesSplitsActionProxyResponseHeadersAdd>>,
    /// The headers that will not be passed* in the response to the client from a proxied upstream server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hide: Option<Vec<String>>,
    /// Disables processing of certain headers** to the client from a proxied upstream server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ignore: Option<Vec<String>>,
    /// Allows passing the hidden header fields* to the client from a proxied upstream server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pass: Option<Vec<String>>,
}

/// AddHeader defines an HTTP Header with an optional Always field to use with the add_header NGINX directive.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesSplitsActionProxyResponseHeadersAdd {
    /// If set to true, add the header regardless of the response status code**. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub always: Option<bool>,
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Redirects requests to a provided URL.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesSplitsActionRedirect {
    /// The status code of a redirect. The allowed values are: 301, 302, 307 or 308. The default is 301.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// The URL to redirect the request to. Supported NGINX variables: $scheme, $http_x_forwarded_proto, $request_uri or $host. Variables must be enclosed in curly braces. For example: ${host}${request_uri}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// Returns a preconfigured response.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesSplitsActionReturn {
    /// The body of the response. Supports NGINX variables*. Variables must be enclosed in curly brackets. For example: Request is ${request_uri}\n.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// The status code of the response. The allowed values are: 2XX, 4XX or 5XX. The default is 200.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// The custom headers of the response.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<VirtualServerRouteSubroutesMatchesSplitsActionReturnHeaders>>,
    /// The MIME type of the response. The default is text/plain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Header defines an HTTP Header.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesMatchesSplitsActionReturnHeaders {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// PolicyReference references a policy by name and an optional namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesPolicies {
    /// The name of a policy. If the policy doesn’t exist or invalid, NGINX will respond with an error response with the 500 status code.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of a policy. If not specified, the namespace of the VirtualServer resource is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Split defines a split.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesSplits {
    /// The action to perform for a request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<VirtualServerRouteSubroutesSplitsAction>,
    /// The weight of an action. Must fall into the range 0..100. The sum of the weights of all splits must be equal to 100.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<i64>,
}

/// The action to perform for a request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesSplitsAction {
    /// Passes requests to an upstream. The upstream with that name must be defined in the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pass: Option<String>,
    /// Passes requests to an upstream with the ability to modify the request/response (for example, rewrite the URI or modify the headers).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy: Option<VirtualServerRouteSubroutesSplitsActionProxy>,
    /// Redirects requests to a provided URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redirect: Option<VirtualServerRouteSubroutesSplitsActionRedirect>,
    /// Returns a preconfigured response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "return")]
    pub r#return: Option<VirtualServerRouteSubroutesSplitsActionReturn>,
}

/// Passes requests to an upstream with the ability to modify the request/response (for example, rewrite the URI or modify the headers).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesSplitsActionProxy {
    /// The request headers modifications.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeaders")]
    pub request_headers: Option<VirtualServerRouteSubroutesSplitsActionProxyRequestHeaders>,
    /// The response headers modifications.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeaders")]
    pub response_headers: Option<VirtualServerRouteSubroutesSplitsActionProxyResponseHeaders>,
    /// The rewritten URI. If the route path is a regular expression – starts with ~ – the rewritePath can include capture groups with $1-9. For example $1 for the first group, and so on. For more information, check the rewrite example.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rewritePath")]
    pub rewrite_path: Option<String>,
    /// The name of the upstream which the requests will be proxied to. The upstream with that name must be defined in the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub upstream: Option<String>,
}

/// The request headers modifications.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesSplitsActionProxyRequestHeaders {
    /// Passes the original request headers to the proxied upstream server.  Default is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pass: Option<bool>,
    /// Allows redefining or appending fields to present request headers passed to the proxied upstream servers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set: Option<Vec<VirtualServerRouteSubroutesSplitsActionProxyRequestHeadersSet>>,
}

/// Header defines an HTTP Header.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesSplitsActionProxyRequestHeadersSet {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// The response headers modifications.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesSplitsActionProxyResponseHeaders {
    /// Adds headers to the response to the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<VirtualServerRouteSubroutesSplitsActionProxyResponseHeadersAdd>>,
    /// The headers that will not be passed* in the response to the client from a proxied upstream server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hide: Option<Vec<String>>,
    /// Disables processing of certain headers** to the client from a proxied upstream server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ignore: Option<Vec<String>>,
    /// Allows passing the hidden header fields* to the client from a proxied upstream server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pass: Option<Vec<String>>,
}

/// AddHeader defines an HTTP Header with an optional Always field to use with the add_header NGINX directive.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesSplitsActionProxyResponseHeadersAdd {
    /// If set to true, add the header regardless of the response status code**. Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub always: Option<bool>,
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Redirects requests to a provided URL.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesSplitsActionRedirect {
    /// The status code of a redirect. The allowed values are: 301, 302, 307 or 308. The default is 301.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// The URL to redirect the request to. Supported NGINX variables: $scheme, $http_x_forwarded_proto, $request_uri or $host. Variables must be enclosed in curly braces. For example: ${host}${request_uri}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// Returns a preconfigured response.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesSplitsActionReturn {
    /// The body of the response. Supports NGINX variables*. Variables must be enclosed in curly brackets. For example: Request is ${request_uri}\n.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// The status code of the response. The allowed values are: 2XX, 4XX or 5XX. The default is 200.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// The custom headers of the response.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<VirtualServerRouteSubroutesSplitsActionReturnHeaders>>,
    /// The MIME type of the response. The default is text/plain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Header defines an HTTP Header.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteSubroutesSplitsActionReturnHeaders {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Upstream defines an upstream.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteUpstreams {
    /// The name of the backup service of type ExternalName. This will be used when the primary servers are unavailable. Note: The parameter cannot be used along with the random, hash or ip_hash load balancing methods.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub backup: Option<String>,
    /// The port of the backup service. The backup port is required if the backup service name is provided. The port must fall into the range 1..65535.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupPort")]
    pub backup_port: Option<i64>,
    /// Sets the size of the buffer used for reading the first part of a response received from the upstream server. The default is set in the proxy-buffer-size ConfigMap key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "buffer-size")]
    pub buffer_size: Option<String>,
    /// Enables buffering of responses from the upstream server.  The default is set in the proxy-buffering ConfigMap key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub buffering: Option<bool>,
    /// Configures the buffers used for reading a response from the upstream server for a single connection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub buffers: Option<VirtualServerRouteUpstreamsBuffers>,
    /// Sets the maximum allowed size of the client request body. The default is set in the client-max-body-size ConfigMap key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "client-max-body-size")]
    pub client_max_body_size: Option<String>,
    /// The timeout for establishing a connection with an upstream server. The default is specified in the proxy-connect-timeout ConfigMap key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connect-timeout")]
    pub connect_timeout: Option<String>,
    /// The time during which the specified number of unsuccessful attempts to communicate with an upstream server should happen to consider the server unavailable. The default is set in the fail-timeout ConfigMap key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fail-timeout")]
    pub fail_timeout: Option<String>,
    /// The health check configuration for the Upstream. Note: this feature is supported only in NGINX Plus.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    pub health_check: Option<VirtualServerRouteUpstreamsHealthCheck>,
    /// Configures the cache for connections to upstream servers. The value 0 disables the cache. The default is set in the keepalive ConfigMap key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<i64>,
    /// The load balancing method. To use the round-robin method, specify round_robin. The default is specified in the lb-method ConfigMap key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lb-method")]
    pub lb_method: Option<String>,
    /// The maximum number of simultaneous active connections to an upstream server. By default there is no limit. Note: if keepalive connections are enabled, the total number of active and idle keepalive connections to an upstream server may exceed the max_conns value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "max-conns")]
    pub max_conns: Option<i64>,
    /// The number of unsuccessful attempts to communicate with an upstream server that should happen in the duration set by the fail-timeout to consider the server unavailable. The default is set in the max-fails ConfigMap key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "max-fails")]
    pub max_fails: Option<i64>,
    /// The name of the upstream. Must be a valid DNS label as defined in RFC 1035. For example, hello and upstream-123 are valid. The name must be unique among all upstreams of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specifies in which cases a request should be passed to the next upstream server. The default is error timeout.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "next-upstream")]
    pub next_upstream: Option<String>,
    /// The time during which a request can be passed to the next upstream server. The 0 value turns off the time limit. The default is 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "next-upstream-timeout")]
    pub next_upstream_timeout: Option<String>,
    /// The number of possible tries for passing a request to the next upstream server. The 0 value turns off this limit. The default is 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "next-upstream-tries")]
    pub next_upstream_tries: Option<i64>,
    /// Allows proxying requests with NTLM Authentication. In order for NTLM authentication to work, it is necessary to enable keepalive connections to upstream servers using the keepalive field. Note: this feature is supported only in NGINX Plus.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ntlm: Option<bool>,
    /// The port of the service. If the service doesn’t define that port, NGINX will assume the service has zero endpoints and return a 502 response for requests for this upstream. The port must fall into the range 1..65535.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// Configures a queue for an upstream. A client request will be placed into the queue if an upstream server cannot be selected immediately while processing the request. By default, no queue is configured. Note: this feature is supported only in NGINX Plus.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub queue: Option<VirtualServerRouteUpstreamsQueue>,
    /// The timeout for reading a response from an upstream server. The default is specified in the proxy-read-timeout ConfigMap key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "read-timeout")]
    pub read_timeout: Option<String>,
    /// The timeout for transmitting a request to an upstream server. The default is specified in the proxy-send-timeout ConfigMap key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "send-timeout")]
    pub send_timeout: Option<String>,
    /// The name of a service. The service must belong to the same namespace as the resource. If the service doesn’t exist, NGINX will assume the service has zero endpoints and return a 502 response for requests for this upstream. For NGINX Plus only, services of type ExternalName are also supported .
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
    /// The SessionCookie field configures session persistence which allows requests from the same client to be passed to the same upstream server. The information about the designated upstream server is passed in a session cookie generated by NGINX Plus.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionCookie")]
    pub session_cookie: Option<VirtualServerRouteUpstreamsSessionCookie>,
    /// The slow start allows an upstream server to gradually recover its weight from 0 to its nominal value after it has been recovered or became available or when the server becomes available after a period of time it was considered unavailable. By default, the slow start is disabled. Note: The parameter cannot be used along with the random, hash or ip_hash load balancing methods and will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "slow-start")]
    pub slow_start: Option<String>,
    /// Selects the pods within the service using label keys and values. By default, all pods of the service are selected. Note: the specified labels are expected to be present in the pods when they are created. If the pod labels are updated, NGINX Ingress Controller will not see that change until the number of the pods is changed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subselector: Option<BTreeMap<String, String>>,
    /// The TLS configuration for the Upstream.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<VirtualServerRouteUpstreamsTls>,
    /// The type of the upstream. Supported values are http and grpc. The default is http. For gRPC, it is necessary to enable HTTP/2 in the ConfigMap and configure TLS termination in the VirtualServer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// Enables using the Cluster IP and port of the service instead of the default behavior of using the IP and port of the pods. When this field is enabled, the fields that configure NGINX behavior related to multiple upstream servers (like lb-method and next-upstream) will have no effect, as NGINX Ingress Controller will configure NGINX with only one upstream server that will match the service Cluster IP.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "use-cluster-ip")]
    pub use_cluster_ip: Option<bool>,
}

/// Configures the buffers used for reading a response from the upstream server for a single connection.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteUpstreamsBuffers {
    /// Configures the number of buffers. The default is set in the proxy-buffers ConfigMap key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number: Option<i64>,
    /// Configures the size of a buffer. The default is set in the proxy-buffers ConfigMap key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,
}

/// The health check configuration for the Upstream. Note: this feature is supported only in NGINX Plus.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteUpstreamsHealthCheck {
    /// The timeout for establishing a connection with an upstream server. By default, the connect-timeout of the upstream is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connect-timeout")]
    pub connect_timeout: Option<String>,
    /// Enables a health check for an upstream server. The default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// The number of consecutive failed health checks of a particular upstream server after which this server will be considered unhealthy. The default is 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fails: Option<i64>,
    /// The gRPC service to be monitored on the upstream server. Only valid on gRPC type upstreams.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "grpcService")]
    pub grpc_service: Option<String>,
    /// The expected gRPC status code of the upstream server response to the Check method. Configure this field only if your gRPC services do not implement the gRPC health checking protocol. For example, configure 12 if the upstream server responds with 12 (UNIMPLEMENTED) status code. Only valid on gRPC type upstreams.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "grpcStatus")]
    pub grpc_status: Option<i64>,
    /// The request headers used for health check requests. NGINX Plus always sets the Host, User-Agent and Connection headers for health check requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<VirtualServerRouteUpstreamsHealthCheckHeaders>>,
    /// The interval between two consecutive health checks. The default is 5s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// The time within which each health check will be randomly delayed. By default, there is no delay.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jitter: Option<String>,
    /// Enables keepalive connections for health checks and specifies the time during which requests can be processed through one keepalive connection. The default is 60s.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepalive-time")]
    pub keepalive_time: Option<String>,
    /// Require every newly added server to pass all configured health checks before NGINX Plus sends traffic to it. If this is not specified, or is set to false, the server will be initially considered healthy. When combined with slow-start, it gives a new server more time to connect to databases and “warm up” before being asked to handle their full share of traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mandatory: Option<bool>,
    /// The number of consecutive passed health checks of a particular upstream server after which the server will be considered healthy. The default is 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub passes: Option<i64>,
    /// The path used for health check requests. The default is /. This is not configurable for gRPC type upstreams.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Set the initial “up” state for a server after reload if the server was considered healthy before reload. Enabling persistent requires that the mandatory parameter is also set to true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub persistent: Option<bool>,
    /// The port used for health check requests. By default, the server port is used. Note: in contrast with the port of the upstream, this port is not a service port, but a port of a pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// The timeout for reading a response from an upstream server. By default, the read-timeout of the upstream is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "read-timeout")]
    pub read_timeout: Option<String>,
    /// The timeout for transmitting a request to an upstream server. By default, the send-timeout of the upstream is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "send-timeout")]
    pub send_timeout: Option<String>,
    /// The expected response status codes of a health check. By default, the response should have status code 2xx or 3xx. Examples: "200", "! 500", "301-303 307". This not supported for gRPC type upstreams.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statusMatch")]
    pub status_match: Option<String>,
    /// The TLS configuration used for health check requests. By default, the tls field of the upstream is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<VirtualServerRouteUpstreamsHealthCheckTls>,
}

/// Header defines an HTTP Header.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteUpstreamsHealthCheckHeaders {
    /// The name of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// The TLS configuration used for health check requests. By default, the tls field of the upstream is used.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteUpstreamsHealthCheckTls {
    /// Enables HTTPS for requests to upstream servers. The default is False , meaning that HTTP will be used. Note: by default, NGINX will not verify the upstream server certificate. To enable the verification, configure an EgressMTLS Policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
}

/// Configures a queue for an upstream. A client request will be placed into the queue if an upstream server cannot be selected immediately while processing the request. By default, no queue is configured. Note: this feature is supported only in NGINX Plus.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteUpstreamsQueue {
    /// The size of the queue.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<i64>,
    /// The timeout of the queue. A request cannot be queued for a period longer than the timeout. The default is 60s.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
}

/// The SessionCookie field configures session persistence which allows requests from the same client to be passed to the same upstream server. The information about the designated upstream server is passed in a session cookie generated by NGINX Plus.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteUpstreamsSessionCookie {
    /// The domain for which the cookie is set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<String>,
    /// Enables session persistence with a session cookie for an upstream server. The default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// The time for which a browser should keep the cookie. Can be set to the special value max, which will cause the cookie to expire on 31 Dec 2037 23:55:55 GMT.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expires: Option<String>,
    /// Adds the HttpOnly attribute to the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpOnly")]
    pub http_only: Option<bool>,
    /// The name of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The path for which the cookie is set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Adds the SameSite attribute to the cookie. The allowed values are: strict, lax, none
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub samesite: Option<String>,
    /// Adds the Secure attribute to the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secure: Option<bool>,
}

/// The TLS configuration for the Upstream.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteUpstreamsTls {
    /// Enables HTTPS for requests to upstream servers. The default is False , meaning that HTTP will be used. Note: by default, NGINX will not verify the upstream server certificate. To enable the verification, configure an EgressMTLS Policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
}

/// VirtualServerRouteStatus defines the status for the VirtualServerRoute resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteStatus {
    /// Defines the IPs, hostnames and ports used to connect to this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalEndpoints")]
    pub external_endpoints: Option<Vec<VirtualServerRouteStatusExternalEndpoints>>,
    /// The message of the current state of the resource. It can contain more detailed information about the reason.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// The reason of the current state of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    /// Defines how other resources reference this resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "referencedBy")]
    pub referenced_by: Option<String>,
    /// Represents the current state of the resource. There are three possible values: Valid, Invalid and Warning. Valid indicates that the resource has been validated and accepted by the Ingress Controller. Invalid means the resource failed validation or NGINX
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
}

/// ExternalEndpoint defines the IP/ Hostname and ports used to connect to this resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VirtualServerRouteStatusExternalEndpoints {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<String>,
}

