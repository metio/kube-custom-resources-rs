// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/chaos-mesh/chaos-mesh/chaos-mesh.org/v1alpha1/physicalmachinechaos.yaml
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// Spec defines the behavior of a physical machine chaos experiment
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "chaos-mesh.org", version = "v1alpha1", kind = "PhysicalMachineChaos", plural = "physicalmachinechaos")]
#[kube(namespaced)]
#[kube(status = "PhysicalMachineChaosStatus")]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
pub struct PhysicalMachineChaosSpec {
    /// the subAction, generate automatically
    pub action: PhysicalMachineChaosAction,
    /// DEPRECATED: Use Selector instead.
    /// Only one of Address and Selector could be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clock: Option<PhysicalMachineChaosClock>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disk-fill")]
    pub disk_fill: Option<PhysicalMachineChaosDiskFill>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disk-read-payload")]
    pub disk_read_payload: Option<PhysicalMachineChaosDiskReadPayload>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disk-write-payload")]
    pub disk_write_payload: Option<PhysicalMachineChaosDiskWritePayload>,
    /// Duration represents the duration of the chaos action
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-append")]
    pub file_append: Option<PhysicalMachineChaosFileAppend>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-create")]
    pub file_create: Option<PhysicalMachineChaosFileCreate>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-delete")]
    pub file_delete: Option<PhysicalMachineChaosFileDelete>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-modify")]
    pub file_modify: Option<PhysicalMachineChaosFileModify>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-rename")]
    pub file_rename: Option<PhysicalMachineChaosFileRename>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-replace")]
    pub file_replace: Option<PhysicalMachineChaosFileReplace>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http-abort")]
    pub http_abort: Option<PhysicalMachineChaosHttpAbort>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http-config")]
    pub http_config: Option<PhysicalMachineChaosHttpConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http-delay")]
    pub http_delay: Option<PhysicalMachineChaosHttpDelay>,
    /// used for HTTP request, now only support GET
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http-request")]
    pub http_request: Option<PhysicalMachineChaosHttpRequest>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jvm-exception")]
    pub jvm_exception: Option<PhysicalMachineChaosJvmException>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jvm-gc")]
    pub jvm_gc: Option<PhysicalMachineChaosJvmGc>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jvm-latency")]
    pub jvm_latency: Option<PhysicalMachineChaosJvmLatency>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jvm-mysql")]
    pub jvm_mysql: Option<PhysicalMachineChaosJvmMysql>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jvm-return")]
    pub jvm_return: Option<PhysicalMachineChaosJvmReturn>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jvm-rule-data")]
    pub jvm_rule_data: Option<PhysicalMachineChaosJvmRuleData>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jvm-stress")]
    pub jvm_stress: Option<PhysicalMachineChaosJvmStress>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kafka-fill")]
    pub kafka_fill: Option<PhysicalMachineChaosKafkaFill>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kafka-flood")]
    pub kafka_flood: Option<PhysicalMachineChaosKafkaFlood>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kafka-io")]
    pub kafka_io: Option<PhysicalMachineChaosKafkaIo>,
    /// Mode defines the mode to run chaos action.
    /// Supported mode: one / all / fixed / fixed-percent / random-max-percent
    pub mode: PhysicalMachineChaosMode,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-bandwidth")]
    pub network_bandwidth: Option<PhysicalMachineChaosNetworkBandwidth>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-corrupt")]
    pub network_corrupt: Option<PhysicalMachineChaosNetworkCorrupt>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-delay")]
    pub network_delay: Option<PhysicalMachineChaosNetworkDelay>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-dns")]
    pub network_dns: Option<PhysicalMachineChaosNetworkDns>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-down")]
    pub network_down: Option<PhysicalMachineChaosNetworkDown>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-duplicate")]
    pub network_duplicate: Option<PhysicalMachineChaosNetworkDuplicate>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-flood")]
    pub network_flood: Option<PhysicalMachineChaosNetworkFlood>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-loss")]
    pub network_loss: Option<PhysicalMachineChaosNetworkLoss>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-partition")]
    pub network_partition: Option<PhysicalMachineChaosNetworkPartition>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub process: Option<PhysicalMachineChaosProcess>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redis-cacheLimit")]
    pub redis_cache_limit: Option<PhysicalMachineChaosRedisCacheLimit>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redis-expiration")]
    pub redis_expiration: Option<PhysicalMachineChaosRedisExpiration>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redis-penetration")]
    pub redis_penetration: Option<PhysicalMachineChaosRedisPenetration>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redis-restart")]
    pub redis_restart: Option<PhysicalMachineChaosRedisRestart>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redis-stop")]
    pub redis_stop: Option<PhysicalMachineChaosRedisStop>,
    /// RemoteCluster represents the remote cluster where the chaos will be deployed
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remoteCluster")]
    pub remote_cluster: Option<String>,
    /// Selector is used to select physical machines that are used to inject chaos action.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<PhysicalMachineChaosSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stress-cpu")]
    pub stress_cpu: Option<PhysicalMachineChaosStressCpu>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stress-mem")]
    pub stress_mem: Option<PhysicalMachineChaosStressMem>,
    /// the experiment ID
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user_defined: Option<PhysicalMachineChaosUserDefined>,
    /// Value is required when the mode is set to `FixedMode` / `FixedPercentMode` / `RandomMaxPercentMode`.
    /// If `FixedMode`, provide an integer of physical machines to do chaos action.
    /// If `FixedPercentMode`, provide a number from 0-100 to specify the percent of physical machines the server can do chaos action.
    /// IF `RandomMaxPercentMode`,  provide a number from 0-100 to specify the max percent of pods to do chaos action
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vm: Option<PhysicalMachineChaosVm>,
}

/// Spec defines the behavior of a physical machine chaos experiment
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PhysicalMachineChaosAction {
    #[serde(rename = "stress-cpu")]
    StressCpu,
    #[serde(rename = "stress-mem")]
    StressMem,
    #[serde(rename = "disk-read-payload")]
    DiskReadPayload,
    #[serde(rename = "disk-write-payload")]
    DiskWritePayload,
    #[serde(rename = "disk-fill")]
    DiskFill,
    #[serde(rename = "network-corrupt")]
    NetworkCorrupt,
    #[serde(rename = "network-duplicate")]
    NetworkDuplicate,
    #[serde(rename = "network-loss")]
    NetworkLoss,
    #[serde(rename = "network-delay")]
    NetworkDelay,
    #[serde(rename = "network-partition")]
    NetworkPartition,
    #[serde(rename = "network-dns")]
    NetworkDns,
    #[serde(rename = "network-bandwidth")]
    NetworkBandwidth,
    #[serde(rename = "network-flood")]
    NetworkFlood,
    #[serde(rename = "network-down")]
    NetworkDown,
    #[serde(rename = "process")]
    Process,
    #[serde(rename = "jvm-exception")]
    JvmException,
    #[serde(rename = "jvm-gc")]
    JvmGc,
    #[serde(rename = "jvm-latency")]
    JvmLatency,
    #[serde(rename = "jvm-return")]
    JvmReturn,
    #[serde(rename = "jvm-stress")]
    JvmStress,
    #[serde(rename = "jvm-rule-data")]
    JvmRuleData,
    #[serde(rename = "jvm-mysql")]
    JvmMysql,
    #[serde(rename = "clock")]
    Clock,
    #[serde(rename = "redis-expiration")]
    RedisExpiration,
    #[serde(rename = "redis-penetration")]
    RedisPenetration,
    #[serde(rename = "redis-cacheLimit")]
    RedisCacheLimit,
    #[serde(rename = "redis-restart")]
    RedisRestart,
    #[serde(rename = "redis-stop")]
    RedisStop,
    #[serde(rename = "kafka-fill")]
    KafkaFill,
    #[serde(rename = "kafka-flood")]
    KafkaFlood,
    #[serde(rename = "kafka-io")]
    KafkaIo,
    #[serde(rename = "file-create")]
    FileCreate,
    #[serde(rename = "file-modify")]
    FileModify,
    #[serde(rename = "file-delete")]
    FileDelete,
    #[serde(rename = "file-rename")]
    FileRename,
    #[serde(rename = "file-append")]
    FileAppend,
    #[serde(rename = "file-replace")]
    FileReplace,
    #[serde(rename = "vm")]
    Vm,
    #[serde(rename = "user_defined")]
    UserDefined,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosClock {
    /// the identifier of the particular clock on which to act.
    /// More clock description in linux kernel can be found in man page of clock_getres, clock_gettime, clock_settime.
    /// Muti clock ids should be split with ","
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clock-ids-slice")]
    pub clock_ids_slice: Option<String>,
    /// the pid of target program.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i64>,
    /// specifies the length of time offset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "time-offset")]
    pub time_offset: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosDiskFill {
    /// fill disk by fallocate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fill-by-fallocate")]
    pub fill_by_fallocate: Option<bool>,
    /// specifies the location to fill data in. if path not provided,
    /// payload will read/write from/into a temp file, temp file will be deleted after writing
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// specifies how many units of data will write into the file path. support unit: c=1, w=2, b=512, kB=1000,
    /// K=1024, MB=1000*1000, M=1024*1024, GB=1000*1000*1000, G=1024*1024*1024 BYTES. example : 1M | 512kB
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosDiskReadPayload {
    /// specifies the location to fill data in. if path not provided,
    /// payload will read/write from/into a temp file, temp file will be deleted after writing
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// specifies the number of process work on writing, default 1, only 1-255 is valid value
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "payload-process-num")]
    pub payload_process_num: Option<i64>,
    /// specifies how many units of data will write into the file path. support unit: c=1, w=2, b=512, kB=1000,
    /// K=1024, MB=1000*1000, M=1024*1024, GB=1000*1000*1000, G=1024*1024*1024 BYTES. example : 1M | 512kB
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosDiskWritePayload {
    /// specifies the location to fill data in. if path not provided,
    /// payload will read/write from/into a temp file, temp file will be deleted after writing
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// specifies the number of process work on writing, default 1, only 1-255 is valid value
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "payload-process-num")]
    pub payload_process_num: Option<i64>,
    /// specifies how many units of data will write into the file path. support unit: c=1, w=2, b=512, kB=1000,
    /// K=1024, MB=1000*1000, M=1024*1024, GB=1000*1000*1000, G=1024*1024*1024 BYTES. example : 1M | 512kB
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosFileAppend {
    /// Count is the number of times to append the data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<i64>,
    /// Data is the data for append.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    /// FileName is the name of the file to be created, modified, deleted, renamed, or appended.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-name")]
    pub file_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosFileCreate {
    /// DirName is the directory name to create or delete.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dir-name")]
    pub dir_name: Option<String>,
    /// FileName is the name of the file to be created, modified, deleted, renamed, or appended.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-name")]
    pub file_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosFileDelete {
    /// DirName is the directory name to create or delete.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dir-name")]
    pub dir_name: Option<String>,
    /// FileName is the name of the file to be created, modified, deleted, renamed, or appended.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-name")]
    pub file_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosFileModify {
    /// FileName is the name of the file to be created, modified, deleted, renamed, or appended.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-name")]
    pub file_name: Option<String>,
    /// Privilege is the file privilege to be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privilege: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosFileRename {
    /// DestFile is the name to be renamed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dest-file")]
    pub dest_file: Option<String>,
    /// SourceFile is the name need to be renamed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source-file")]
    pub source_file: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosFileReplace {
    /// DestStr is the destination string of the file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dest-string")]
    pub dest_string: Option<String>,
    /// FileName is the name of the file to be created, modified, deleted, renamed, or appended.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-name")]
    pub file_name: Option<String>,
    /// Line is the line number of the file to be replaced.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub line: Option<i64>,
    /// OriginStr is the origin string of the file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "origin-string")]
    pub origin_string: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosHttpAbort {
    /// Code is a rule to select target by http status code in response
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    /// HTTP method
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Match path of Uri with wildcard matches
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The TCP port that the target service listens on
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Composed with one of the port of HTTP connection, we will only attack HTTP connection with port inside proxy_ports
    pub proxy_ports: Vec<i64>,
    /// HTTP target: Request or Response
    pub target: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosHttpConfig {
    /// The config file path
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub file_path: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosHttpDelay {
    /// Code is a rule to select target by http status code in response
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    /// Delay represents the delay of the target request/response
    pub delay: String,
    /// HTTP method
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Match path of Uri with wildcard matches
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The TCP port that the target service listens on
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Composed with one of the port of HTTP connection, we will only attack HTTP connection with port inside proxy_ports
    pub proxy_ports: Vec<i64>,
    /// HTTP target: Request or Response
    pub target: String,
}

/// used for HTTP request, now only support GET
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosHttpRequest {
    /// The number of requests to send
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<i64>,
    /// Enable connection pool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enable-conn-pool")]
    pub enable_conn_pool: Option<bool>,
    /// Request to send"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosJvmException {
    /// Java class
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub class: Option<String>,
    /// the exception which needs to throw for action `exception`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exception: Option<String>,
    /// the method in Java class
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// the pid of Java process which needs to attach
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i64>,
    /// the port of agent server, default 9277
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosJvmGc {
    /// the pid of Java process which needs to attach
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i64>,
    /// the port of agent server, default 9277
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosJvmLatency {
    /// Java class
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub class: Option<String>,
    /// the latency duration for action 'latency', unit ms
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub latency: Option<i64>,
    /// the method in Java class
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// the pid of Java process which needs to attach
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i64>,
    /// the port of agent server, default 9277
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosJvmMysql {
    /// the match database
    /// default value is "", means match all database
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub database: Option<String>,
    /// The exception which needs to throw for action `exception`
    /// or the exception message needs to throw in action `mysql`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exception: Option<String>,
    /// The latency duration for action 'latency'
    /// or the latency duration in action `mysql`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub latency: Option<i64>,
    /// the version of mysql-connector-java, only support 5.X.X(set to "5") and 8.X.X(set to "8") now
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mysqlConnectorVersion")]
    pub mysql_connector_version: Option<String>,
    /// the pid of Java process which needs to attach
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i64>,
    /// the port of agent server, default 9277
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// the match sql type
    /// default value is "", means match all SQL type.
    /// The value can be 'select', 'insert', 'update', 'delete', 'replace'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqlType")]
    pub sql_type: Option<String>,
    /// the match table
    /// default value is "", means match all table
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub table: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosJvmReturn {
    /// Java class
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub class: Option<String>,
    /// the method in Java class
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// the pid of Java process which needs to attach
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i64>,
    /// the port of agent server, default 9277
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// the return value for action 'return'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosJvmRuleData {
    /// the pid of Java process which needs to attach
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i64>,
    /// the port of agent server, default 9277
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// RuleData used to save the rule file's data, will use it when recover
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rule-data")]
    pub rule_data: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosJvmStress {
    /// the CPU core number need to use, only set it when action is stress
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpu-count")]
    pub cpu_count: Option<i64>,
    /// the memory type need to locate, only set it when action is stress, the value can be 'stack' or 'heap'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mem-type")]
    pub mem_type: Option<String>,
    /// the pid of Java process which needs to attach
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i64>,
    /// the port of agent server, default 9277
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosKafkaFill {
    /// The host of kafka server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The max bytes to fill
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytes")]
    pub max_bytes: Option<i64>,
    /// The size of each message
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageSize")]
    pub message_size: Option<i64>,
    /// The password of kafka client
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// The port of kafka server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// The command to reload kafka config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reloadCommand")]
    pub reload_command: Option<String>,
    /// The topic to attack
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
    /// The username of kafka client
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosKafkaFlood {
    /// The host of kafka server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The size of each message
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageSize")]
    pub message_size: Option<i64>,
    /// The password of kafka client
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// The port of kafka server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// The number of worker threads
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub threads: Option<i64>,
    /// The topic to attack
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
    /// The username of kafka client
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosKafkaIo {
    /// The path of server config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configFile")]
    pub config_file: Option<String>,
    /// Make kafka cluster non-readable
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nonReadable")]
    pub non_readable: Option<bool>,
    /// Make kafka cluster non-writable
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nonWritable")]
    pub non_writable: Option<bool>,
    /// The topic to attack
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// Spec defines the behavior of a physical machine chaos experiment
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PhysicalMachineChaosMode {
    #[serde(rename = "one")]
    One,
    #[serde(rename = "all")]
    All,
    #[serde(rename = "fixed")]
    Fixed,
    #[serde(rename = "fixed-percent")]
    FixedPercent,
    #[serde(rename = "random-max-percent")]
    RandomMaxPercent,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosNetworkBandwidth {
    pub buffer: i32,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-address")]
    pub ip_address: Option<String>,
    pub limit: i32,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minburst: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub peakrate: Option<i64>,
    pub rate: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosNetworkCorrupt {
    /// correlation is percentage (10 is 10%)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub correlation: Option<String>,
    /// the network interface to impact
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    /// only impact egress traffic to these destination ports, use a ',' to separate or to indicate the range, such as 80, 8001:8010.
    /// it can only be used in conjunction with -p tcp or -p udp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egress-port")]
    pub egress_port: Option<String>,
    /// only impact traffic to these hostnames
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// only impact egress traffic to these IP addresses
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-address")]
    pub ip_address: Option<String>,
    /// only impact traffic using this IP protocol, supported: tcp, udp, icmp, all
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-protocol")]
    pub ip_protocol: Option<String>,
    /// percentage of packets to corrupt (10 is 10%)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub percent: Option<String>,
    /// only impact egress traffic from these source ports, use a ',' to separate or to indicate the range, such as 80, 8001:8010.
    /// it can only be used in conjunction with -p tcp or -p udp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source-port")]
    pub source_port: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosNetworkDelay {
    /// only the packet which match the tcp flag can be accepted, others will be dropped.
    /// only set when the IPProtocol is tcp, used for partition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accept-tcp-flags")]
    pub accept_tcp_flags: Option<String>,
    /// correlation is percentage (10 is 10%)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub correlation: Option<String>,
    /// the network interface to impact
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    /// only impact egress traffic to these destination ports, use a ',' to separate or to indicate the range, such as 80, 8001:8010.
    /// it can only be used in conjunction with -p tcp or -p udp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egress-port")]
    pub egress_port: Option<String>,
    /// only impact traffic to these hostnames
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// only impact egress traffic to these IP addresses
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-address")]
    pub ip_address: Option<String>,
    /// only impact traffic using this IP protocol, supported: tcp, udp, icmp, all
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-protocol")]
    pub ip_protocol: Option<String>,
    /// jitter time, time units: ns, us (or µs), ms, s, m, h.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jitter: Option<String>,
    /// delay egress time, time units: ns, us (or µs), ms, s, m, h.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub latency: Option<String>,
    /// only impact egress traffic from these source ports, use a ',' to separate or to indicate the range, such as 80, 8001:8010.
    /// it can only be used in conjunction with -p tcp or -p udp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source-port")]
    pub source_port: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosNetworkDns {
    /// map this host to specified IP
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dns-domain-name")]
    pub dns_domain_name: Option<String>,
    /// map specified host to this IP address
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dns-ip")]
    pub dns_ip: Option<String>,
    /// update the DNS server in /etc/resolv.conf with this value
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dns-server")]
    pub dns_server: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosNetworkDown {
    /// The network interface to impact
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    /// NIC down time, time units: ns, us (or µs), ms, s, m, h.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosNetworkDuplicate {
    /// correlation is percentage (10 is 10%)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub correlation: Option<String>,
    /// the network interface to impact
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    /// only impact egress traffic to these destination ports, use a ',' to separate or to indicate the range, such as 80, 8001:8010.
    /// it can only be used in conjunction with -p tcp or -p udp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egress-port")]
    pub egress_port: Option<String>,
    /// only impact traffic to these hostnames
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// only impact egress traffic to these IP addresses
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-address")]
    pub ip_address: Option<String>,
    /// only impact traffic using this IP protocol, supported: tcp, udp, icmp, all
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-protocol")]
    pub ip_protocol: Option<String>,
    /// percentage of packets to duplicate (10 is 10%)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub percent: Option<String>,
    /// only impact egress traffic from these source ports, use a ',' to separate or to indicate the range, such as 80, 8001:8010.
    /// it can only be used in conjunction with -p tcp or -p udp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source-port")]
    pub source_port: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosNetworkFlood {
    /// The number of seconds to run the iperf test
    pub duration: String,
    /// Generate traffic to this IP address
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-address")]
    pub ip_address: Option<String>,
    /// The number of iperf parallel client threads to run
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parallel: Option<i32>,
    /// Generate traffic to this port on the IP address
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<String>,
    /// The speed of network traffic, allows bps, kbps, mbps, gbps, tbps unit. bps means bytes per second
    pub rate: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosNetworkLoss {
    /// correlation is percentage (10 is 10%)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub correlation: Option<String>,
    /// the network interface to impact
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    /// only impact egress traffic to these destination ports, use a ',' to separate or to indicate the range, such as 80, 8001:8010.
    /// it can only be used in conjunction with -p tcp or -p udp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egress-port")]
    pub egress_port: Option<String>,
    /// only impact traffic to these hostnames
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// only impact egress traffic to these IP addresses
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-address")]
    pub ip_address: Option<String>,
    /// only impact traffic using this IP protocol, supported: tcp, udp, icmp, all
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-protocol")]
    pub ip_protocol: Option<String>,
    /// percentage of packets to loss (10 is 10%)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub percent: Option<String>,
    /// only impact egress traffic from these source ports, use a ',' to separate or to indicate the range, such as 80, 8001:8010.
    /// it can only be used in conjunction with -p tcp or -p udp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source-port")]
    pub source_port: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosNetworkPartition {
    /// only the packet which match the tcp flag can be accepted, others will be dropped.
    /// only set when the IPProtocol is tcp, used for partition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accept-tcp-flags")]
    pub accept_tcp_flags: Option<String>,
    /// the network interface to impact
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    /// specifies the partition direction, values can be 'from', 'to'.
    /// 'from' means packets coming from the 'IPAddress' or 'Hostname' and going to your server,
    /// 'to' means packets originating from your server and going to the 'IPAddress' or 'Hostname'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub direction: Option<String>,
    /// only impact traffic to these hostnames
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// only impact egress traffic to these IP addresses
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-address")]
    pub ip_address: Option<String>,
    /// only impact egress traffic to these IP addresses
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-protocol")]
    pub ip_protocol: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosProcess {
    /// the process name or the process ID
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub process: Option<String>,
    /// the command to be run when recovering experiment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recoverCmd")]
    pub recover_cmd: Option<String>,
    /// the signal number to send
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosRedisCacheLimit {
    /// The adress of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub addr: Option<String>,
    /// The size of `maxmemory`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cacheSize")]
    pub cache_size: Option<String>,
    /// The password of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// Specifies maxmemory as a percentage of the original value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub percent: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosRedisExpiration {
    /// The adress of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub addr: Option<String>,
    /// The expiration of the keys
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expiration: Option<String>,
    /// The keys to be expired
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Additional options for `expiration`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub option: Option<String>,
    /// The password of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosRedisPenetration {
    /// The adress of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub addr: Option<String>,
    /// The password of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// The number of requests to be sent
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestNum")]
    pub request_num: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosRedisRestart {
    /// The adress of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub addr: Option<String>,
    /// The path of Sentinel conf
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conf: Option<String>,
    /// The control flag determines whether to flush config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flushConfig")]
    pub flush_config: Option<bool>,
    /// The password of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// The path of `redis-server` command-line tool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redisPath")]
    pub redis_path: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosRedisStop {
    /// The adress of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub addr: Option<String>,
    /// The path of Sentinel conf
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conf: Option<String>,
    /// The control flag determines whether to flush config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flushConfig")]
    pub flush_config: Option<bool>,
    /// The password of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// The path of `redis-server` command-line tool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redisPath")]
    pub redis_path: Option<bool>,
}

/// Selector is used to select physical machines that are used to inject chaos action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosSelector {
    /// Map of string keys and values that can be used to select objects.
    /// A selector based on annotations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "annotationSelectors")]
    pub annotation_selectors: Option<BTreeMap<String, String>>,
    /// a slice of label selector expressions that can be used to select objects.
    /// A list of selectors based on set-based label expressions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expressionSelectors")]
    pub expression_selectors: Option<Vec<PhysicalMachineChaosSelectorExpressionSelectors>>,
    /// Map of string keys and values that can be used to select objects.
    /// A selector based on fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldSelectors")]
    pub field_selectors: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to select objects.
    /// A selector based on labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelectors")]
    pub label_selectors: Option<BTreeMap<String, String>>,
    /// Namespaces is a set of namespace to which objects belong.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// PhysicalMachines is a map of string keys and a set values that used to select physical machines.
    /// The key defines the namespace which physical machine belong,
    /// and each value is a set of physical machine names.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "physicalMachines")]
    pub physical_machines: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosSelectorExpressionSelectors {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosStressCpu {
    /// specifies P percent loading per CPU worker. 0 is effectively a sleep (no load) and 100 is full loading.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub load: Option<i64>,
    /// extend stress-ng options
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<String>>,
    /// specifies N workers to apply the stressor.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workers: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosStressMem {
    /// extend stress-ng options
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<String>>,
    /// specifies N bytes consumed per vm worker, default is the total available memory.
    /// One can specify the size as % of total available memory or in units of B, KB/KiB, MB/MiB, GB/GiB, TB/TiB..
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosUserDefined {
    /// The command to be executed when attack
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "attackCmd")]
    pub attack_cmd: Option<String>,
    /// The command to be executed when recover
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recoverCmd")]
    pub recover_cmd: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosVm {
    /// The name of the VM to be injected
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vm-name")]
    pub vm_name: Option<String>,
}

/// Most recently observed status of the chaos experiment
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosStatus {
    /// Conditions represents the current global condition of the chaos
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<PhysicalMachineChaosStatusConditions>>,
    /// Experiment records the last experiment state.
    pub experiment: PhysicalMachineChaosStatusExperiment,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosStatusConditions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    pub status: String,
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Experiment records the last experiment state.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosStatusExperiment {
    /// Records are used to track the running status
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerRecords")]
    pub container_records: Option<Vec<PhysicalMachineChaosStatusExperimentContainerRecords>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredPhase")]
    pub desired_phase: Option<PhysicalMachineChaosStatusExperimentDesiredPhase>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosStatusExperimentContainerRecords {
    /// Events are the essential details about the injections and recoveries
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub events: Option<Vec<PhysicalMachineChaosStatusExperimentContainerRecordsEvents>>,
    pub id: String,
    /// InjectedCount is a counter to record the sum of successful injections
    #[serde(rename = "injectedCount")]
    pub injected_count: i64,
    pub phase: String,
    /// RecoveredCount is a counter to record the sum of successful recoveries
    #[serde(rename = "recoveredCount")]
    pub recovered_count: i64,
    #[serde(rename = "selectorKey")]
    pub selector_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PhysicalMachineChaosStatusExperimentContainerRecordsEvents {
    /// Message is the detail message, e.g. the reason why we failed to inject the chaos
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Operation represents the operation we are doing, when we crate this event
    pub operation: String,
    /// Timestamp is time when we create this event
    pub timestamp: String,
    /// Type means the stage of this event
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Experiment records the last experiment state.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PhysicalMachineChaosStatusExperimentDesiredPhase {
    Run,
    Stop,
}

