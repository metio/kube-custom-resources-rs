apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: dittos.iot.eclipse.org
spec:
  group: iot.eclipse.org
  names:
    categories: []
    kind: Ditto
    plural: dittos
    shortNames: []
    singular: ditto
  scope: Namespaced
  versions:
  - additionalPrinterColumns:
    - jsonPath: .status.phase
      name: Phase
      type: string
    - jsonPath: .status.message
      name: Message
      type: string
    name: v1alpha1
    schema:
      openAPIV3Schema:
        description: Auto-generated derived type for DittoSpec via `CustomResource`
        properties:
          spec:
            properties:
              createDefaultUser:
                description: |-
                  Create the default "ditto" user when initially deploying.

                  This has no effect when using OAuth2.
                nullable: true
                type: boolean
              devops:
                description: Devops endpoint
                nullable: true
                properties:
                  expose:
                    type: boolean
                  insecure:
                    type: boolean
                  password:
                    nullable: true
                    oneOf:
                    - required:
                      - value
                    - required:
                      - secret
                    - required:
                      - configMap
                    properties:
                      configMap:
                        description: Selects a key from a ConfigMap.
                        properties:
                          key:
                            description: The key to select.
                            type: string
                          name:
                            description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'
                            type: string
                          optional:
                            description: Specify whether the ConfigMap or its key must be defined
                            type: boolean
                        required:
                        - key
                        type: object
                      secret:
                        description: SecretKeySelector selects a key of a Secret.
                        properties:
                          key:
                            description: The key of the secret to select from.  Must be a valid secret key.
                            type: string
                          name:
                            description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'
                            type: string
                          optional:
                            description: Specify whether the Secret or its key must be defined
                            type: boolean
                        required:
                        - key
                        type: object
                      value:
                        type: string
                    type: object
                  statusPassword:
                    nullable: true
                    oneOf:
                    - required:
                      - value
                    - required:
                      - secret
                    - required:
                      - configMap
                    properties:
                      configMap:
                        description: Selects a key from a ConfigMap.
                        properties:
                          key:
                            description: The key to select.
                            type: string
                          name:
                            description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'
                            type: string
                          optional:
                            description: Specify whether the ConfigMap or its key must be defined
                            type: boolean
                        required:
                        - key
                        type: object
                      secret:
                        description: SecretKeySelector selects a key of a Secret.
                        properties:
                          key:
                            description: The key of the secret to select from.  Must be a valid secret key.
                            type: string
                          name:
                            description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'
                            type: string
                          optional:
                            description: Specify whether the Secret or its key must be defined
                            type: boolean
                        required:
                        - key
                        type: object
                      value:
                        type: string
                    type: object
                type: object
              disableInfraProxy:
                description: Don't expose infra endpoints
                type: boolean
              disableWelcomePage:
                description: Allow disabling the welcome page
                type: boolean
              ingress:
                description: |-
                  Configure ingress options

                  If the field is missing, no ingress resource is being created.
                nullable: true
                properties:
                  annotations:
                    additionalProperties:
                      type: string
                    description: |-
                      Annotations which should be applied to the ingress resources.

                      The annotations will be set to the resource, not merged. All changes done on the ingress resource itself will be overridden.

                      If no annotations are configured, reasonable defaults will be used instead. You can prevent this by setting a single dummy annotation.
                    type: object
                  className:
                    description: The optional ingress class name.
                    nullable: true
                    type: string
                  host:
                    description: |-
                      The host of the ingress resource.

                      This is required if the ingress resource should be created by the operator
                    type: string
                required:
                - host
                type: object
              kafka:
                description: Kafka options
                nullable: true
                properties:
                  consumerThrottlingLimit:
                    format: uint32
                    minimum: 0.0
                    nullable: true
                    type: integer
                type: object
              keycloak:
                description: Enable and configure keycloak integration.
                nullable: true
                properties:
                  clientId:
                    oneOf:
                    - required:
                      - value
                    - required:
                      - secret
                    - required:
                      - configMap
                    properties:
                      configMap:
                        description: Selects a key from a ConfigMap.
                        properties:
                          key:
                            description: The key to select.
                            type: string
                          name:
                            description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'
                            type: string
                          optional:
                            description: Specify whether the ConfigMap or its key must be defined
                            type: boolean
                        required:
                        - key
                        type: object
                      secret:
                        description: SecretKeySelector selects a key of a Secret.
                        properties:
                          key:
                            description: The key of the secret to select from.  Must be a valid secret key.
                            type: string
                          name:
                            description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'
                            type: string
                          optional:
                            description: Specify whether the Secret or its key must be defined
                            type: boolean
                        required:
                        - key
                        type: object
                      value:
                        type: string
                    type: object
                  clientSecret:
                    oneOf:
                    - required:
                      - value
                    - required:
                      - secret
                    - required:
                      - configMap
                    properties:
                      configMap:
                        description: Selects a key from a ConfigMap.
                        properties:
                          key:
                            description: The key to select.
                            type: string
                          name:
                            description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'
                            type: string
                          optional:
                            description: Specify whether the ConfigMap or its key must be defined
                            type: boolean
                        required:
                        - key
                        type: object
                      secret:
                        description: SecretKeySelector selects a key of a Secret.
                        properties:
                          key:
                            description: The key of the secret to select from.  Must be a valid secret key.
                            type: string
                          name:
                            description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'
                            type: string
                          optional:
                            description: Specify whether the Secret or its key must be defined
                            type: boolean
                        required:
                        - key
                        type: object
                      value:
                        type: string
                    type: object
                  description:
                    description: Description of this login option.
                    nullable: true
                    type: string
                  disableProxy:
                    type: boolean
                  groups:
                    items:
                      type: string
                    type: array
                  label:
                    description: Label when referencing this login option.
                    nullable: true
                    type: string
                  realm:
                    type: string
                  redirectUrl:
                    description: Allow overriding the redirect URL.
                    nullable: true
                    type: string
                  url:
                    type: string
                required:
                - clientId
                - clientSecret
                - realm
                - url
                type: object
              metrics:
                default:
                  enabled: false
                description: Metrics configuration
                properties:
                  enabled:
                    default: false
                    description: Enable metrics integration
                    type: boolean
                type: object
              mongoDb:
                default:
                  host: mongodb
                  port: 27017
                properties:
                  database:
                    description: The optional database name used to connect, defaults to "ditto".
                    nullable: true
                    oneOf:
                    - required:
                      - value
                    - required:
                      - secret
                    - required:
                      - configMap
                    properties:
                      configMap:
                        description: Selects a key from a ConfigMap.
                        properties:
                          key:
                            description: The key to select.
                            type: string
                          name:
                            description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'
                            type: string
                          optional:
                            description: Specify whether the ConfigMap or its key must be defined
                            type: boolean
                        required:
                        - key
                        type: object
                      secret:
                        description: SecretKeySelector selects a key of a Secret.
                        properties:
                          key:
                            description: The key of the secret to select from.  Must be a valid secret key.
                            type: string
                          name:
                            description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'
                            type: string
                          optional:
                            description: Specify whether the Secret or its key must be defined
                            type: boolean
                        required:
                        - key
                        type: object
                      value:
                        type: string
                    type: object
                  host:
                    default: mongodb
                    description: The hostname of the MongoDB instance.
                    type: string
                  password:
                    description: The password used to connect to the MongoDB instance.
                    nullable: true
                    oneOf:
                    - required:
                      - value
                    - required:
                      - secret
                    - required:
                      - configMap
                    properties:
                      configMap:
                        description: Selects a key from a ConfigMap.
                        properties:
                          key:
                            description: The key to select.
                            type: string
                          name:
                            description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'
                            type: string
                          optional:
                            description: Specify whether the ConfigMap or its key must be defined
                            type: boolean
                        required:
                        - key
                        type: object
                      secret:
                        description: SecretKeySelector selects a key of a Secret.
                        properties:
                          key:
                            description: The key of the secret to select from.  Must be a valid secret key.
                            type: string
                          name:
                            description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'
                            type: string
                          optional:
                            description: Specify whether the Secret or its key must be defined
                            type: boolean
                        required:
                        - key
                        type: object
                      value:
                        type: string
                    type: object
                  port:
                    default: 27017
                    description: The port name of the MongoDB instance.
                    format: uint16
                    minimum: 0.0
                    type: integer
                  username:
                    description: The username used to connect to the MongoDB instance.
                    nullable: true
                    oneOf:
                    - required:
                      - value
                    - required:
                      - secret
                    - required:
                      - configMap
                    properties:
                      configMap:
                        description: Selects a key from a ConfigMap.
                        properties:
                          key:
                            description: The key to select.
                            type: string
                          name:
                            description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'
                            type: string
                          optional:
                            description: Specify whether the ConfigMap or its key must be defined
                            type: boolean
                        required:
                        - key
                        type: object
                      secret:
                        description: SecretKeySelector selects a key of a Secret.
                        properties:
                          key:
                            description: The key of the secret to select from.  Must be a valid secret key.
                            type: string
                          name:
                            description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'
                            type: string
                          optional:
                            description: Specify whether the Secret or its key must be defined
                            type: boolean
                        required:
                        - key
                        type: object
                      value:
                        type: string
                    type: object
                type: object
              oauth:
                description: Provide additional OAuth configuration
                nullable: true
                properties:
                  issuers:
                    additionalProperties:
                      properties:
                        subjects:
                          items:
                            type: string
                          type: array
                        url:
                          type: string
                      required:
                      - url
                      type: object
                    type: object
                type: object
              openApi:
                description: Influence some options of the hosted OpenAPI spec.
                nullable: true
                properties:
                  serverLabel:
                    nullable: true
                    type: string
                type: object
              pullPolicy:
                description: |-
                  Override the imagePullPolicy

                  By default this will use Always if the image version is ":latest" and IfNotPresent otherwise
                nullable: true
                type: string
              registry:
                description: Allow to override the Ditto container registry
                nullable: true
                type: string
              services:
                default:
                  concierge:
                    resources: null
                  connectivity:
                    resources: null
                  gateway:
                    resources: null
                  policies:
                    resources: null
                  things:
                    resources: null
                  thingsSearch:
                    resources: null
                description: Services configuration
                properties:
                  concierge:
                    default:
                      resources: null
                    description: The concierge service
                    properties:
                      additionalProperties:
                        additionalProperties:
                          type: string
                        description: |-
                          Additional system properties, which will be appended to the list of system properties.

                          Note: Setting arbitrary system properties may break the deployment and may also not be compatible with future versions.
                        type: object
                      appLogLevel:
                        description: Allow configuring the application log level.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                      logLevel:
                        description: Allow configuring all log levels.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                      replicas:
                        description: Number of replicas. Defaults to one.
                        format: uint32
                        minimum: 0.0
                        nullable: true
                        type: integer
                      resources:
                        description: Service resource limits
                        nullable: true
                        properties:
                          limits:
                            additionalProperties:
                              description: |-
                                Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.

                                The serialization format is:

                                <quantity>        ::= <signedNumber><suffix>
                                  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
                                <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
                                  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
                                <decimalSI>       ::= m | "" | k | M | G | T | P | E
                                  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
                                <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

                                No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

                                When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

                                Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
                                  a. No precision is lost
                                  b. No fractional digits will be emitted
                                  c. The exponent (or suffix) is as large as possible.
                                The sign will be omitted unless the number is negative.

                                Examples:
                                  1.5 will be serialized as "1500m"
                                  1.5Gi will be serialized as "1536Mi"

                                Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

                                Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

                                This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
                              type: string
                            description: 'Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/'
                            type: object
                          requests:
                            additionalProperties:
                              description: |-
                                Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.

                                The serialization format is:

                                <quantity>        ::= <signedNumber><suffix>
                                  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
                                <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
                                  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
                                <decimalSI>       ::= m | "" | k | M | G | T | P | E
                                  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
                                <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

                                No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

                                When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

                                Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
                                  a. No precision is lost
                                  b. No fractional digits will be emitted
                                  c. The exponent (or suffix) is as large as possible.
                                The sign will be omitted unless the number is negative.

                                Examples:
                                  1.5 will be serialized as "1500m"
                                  1.5Gi will be serialized as "1536Mi"

                                Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

                                Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

                                This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
                              type: string
                            description: 'Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/'
                            type: object
                        type: object
                      rootLogLevel:
                        description: Allow configuring the root log level.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                    type: object
                  connectivity:
                    default:
                      resources: null
                    description: The connectivity service
                    properties:
                      additionalProperties:
                        additionalProperties:
                          type: string
                        description: |-
                          Additional system properties, which will be appended to the list of system properties.

                          Note: Setting arbitrary system properties may break the deployment and may also not be compatible with future versions.
                        type: object
                      appLogLevel:
                        description: Allow configuring the application log level.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                      logLevel:
                        description: Allow configuring all log levels.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                      replicas:
                        description: Number of replicas. Defaults to one.
                        format: uint32
                        minimum: 0.0
                        nullable: true
                        type: integer
                      resources:
                        description: Service resource limits
                        nullable: true
                        properties:
                          limits:
                            additionalProperties:
                              description: |-
                                Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.

                                The serialization format is:

                                <quantity>        ::= <signedNumber><suffix>
                                  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
                                <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
                                  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
                                <decimalSI>       ::= m | "" | k | M | G | T | P | E
                                  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
                                <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

                                No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

                                When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

                                Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
                                  a. No precision is lost
                                  b. No fractional digits will be emitted
                                  c. The exponent (or suffix) is as large as possible.
                                The sign will be omitted unless the number is negative.

                                Examples:
                                  1.5 will be serialized as "1500m"
                                  1.5Gi will be serialized as "1536Mi"

                                Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

                                Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

                                This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
                              type: string
                            description: 'Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/'
                            type: object
                          requests:
                            additionalProperties:
                              description: |-
                                Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.

                                The serialization format is:

                                <quantity>        ::= <signedNumber><suffix>
                                  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
                                <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
                                  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
                                <decimalSI>       ::= m | "" | k | M | G | T | P | E
                                  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
                                <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

                                No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

                                When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

                                Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
                                  a. No precision is lost
                                  b. No fractional digits will be emitted
                                  c. The exponent (or suffix) is as large as possible.
                                The sign will be omitted unless the number is negative.

                                Examples:
                                  1.5 will be serialized as "1500m"
                                  1.5Gi will be serialized as "1536Mi"

                                Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

                                Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

                                This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
                              type: string
                            description: 'Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/'
                            type: object
                        type: object
                      rootLogLevel:
                        description: Allow configuring the root log level.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                    type: object
                  gateway:
                    default:
                      resources: null
                    description: The gateway service
                    properties:
                      additionalProperties:
                        additionalProperties:
                          type: string
                        description: |-
                          Additional system properties, which will be appended to the list of system properties.

                          Note: Setting arbitrary system properties may break the deployment and may also not be compatible with future versions.
                        type: object
                      appLogLevel:
                        description: Allow configuring the application log level.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                      logLevel:
                        description: Allow configuring all log levels.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                      replicas:
                        description: Number of replicas. Defaults to one.
                        format: uint32
                        minimum: 0.0
                        nullable: true
                        type: integer
                      resources:
                        description: Service resource limits
                        nullable: true
                        properties:
                          limits:
                            additionalProperties:
                              description: |-
                                Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.

                                The serialization format is:

                                <quantity>        ::= <signedNumber><suffix>
                                  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
                                <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
                                  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
                                <decimalSI>       ::= m | "" | k | M | G | T | P | E
                                  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
                                <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

                                No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

                                When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

                                Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
                                  a. No precision is lost
                                  b. No fractional digits will be emitted
                                  c. The exponent (or suffix) is as large as possible.
                                The sign will be omitted unless the number is negative.

                                Examples:
                                  1.5 will be serialized as "1500m"
                                  1.5Gi will be serialized as "1536Mi"

                                Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

                                Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

                                This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
                              type: string
                            description: 'Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/'
                            type: object
                          requests:
                            additionalProperties:
                              description: |-
                                Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.

                                The serialization format is:

                                <quantity>        ::= <signedNumber><suffix>
                                  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
                                <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
                                  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
                                <decimalSI>       ::= m | "" | k | M | G | T | P | E
                                  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
                                <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

                                No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

                                When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

                                Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
                                  a. No precision is lost
                                  b. No fractional digits will be emitted
                                  c. The exponent (or suffix) is as large as possible.
                                The sign will be omitted unless the number is negative.

                                Examples:
                                  1.5 will be serialized as "1500m"
                                  1.5Gi will be serialized as "1536Mi"

                                Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

                                Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

                                This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
                              type: string
                            description: 'Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/'
                            type: object
                        type: object
                      rootLogLevel:
                        description: Allow configuring the root log level.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                    type: object
                  policies:
                    default:
                      resources: null
                    description: The policies service
                    properties:
                      additionalProperties:
                        additionalProperties:
                          type: string
                        description: |-
                          Additional system properties, which will be appended to the list of system properties.

                          Note: Setting arbitrary system properties may break the deployment and may also not be compatible with future versions.
                        type: object
                      appLogLevel:
                        description: Allow configuring the application log level.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                      logLevel:
                        description: Allow configuring all log levels.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                      replicas:
                        description: Number of replicas. Defaults to one.
                        format: uint32
                        minimum: 0.0
                        nullable: true
                        type: integer
                      resources:
                        description: Service resource limits
                        nullable: true
                        properties:
                          limits:
                            additionalProperties:
                              description: |-
                                Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.

                                The serialization format is:

                                <quantity>        ::= <signedNumber><suffix>
                                  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
                                <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
                                  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
                                <decimalSI>       ::= m | "" | k | M | G | T | P | E
                                  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
                                <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

                                No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

                                When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

                                Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
                                  a. No precision is lost
                                  b. No fractional digits will be emitted
                                  c. The exponent (or suffix) is as large as possible.
                                The sign will be omitted unless the number is negative.

                                Examples:
                                  1.5 will be serialized as "1500m"
                                  1.5Gi will be serialized as "1536Mi"

                                Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

                                Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

                                This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
                              type: string
                            description: 'Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/'
                            type: object
                          requests:
                            additionalProperties:
                              description: |-
                                Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.

                                The serialization format is:

                                <quantity>        ::= <signedNumber><suffix>
                                  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
                                <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
                                  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
                                <decimalSI>       ::= m | "" | k | M | G | T | P | E
                                  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
                                <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

                                No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

                                When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

                                Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
                                  a. No precision is lost
                                  b. No fractional digits will be emitted
                                  c. The exponent (or suffix) is as large as possible.
                                The sign will be omitted unless the number is negative.

                                Examples:
                                  1.5 will be serialized as "1500m"
                                  1.5Gi will be serialized as "1536Mi"

                                Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

                                Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

                                This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
                              type: string
                            description: 'Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/'
                            type: object
                        type: object
                      rootLogLevel:
                        description: Allow configuring the root log level.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                    type: object
                  things:
                    default:
                      resources: null
                    description: The things service
                    properties:
                      additionalProperties:
                        additionalProperties:
                          type: string
                        description: |-
                          Additional system properties, which will be appended to the list of system properties.

                          Note: Setting arbitrary system properties may break the deployment and may also not be compatible with future versions.
                        type: object
                      appLogLevel:
                        description: Allow configuring the application log level.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                      logLevel:
                        description: Allow configuring all log levels.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                      replicas:
                        description: Number of replicas. Defaults to one.
                        format: uint32
                        minimum: 0.0
                        nullable: true
                        type: integer
                      resources:
                        description: Service resource limits
                        nullable: true
                        properties:
                          limits:
                            additionalProperties:
                              description: |-
                                Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.

                                The serialization format is:

                                <quantity>        ::= <signedNumber><suffix>
                                  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
                                <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
                                  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
                                <decimalSI>       ::= m | "" | k | M | G | T | P | E
                                  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
                                <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

                                No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

                                When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

                                Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
                                  a. No precision is lost
                                  b. No fractional digits will be emitted
                                  c. The exponent (or suffix) is as large as possible.
                                The sign will be omitted unless the number is negative.

                                Examples:
                                  1.5 will be serialized as "1500m"
                                  1.5Gi will be serialized as "1536Mi"

                                Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

                                Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

                                This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
                              type: string
                            description: 'Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/'
                            type: object
                          requests:
                            additionalProperties:
                              description: |-
                                Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.

                                The serialization format is:

                                <quantity>        ::= <signedNumber><suffix>
                                  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
                                <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
                                  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
                                <decimalSI>       ::= m | "" | k | M | G | T | P | E
                                  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
                                <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

                                No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

                                When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

                                Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
                                  a. No precision is lost
                                  b. No fractional digits will be emitted
                                  c. The exponent (or suffix) is as large as possible.
                                The sign will be omitted unless the number is negative.

                                Examples:
                                  1.5 will be serialized as "1500m"
                                  1.5Gi will be serialized as "1536Mi"

                                Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

                                Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

                                This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
                              type: string
                            description: 'Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/'
                            type: object
                        type: object
                      rootLogLevel:
                        description: Allow configuring the root log level.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                    type: object
                  thingsSearch:
                    default:
                      resources: null
                    description: The things search service
                    properties:
                      additionalProperties:
                        additionalProperties:
                          type: string
                        description: |-
                          Additional system properties, which will be appended to the list of system properties.

                          Note: Setting arbitrary system properties may break the deployment and may also not be compatible with future versions.
                        type: object
                      appLogLevel:
                        description: Allow configuring the application log level.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                      logLevel:
                        description: Allow configuring all log levels.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                      replicas:
                        description: Number of replicas. Defaults to one.
                        format: uint32
                        minimum: 0.0
                        nullable: true
                        type: integer
                      resources:
                        description: Service resource limits
                        nullable: true
                        properties:
                          limits:
                            additionalProperties:
                              description: |-
                                Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.

                                The serialization format is:

                                <quantity>        ::= <signedNumber><suffix>
                                  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
                                <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
                                  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
                                <decimalSI>       ::= m | "" | k | M | G | T | P | E
                                  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
                                <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

                                No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

                                When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

                                Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
                                  a. No precision is lost
                                  b. No fractional digits will be emitted
                                  c. The exponent (or suffix) is as large as possible.
                                The sign will be omitted unless the number is negative.

                                Examples:
                                  1.5 will be serialized as "1500m"
                                  1.5Gi will be serialized as "1536Mi"

                                Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

                                Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

                                This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
                              type: string
                            description: 'Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/'
                            type: object
                          requests:
                            additionalProperties:
                              description: |-
                                Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.

                                The serialization format is:

                                <quantity>        ::= <signedNumber><suffix>
                                  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
                                <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
                                  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
                                <decimalSI>       ::= m | "" | k | M | G | T | P | E
                                  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
                                <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

                                No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

                                When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

                                Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
                                  a. No precision is lost
                                  b. No fractional digits will be emitted
                                  c. The exponent (or suffix) is as large as possible.
                                The sign will be omitted unless the number is negative.

                                Examples:
                                  1.5 will be serialized as "1500m"
                                  1.5Gi will be serialized as "1536Mi"

                                Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

                                Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

                                This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
                              type: string
                            description: 'Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/'
                            type: object
                        type: object
                      rootLogLevel:
                        description: Allow configuring the root log level.
                        enum:
                        - trace
                        - debug
                        - info
                        - warn
                        - error
                        nullable: true
                        type: string
                    type: object
                type: object
              swaggerUi:
                description: Influence some options of the hosted SwaggerUI.
                nullable: true
                properties:
                  disable:
                    type: boolean
                  image:
                    nullable: true
                    type: string
                type: object
              version:
                description: Allow to override the Ditto image version.
                nullable: true
                type: string
            type: object
          status:
            nullable: true
            properties:
              conditions:
                description: Status conditions
                items:
                  description: Condition contains details for one aspect of the current state of this API Resource.
                  properties:
                    lastTransitionTime:
                      description: lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                      format: date-time
                      type: string
                    message:
                      description: message is a human readable message indicating details about the transition. This may be an empty string.
                      type: string
                    observedGeneration:
                      description: observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                      format: int64
                      type: integer
                    reason:
                      description: reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                      type: string
                    status:
                      description: status of the condition, one of True, False, Unknown.
                      type: string
                    type:
                      description: type of condition in CamelCase or in foo.example.com/CamelCase.
                      type: string
                  required:
                  - lastTransitionTime
                  - message
                  - reason
                  - status
                  - type
                  type: object
                type: array
              message:
                description: An optional message
                nullable: true
                type: string
              phase:
                default: ''
                description: The phase the deployment is in.
                type: string
            type: object
        required:
        - spec
        title: Ditto
        type: object
    served: true
    storage: true
    subresources:
      status: {}
